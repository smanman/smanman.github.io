<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>快来地学习canvas吧 | 满天鑫</title><meta name="keywords" content="前端,canvas"><meta name="author" content="满天鑫"><meta name="copyright" content="满天鑫"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Canvas概述&lt;canvas&gt; 是 HTML5 新增的，一个可以使用脚本(通常为JavaScript)在其中绘制图像的 HTML 元素。它可以用来制作照片集或者制作简单(也不是那么简单)的动画，甚至可以进行实时视频处理和渲染。 创建Canvas&lt;canvas&gt;会创建一个固定大小的画布，会公开一个或多个 渲染上下文(画笔)，使用 渲染上下文来绘制和处理要展示的内容。 &amp;lt">
<meta property="og:type" content="article">
<meta property="og:title" content="快来地学习canvas吧">
<meta property="og:url" content="https://smanman.github.io/post/40cf0c06.html">
<meta property="og:site_name" content="满天鑫">
<meta property="og:description" content="Canvas概述&lt;canvas&gt; 是 HTML5 新增的，一个可以使用脚本(通常为JavaScript)在其中绘制图像的 HTML 元素。它可以用来制作照片集或者制作简单(也不是那么简单)的动画，甚至可以进行实时视频处理和渲染。 创建Canvas&lt;canvas&gt;会创建一个固定大小的画布，会公开一个或多个 渲染上下文(画笔)，使用 渲染上下文来绘制和处理要展示的内容。 &amp;lt">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082219.jpg">
<meta property="article:published_time" content="2021-11-19T14:39:00.000Z">
<meta property="article:modified_time" content="2022-11-27T09:16:30.311Z">
<meta property="article:author" content="满天鑫">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="canvas">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082219.jpg"><link rel="shortcut icon" href="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210805191028.png"><link rel="canonical" href="https://smanman.github.io/post/40cf0c06"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '快来地学习canvas吧',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-27 17:16:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/ali_icon.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mogai.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="满天鑫" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202406071141762.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">99</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082219.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">满天鑫</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">快来地学习canvas吧</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-19T14:39:00.000Z" title="发表于 2021-11-19 22:39:00">2021-11-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-27T09:16:30.311Z" title="更新于 2022-11-27 17:16:30">2022-11-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/canvas/">canvas</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>54分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="快来地学习canvas吧"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Canvas概述"><a href="#Canvas概述" class="headerlink" title="Canvas概述"></a>Canvas概述</h1><p><code>&lt;canvas&gt; </code>是 HTML5 新增的，一个可以使用脚本(通常为JavaScript)在其中绘制图像的 HTML 元素。它可以用来制作照片集或者制作简单(也不是那么简单)的动画，甚至可以进行实时视频处理和渲染。</p>
<h2 id="创建Canvas"><a href="#创建Canvas" class="headerlink" title="创建Canvas"></a>创建Canvas</h2><p><code>&lt;canvas&gt;</code>会创建一个固定大小的画布，会公开一个或多个 渲染上下文(画笔)，使用 渲染上下文来绘制和处理要展示的内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中width和height并不是指canvas的真正尺寸，而是指canvas的精度，即将整个画布平分为200*200个像素点，真正指定canvas尺寸大小可以由CSS指定</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#canvas</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="渲染上下文"><a href="#渲染上下文" class="headerlink" title="渲染上下文"></a>渲染上下文</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvas&#x27;</span>) <span class="comment">// 获取canvas元素 -&gt; HTMLCanvasElement</span></span><br><span class="line"><span class="keyword">let</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>) <span class="comment">// 获取到canvas上下文(画笔) -&gt; CanvasRenderingContext2D</span></span><br></pre></td></tr></table></figure>

<h2 id="检测浏览器是否支持"><a href="#检测浏览器是否支持" class="headerlink" title="检测浏览器是否支持"></a>检测浏览器是否支持</h2><p>由于canvas是HTML5新出的一个标签，有些老牌浏览器可能不支持，因此需要检测浏览器是否支持canvas，再进行后续操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, eventWindowLoaded, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eventWindowLoaded</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  canvasApp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">canvasSupport</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!e.getContext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">canvasApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> myCanvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!canvasSupport(myCanvas)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ctx = myCanvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">drawScreen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里开始绘制</span></span><br><span class="line">  &#125;</span><br><span class="line">  drawScreen();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栅格和坐标空间"><a href="#栅格和坐标空间" class="headerlink" title="栅格和坐标空间"></a>栅格和坐标空间</h2><p>上面说了，canvas的属性width和height将canvas平均分布200*200个像素点，左上顶点坐标为(0, 0)，右下顶点为(200, 200)，如图所示：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120171202.png" alt="image-20211120171202641"></p>
<h2 id="绘制网格"><a href="#绘制网格" class="headerlink" title="绘制网格"></a>绘制网格</h2><p>为了更好的看到效果，刚开始学习的时候可以绘制一个网格帮助理解。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawGrid</span>(<span class="params">ctx, color, stepX, stepY</span>) </span>&#123;</span><br><span class="line">  ctx.strokeStyle = color;</span><br><span class="line">  ctx.lineWidth = <span class="number">0.5</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = stepX + <span class="number">0.5</span>; i &lt; myCanvas.width; i += stepX) &#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.moveTo(i, <span class="number">0</span>);</span><br><span class="line">    ctx.lineTo(i, myCanvas.height);</span><br><span class="line">    ctx.stroke();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = stepY + <span class="number">0.5</span>; i &lt; myCanvas.height; i += stepY) &#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.moveTo(<span class="number">0</span>, i);</span><br><span class="line">    ctx.lineTo(myCanvas.width, i);</span><br><span class="line">    ctx.stroke();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myCanvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> ctx = myCanvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">drawGrid(ctx, <span class="string">&#x27;#f00&#x27;</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>一个基础的绘制canvas的HTML模板如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-id">#canvas</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, eventWindowLoaded, <span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">eventWindowLoaded</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      canvasApp();</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">canvasSupport</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> !!e.getContext;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">canvasApp</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> myCanvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvas&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (!canvasSupport(myCanvas)) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> ctx = myCanvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">drawScreen</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 绘制网格</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">drawGrid</span>(<span class="params">ctx, color, stepX, stepY</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          ctx.strokeStyle = color;</span></span><br><span class="line"><span class="javascript">          ctx.lineWidth = <span class="number">0.5</span>;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">for</span> (<span class="keyword">let</span> i = stepX + <span class="number">0.5</span>; i &lt; myCanvas.width; i += stepX) &#123;</span></span><br><span class="line"><span class="javascript">            ctx.beginPath();</span></span><br><span class="line"><span class="javascript">            ctx.moveTo(i, <span class="number">0</span>);</span></span><br><span class="line"><span class="javascript">            ctx.lineTo(i, myCanvas.height);</span></span><br><span class="line"><span class="javascript">            ctx.stroke();</span></span><br><span class="line"><span class="javascript">          &#125;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">for</span> (<span class="keyword">let</span> i = stepY + <span class="number">0.5</span>; i &lt; myCanvas.height; i += stepY) &#123;</span></span><br><span class="line"><span class="javascript">            ctx.beginPath();</span></span><br><span class="line"><span class="javascript">            ctx.moveTo(<span class="number">0</span>, i);</span></span><br><span class="line"><span class="javascript">            ctx.lineTo(myCanvas.width, i);</span></span><br><span class="line"><span class="javascript">            ctx.stroke();</span></span><br><span class="line"><span class="javascript">          &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        drawGrid(ctx, <span class="string">&#x27;#f00&#x27;</span>, <span class="number">10</span>, <span class="number">10</span>)</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      drawScreen();</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120171325.png" alt="image-20211120171325635"></p>
<h1 id="绘制基础图形"><a href="#绘制基础图形" class="headerlink" title="绘制基础图形"></a>绘制基础图形</h1><p>canvas只支持一种基本形状——矩形，所有其它形状都是通过一个或多个路径组合而成，甚至是基本的矩形也可以通过路径组合成。 更多的图形可以使用第三方插件 draw2d.js 完成。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120193551.png" alt="image-20211120193551372"></p>
<h2 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h2><p>canvas提供三个绘制矩形的方法:<br>1.fillRect(x, y, width, height) 绘制一个填充的矩形<br>2.strokeRect(x, y, width, height) 绘制一个矩形的边框<br>3.clearRect(x, y, widh, height) 清除指定的矩形区域，然后这块区域会变的完全透明。(可以理解为一块矩形橡皮擦)</p>
<p>参数说明:<br>●x, y：矩形的左上角的坐标。<br>●width, height：绘制的矩形的宽和高。</p>
<p>填充的默认颜色为黑色。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">ctx.clearRect(<span class="number">20</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">50</span>)</span><br><span class="line">ctx.strokeRect(<span class="number">120</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120193755.png" alt="image-20211120193749399"></p>
<h2 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h2><p>图形的基本元素是路径。路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。一个路径，甚至一个子路径，都是闭合的。</p>
<p>使用路径绘制图形一般需要以下步骤：</p>
<ol>
<li>创建路径起始点</li>
<li>调用绘制方法去绘制出路径</li>
<li>把路径封闭</li>
<li>一旦路径生成，通过描边或填充路径区域来渲染图形。</li>
</ol>
<p>canvas 绘制路径相关的 API</p>
<ol>
<li>beginPath() 新建一条路径，路径一旦创建成功，图形绘制命令被指向到路径上生成路径</li>
<li>moveTo(x, y) 把画笔移动到指定的坐标(x, y)。相当于设置路径的起始点坐标。(可以理解为将画笔悬空移动)</li>
<li>lineTo(x, y) 将画笔以画线的形式移动到另一点坐标(x, y)。(可以理解为让画笔在画纸上移动)</li>
<li>closePath() 闭合路径之后，图形绘制命令又重新指向到上下文中</li>
<li>stroke() 通过线条来绘制图形轮廓</li>
<li>fill() 通过填充路径的内容区域生成实心的图形</li>
</ol>
<h3 id="绘制线段"><a href="#绘制线段" class="headerlink" title="绘制线段"></a>绘制线段</h3><p>只需要使用其 moveTo 与 lineTo 即可创建线段，使用 stroke 绘制线条。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.moveTo(<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure>

<p>效果如下:</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120194040.png" alt="image-20211120194040783"></p>
<h3 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h3><p>结合着 beginPath 和 closePath 可以创建一个封闭路径，使用 stroke 进行描边，使用 fill 进行填充。</p>
<p>如：通过路径绘制一个矩形</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line">ctx.lineTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.lineTo(<span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">ctx.closePath();</span><br><span class="line">ctx.fill();</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120194134.png" alt="image-20211120194134536"></p>
<p>在绘制图形路径时，一定要先调用beginPath()。beginPath()方法将会清空内存中之前的绘制路径信息。如果不这样做，对于绘制单个图形可能没什么影响，但是在绘制多个图形时，将会导致路径绘制或者颜色填充等操作出现任何意料之外的结果。</p>
<h3 id="绘制虚线"><a href="#绘制虚线" class="headerlink" title="绘制虚线"></a>绘制虚线</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.setLineDash(segments)</span><br></pre></td></tr></table></figure>

<p>setLineDash 接收一个数组，按照数组元素组成 (线长，间距) 的形式，循环调用数组中的所有元素作为线长与间距</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.save();</span><br><span class="line">ctx.setLineDash([<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>]);</span><br><span class="line">ctx.lineWidth = <span class="number">4</span>;</span><br><span class="line">ctx.strokeStyle = <span class="string">&#x27;#0f0&#x27;</span>;</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">ctx.lineTo(<span class="number">400</span>, <span class="number">100</span>);</span><br><span class="line">ctx.stroke();</span><br><span class="line">ctx.restore();</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120194240.png" alt="image-20211120194240033"></p>
<p>原理如下：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120194302.png" alt="image-20211120194302146"></p>
<h2 id="绘制样式"><a href="#绘制样式" class="headerlink" title="绘制样式"></a>绘制样式</h2><h3 id="添加颜色"><a href="#添加颜色" class="headerlink" title="添加颜色"></a>添加颜色</h3><p>给绘制的图形上色，可以使用以下 API :</p>
<ol>
<li>fillStyle = color 设置图形的填充颜色</li>
<li>strokeStyle = color 设置图形轮廓的颜色</li>
<li>globalAlpha = transparencyValue  这个属性影响到 canvas 里所有图形的透明度，有效的值范围是 0.0 （完全透明）到 1.0（完全不透明），默认是 1.0。</li>
</ol>
<p>globalAlpha 属性在需要绘制大量拥有相同透明度的图形时候相当高效。不过，个人认为使用rgba()设置透明度更加好一些。</p>
<p><strong>注意：</strong></p>
<ol>
<li>color 可以是表示 css 颜色值的字符串、渐变对象或者图案对象。</li>
<li>默认情况下，线条和填充颜色都是黑色。</li>
<li>一旦您设置了 strokeStyle 或者 fillStyle 的值，那么这个新值就会成为新绘制的图形的默认值。如果你要给每个图形上不同的颜色，需要重新设置 fillStyle。</li>
</ol>
<p>如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; <span class="number">100</span>; k++) &#123;</span><br><span class="line">      ctx.fillStyle = <span class="string">&#x27;rgb(&#x27;</span> +</span><br><span class="line">        <span class="built_in">Math</span>.floor(<span class="number">255</span> - <span class="number">20</span> * i) + <span class="string">&#x27;,&#x27;</span> +</span><br><span class="line">        <span class="built_in">Math</span>.floor(<span class="number">255</span> - <span class="number">20</span> * j) + <span class="string">&#x27;,&#x27;</span> +</span><br><span class="line">        <span class="built_in">Math</span>.floor(<span class="number">255</span> - <span class="number">20</span> * k) + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">      ctx.fillRect(j * <span class="number">10</span>, i * <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120194443.png" alt="image-20211120194443551"></p>
<p>另一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomInt</span>(<span class="params"><span class="keyword">from</span>, to</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * (to - <span class="keyword">from</span> + <span class="number">1</span>) + <span class="keyword">from</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++)&#123;</span><br><span class="line">    ctx.strokeStyle = <span class="string">`rgb(<span class="subst">$&#123;randomInt(<span class="number">0</span>, <span class="number">255</span>)&#125;</span>,<span class="subst">$&#123;randomInt(<span class="number">0</span>, <span class="number">255</span>)&#125;</span>,<span class="subst">$&#123;randomInt(<span class="number">0</span>, <span class="number">255</span>)&#125;</span>)`</span>;</span><br><span class="line">    ctx.strokeRect(j * <span class="number">50</span>, i * <span class="number">50</span>, <span class="number">40</span>, <span class="number">40</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120194529.png" alt="image-20211120194529623"></p>
<h3 id="添加样式"><a href="#添加样式" class="headerlink" title="添加样式"></a>添加样式</h3><ol>
<li>lineWidth = value 线宽。只能是正值。默认是1.0</li>
<li>lineCap = type 线条末端样式，允许的值有:<ul>
<li>butt：线段末端以方形结束</li>
<li>round：线段末端以圆形结束</li>
<li>square：线段末端以方形结束，但是增加了一个宽度和线段相同，高度是线段厚度一半的矩形区域。</li>
</ul>
</li>
<li>lineJoin = type 同一个path内，设定线条与线条间接合处的样式。<ul>
<li>round 通过填充一个额外的，圆心在相连部分末端的扇形，绘制拐角的形状。 圆角的半径是线段的宽度。</li>
<li>bevel 在相连部分的末端填充一个额外的以三角形为底的区域， 每个部分都有各自独立的矩形拐角。</li>
<li>miter (默认) 通过延伸相连部分的外边缘，使其相交于一点，形成一个额外的菱形区域。</li>
</ul>
</li>
<li>设置虚线样式: setLineDash 方法接受一个数组，来指定线段与间隙的交替；lineDashOffset属性设置起始偏移量。</li>
</ol>
<p>示例：设置线条末端样式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">ctx.lineTo(<span class="number">100</span>, <span class="number">10</span>);</span><br><span class="line">ctx.lineWidth = <span class="number">10</span>;</span><br><span class="line">ctx.lineCap = <span class="string">&#x27;round&#x27;</span></span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120194756.png" alt="image-20211120194756814"></p>
<p>示例：设置线条结合处样式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lineJoin = [<span class="string">&#x27;round&#x27;</span>, <span class="string">&#x27;bevel&#x27;</span>, <span class="string">&#x27;miter&#x27;</span>];</span><br><span class="line">ctx.lineWidth = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; lineJoin.length; i++)&#123;</span><br><span class="line">  ctx.lineJoin = lineJoin[i];</span><br><span class="line">  ctx.beginPath();</span><br><span class="line">  ctx.moveTo(<span class="number">50</span>, <span class="number">50</span> + i * <span class="number">50</span>);</span><br><span class="line">  ctx.lineTo(<span class="number">100</span>, <span class="number">100</span> + i * <span class="number">50</span>);</span><br><span class="line">  ctx.lineTo(<span class="number">150</span>, <span class="number">50</span> + i * <span class="number">50</span>);</span><br><span class="line">  ctx.lineTo(<span class="number">200</span>, <span class="number">100</span> + i * <span class="number">50</span>);</span><br><span class="line">  ctx.lineTo(<span class="number">250</span>, <span class="number">50</span> + i * <span class="number">50</span>);</span><br><span class="line">  ctx.stroke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120194913.png" alt="image-20211120194913602"></p>
<p>示例：设置虚线样式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.setLineDash([<span class="number">20</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">5</span>]);  <span class="comment">// [实线长度, 间隙长度]</span></span><br><span class="line">ctx.lineDashOffset = <span class="number">10</span>;</span><br><span class="line">ctx.strokeRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120194945.png" alt="image-20211120194945718"></p>
<h2 id="绘制文字"><a href="#绘制文字" class="headerlink" title="绘制文字"></a>绘制文字</h2><p>canvas 提供了两种方法来渲染文本：</p>
<ol>
<li>fillText(text, x, y [, maxWidth]) 在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的.</li>
<li>strokeText(text, x, y [, maxWidth]) 在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的.</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&#x27;Hello canvas!&#x27;</span></span><br><span class="line">ctx.font = <span class="string">&quot;20px sans-serif&quot;</span></span><br><span class="line">ctx.fillText(text, <span class="number">50</span>, <span class="number">50</span>)</span><br><span class="line">ctx.strokeText(text, <span class="number">50</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120195106.png" alt="image-20211120195106238"></p>
<h3 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h3><ol>
<li>font = value 当前我们用来绘制文本的样式。这个字符串使用和 CSS font属性相同的语法. 默认的字体是 10px sans-serif。</li>
<li>textAlign = value 文本对齐选项. 可选的值包括：start, end, left, right or center. 默认值是 start。</li>
<li>textBaseline = value 基线对齐选项，可选的值包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic。</li>
<li>direction = value 文本方向。可能的值包括：ltr, rtl, inherit。默认值是 inherit。</li>
</ol>
<h2 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h2><p>使用drawImage绘制图像</p>
<p>有以下三种使用方法：</p>
<ol>
<li><p>context.drawImage(img,x,y)</p>
</li>
<li><p>context.drawImage(img,x,y,width,height)</p>
</li>
<li><p>context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height)</p>
<p> ​    </p>
</li>
</ol>
<ul>
<li><p>第一参数img可以是一个Image()的实例，也可以是一个<img>的Dom元素。</p>
</li>
<li><p>sx, sy 必选，为绘制图像的顶点坐标。</p>
</li>
<li><p>sWidth, sHeight 可选，为图片缩放大小。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();   <span class="comment">// 创建img元素</span></span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ctx.drawImage(img, <span class="number">20</span>, <span class="number">20</span>, <span class="number">150</span>, <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line">img.src = <span class="string">&#x27;https://img.xiaoyulive.top/img/shortcut/096.jpg&#x27;</span>; <span class="comment">// 设置图片源地址</span></span><br></pre></td></tr></table></figure>

<p>​    效果:</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120195456.png" alt="image-20211120195456476"></p>
<p>如果除img外有8个参数：</p>
<ul>
<li>前4个是定义图像源的切片位置和大小。</li>
<li>后4个则是定义切片的目标显示位置和大小。</li>
</ul>
<p>原理图：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120195637.png" alt="image-20211120195637147"></p>
<h2 id="绘制圆弧"><a href="#绘制圆弧" class="headerlink" title="绘制圆弧"></a>绘制圆弧</h2><h3 id="arc"><a href="#arc" class="headerlink" title="arc"></a>arc</h3><p>语法：</p>
<p><code>arc(x, y, r, startAngle, endAngle, anticlockwise)</code></p>
<ul>
<li>以 (x, y) 为圆心，以r为半径，从 startAngle 弧度开始到 endAngle 弧度结束，注意: 单位为弧度。</li>
<li>anticlosewise 是布尔值，true 表示逆时针，false 表示顺时针。(默认是顺时针)</li>
<li>0弧度为在一个笛卡尔坐标系中的x轴正方向</li>
<li>通常使用 Math.PI 进行弧度运算，一个 Math.PI 就是 180deg</li>
<li>radians=(Math.PI/180)*degrees   // 角度转换成弧度1</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.beginPath();</span><br><span class="line">ctx.arc(<span class="number">50</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI / <span class="number">2</span>, <span class="literal">false</span>);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120195813.png" alt="image-20211120195813424"></p>
<p>可以看到从x轴正方向顺时针绘制出了半径为40的 1/4 圆弧。</p>
<h3 id="arcTo"><a href="#arcTo" class="headerlink" title="arcTo"></a>arcTo</h3><p>语法：</p>
<p><code>arcTo(x1, y1, x2, y2, radius)</code></p>
<p>根据给定的控制点和半径画一段圆弧，最后再以直线连接两个控制点。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line"><span class="comment">//参数1、2：控制点1坐标   参数3、4：控制点2坐标  参数5：圆弧半径</span></span><br><span class="line">ctx.arcTo(<span class="number">200</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120195924.png" alt="image-20211120195924327"></p>
<p>原理图：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120195945.png" alt="image-20211120195945532"></p>
<p>可以理解为：绘制的弧形是由两条切线所决定。</p>
<p>第 1 条切线：起始点和控制点1决定的直线。<br>第 2 条切线：控制点1 和控制点2决定的直线。</p>
<p>圆弧半径可以回想一下css中border-radius的实现。</p>
<h2 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h2><p>贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。</p>
<p>一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋，我们在绘图工具上看到的钢笔工具就是来做这种矢量曲线的。</p>
<h3 id="原理动画"><a href="#原理动画" class="headerlink" title="原理动画"></a>原理动画</h3><p>一次贝塞尔曲线：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120200032.gif" alt="002.gif"></p>
<p>二次贝塞尔曲线：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120200048.gif" alt="003.gif"></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120200216.png" alt="image-20211120200216767"></p>
<p>三次贝塞尔曲线：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120200127.gif" alt="005.gif"></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120200151.png" alt="image-20211120200151307"></p>
<h3 id="绘制二次贝塞尔曲线"><a href="#绘制二次贝塞尔曲线" class="headerlink" title="绘制二次贝塞尔曲线"></a>绘制二次贝塞尔曲线</h3><p>语法：</p>
<p><code>quadraticCurveTo(cp1x, cp1y, x, y);</code></p>
<p>参数说明：</p>
<ul>
<li>参数1和2：控制点坐标</li>
<li>参数3和4：结束点坐标</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.beginPath();</span><br><span class="line"><span class="keyword">let</span> bX = <span class="number">10</span>, bY = <span class="number">160</span>; <span class="comment">// 起始点</span></span><br><span class="line">ctx.moveTo(bX, bY);</span><br><span class="line"><span class="keyword">let</span> cX = <span class="number">40</span>, cY = <span class="number">100</span>;  <span class="comment">// 控制点</span></span><br><span class="line"><span class="keyword">let</span> toX = <span class="number">180</span>, toY = <span class="number">180</span>; <span class="comment">// 结束点</span></span><br><span class="line"><span class="comment">// 绘制二次贝塞尔曲线</span></span><br><span class="line">ctx.quadraticCurveTo(cX, cY, toX, toY);</span><br><span class="line">ctx.stroke();</span><br><span class="line"></span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.rect(bX, bY, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">ctx.rect(cX, cY, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">ctx.rect(toX, toY, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">ctx.fill();</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120200334.png" alt="image-20211120200334488"></p>
<p>为了方便理解，将起始点、控制点、结束点都用实心矩形标出。</p>
<h3 id="绘制三次贝塞尔曲线"><a href="#绘制三次贝塞尔曲线" class="headerlink" title="绘制三次贝塞尔曲线"></a>绘制三次贝塞尔曲线</h3><p>语法</p>
<p><code>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);</code></p>
<p>参数说明：</p>
<ul>
<li>参数1和2：控制点1的坐标</li>
<li>参数3和4：控制点2的坐标</li>
<li>参数5和6：结束点的坐标</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.beginPath();</span><br><span class="line"><span class="keyword">let</span> bX = <span class="number">10</span>, bY = <span class="number">160</span>; <span class="comment">// 起始点</span></span><br><span class="line">ctx.moveTo(bX, bY);</span><br><span class="line"><span class="keyword">let</span> cX1 = <span class="number">20</span>, cY1 = <span class="number">50</span>;  <span class="comment">// 控制点1</span></span><br><span class="line"><span class="keyword">let</span> cX2 = <span class="number">60</span>, cY2 = <span class="number">150</span>;  <span class="comment">// 控制点2</span></span><br><span class="line"><span class="keyword">let</span> toX = <span class="number">180</span>, toY = <span class="number">180</span>; <span class="comment">// 结束点</span></span><br><span class="line"><span class="comment">// 绘制二次贝塞尔曲线</span></span><br><span class="line">ctx.bezierCurveTo(cX1, cY1, cX2, cY2, toX, toY);</span><br><span class="line">ctx.stroke();</span><br><span class="line"></span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.rect(bX, bY, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">ctx.rect(cX1, cY1, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">ctx.rect(cX2, cY2, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">ctx.rect(toX, toY, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">ctx.fill();</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120200707.png" alt="image-20211120200707069"></p>
<h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><h3 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h3><p>语法：<br><code>createLinearGradient(x1, y1, x2, y2);</code></p>
<p>使用 createLinearGradient(x1, y1, x2, y2) 可以创建一个线性渐变，线性渐变会从第一个点(x1, y1)扩展到第二个点(x2, y2)，即定义了渐变的线长与方向。</p>
<p>语法：</p>
<p><code>addColorStop(position, endColor);</code></p>
<p>使用addColorStop可以添加一个颜色节点</p>
<ul>
<li>第一个参数是0-1之间的一个数值，这个数值指定该颜色进入渐变多长的距离</li>
<li>第二个参数是颜色值</li>
</ul>
<p>示例:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> y1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> x2 = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">let</span> y2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> linearGradient1 = ctx.createLinearGradient(x1, y1, x2, y2);</span><br><span class="line">linearGradient1.addColorStop(<span class="number">0</span>, <span class="string">&#x27;rgb(255, 0, 0)&#x27;</span>);</span><br><span class="line">linearGradient1.addColorStop(<span class="number">0.5</span>, <span class="string">&#x27;rgb(0, 0, 255&#x27;</span>);</span><br><span class="line">linearGradient1.addColorStop(<span class="number">1</span>, <span class="string">&#x27;rgb(0, 0, 0)&#x27;</span>);</span><br><span class="line">ctx.fillStyle = linearGradient1</span><br><span class="line"></span><br><span class="line">ctx.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120200920.png" alt="image-20211120200920199"></p>
<h3 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h3><p>径向渐变是一种圆形的颜色扩展模式，颜色从圆心位置开始向外辐射。<br>一个径向渐变于两个圆形来定义。每一个圆都有一个圆心和一条半径。</p>
<p>语法：</p>
<p><code>ctx.createRadialGradient(x1, y1, r1, x2, y2, r2)</code></p>
<p>使用createRadialGradient可以创建一个径向渐变，(x1, y1, r1)和(x2, y2, r2)分别为两个圆的圆心坐标和半径。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x1 = <span class="number">100</span>;   <span class="comment">// 第一个圆圆心的X坐标</span></span><br><span class="line"><span class="keyword">let</span> y1 = <span class="number">100</span>;   <span class="comment">// 第一个圆圆心的Y坐标</span></span><br><span class="line"><span class="keyword">let</span> r1 = <span class="number">30</span>;    <span class="comment">// 第一个圆的半径</span></span><br><span class="line"><span class="keyword">let</span> x2 = <span class="number">100</span>;   <span class="comment">// 第二个圆圆心的X坐标</span></span><br><span class="line"><span class="keyword">let</span> y2 = <span class="number">100</span>;   <span class="comment">// 第二个圆圆心的Y坐标</span></span><br><span class="line"><span class="keyword">let</span> r2 = <span class="number">100</span>;   <span class="comment">// 第二个圆的半径</span></span><br><span class="line"><span class="keyword">let</span> radialGradient1 = ctx.createRadialGradient(x1, y1, r1, x2, y2, r2);</span><br><span class="line">radialGradient1.addColorStop(<span class="number">0</span>, <span class="string">&#x27;rgb(0, 0, 255)&#x27;</span>);</span><br><span class="line">radialGradient1.addColorStop(<span class="number">1</span>, <span class="string">&#x27;rgb(0, 255, 0)&#x27;</span>);</span><br><span class="line">ctx.fillStyle = radialGradient1</span><br><span class="line"></span><br><span class="line">ctx.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120201046.png" alt="image-20211120201046818"></p>
<p>addColorStop的用法同线性渐变。</p>
<p>如果两个圆形的圆心位置相同，那么径向渐变将是一个完整的圆形。如果两个圆的圆心位置不相同，那么径向渐变看起来就像是一个探照灯发出的光线。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x1 = <span class="number">100</span>;   <span class="comment">// 第一个圆圆心的X坐标</span></span><br><span class="line"><span class="keyword">let</span> y1 = <span class="number">100</span>;   <span class="comment">// 第一个圆圆心的Y坐标</span></span><br><span class="line"><span class="keyword">let</span> r1 = <span class="number">30</span>;    <span class="comment">// 第一个圆的半径</span></span><br><span class="line"><span class="keyword">let</span> x2 = <span class="number">150</span>;   <span class="comment">// 第二个圆圆心的X坐标</span></span><br><span class="line"><span class="keyword">let</span> y2 = <span class="number">120</span>;   <span class="comment">// 第二个圆圆心的Y坐标</span></span><br><span class="line"><span class="keyword">let</span> r2 = <span class="number">100</span>;   <span class="comment">// 第二个圆的半径</span></span><br><span class="line"><span class="keyword">let</span> radialGradient1 = ctx.createRadialGradient(x1, y1, r1, x2, y2, r2);</span><br><span class="line">radialGradient1.addColorStop(<span class="number">0</span>, <span class="string">&#x27;rgb(0, 0, 255)&#x27;</span>);</span><br><span class="line">radialGradient1.addColorStop(<span class="number">1</span>, <span class="string">&#x27;rgb(0, 255, 0)&#x27;</span>);</span><br><span class="line">ctx.fillStyle = radialGradient1</span><br><span class="line"></span><br><span class="line">ctx.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120201136.png" alt="image"></p>
<h1 id="绘制复杂图形"><a href="#绘制复杂图形" class="headerlink" title="绘制复杂图形"></a>绘制复杂图形</h1><h2 id="正多边形基础知识"><a href="#正多边形基础知识" class="headerlink" title="正多边形基础知识"></a>正多边形基础知识</h2><p>正多边形是所有角都相等、并且所有边都相等的简单多边形，简单多边形是指在任何位置都不与自身相交的多边形。</p>
<h3 id="正多边形的特性"><a href="#正多边形的特性" class="headerlink" title="正多边形的特性"></a>正多边形的特性</h3><p>正n边形每个内角为(1 - 2 / n) * 180或者表示为(n - 2) * 180 / n角度。也可以用弧度表示为(n - 2) * π / n 或者(n - 2) / 2n。</p>
<p>正多边形的所有顶点都在同一个外接圆上，每个正多边形都有一个外接圆，这也称为圆内接正多边形。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120201301.png" alt="image-20211120201301026"></p>
<p>把一个圆分成相等的一些弧，就可以得到这个圆的内接正多边形（Regular Polygon），这个圆就是正多边形的外接圆。外接圆的圆心叫做这个正多边形的中心，外接圆的半径叫做正多边形的半径（Radius），正多边形每一边所对的圆心角叫做正多边形的中心角（圆心角，Central Angle），中心到正多边形的一边的距离叫做正多边形的边心距（Apothem）。</p>
<p>一个圆的圆周是2π，当边的数目为n时，每一个中心角都是2π / n。半径r、边心距a、边长s 都存在着固定的关系，已知其中的两个，都可由上面的公式求出第三个。</p>
<p>当n接近48这个值时，那这个正多边形也就接近是一个圆了。如下图所示：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120201338.png" alt="image-20211120201337971"></p>
<h3 id="正多边形属性"><a href="#正多边形属性" class="headerlink" title="正多边形属性"></a>正多边形属性</h3><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120201407.png" alt="image-20211120201407240"></p>
<p>上图描述了正多边形的相关属性：</p>
<ul>
<li>正多边形的中心点正好是一个正多边形的外接圆的圆心</li>
<li>正多边形每条边的长度都相等，如上图中的x</li>
<li>正多边形的每个内角都相等，如上图中的β</li>
<li>正多边形的每个外角都相等，如上图中的α</li>
<li>正多边形的中心角都相等，如上图中的θ</li>
<li>正多边形的中心点距正多边形的内切圆的半行为r</li>
<li>正多边形的顶点数和边数相等，常用n表示</li>
<li>正多边形中心距正多边形的外接圆（或者正多边中心点距正多边形的顶点）就是正多边形外接圆半径，如上图中的R</li>
<li>正多边形中心点距和每条边的端点构成一个等腰三角形，如上图中的A1。这个三角形的两条边长度相等，刚好是正多边形外接圆半径R，而这个三角形的高，刚好是正多边形内切圆半径r（边心距）</li>
</ul>
<p>那么在Canvas中要使用CanvasRenderingContext2D对象自带的方法，比如moveTo()和lineTo()绘制多边形，我们就必须知道正多边形属性之间的关系。也就是这些属性之间的三角函数。言外之意，在Canvas中，我们使用moveTo()和lineTo()方法，再配合一些简单的三角函数，就可以绘制出任意边数的多边形。</p>
<p>既然绘制正多边形需要一定的三角函数知道，我们在绘制正多边形之前，先了简单的了解一下这方面的基础。</p>
<h3 id="外角（Exterior-Angle）"><a href="#外角（Exterior-Angle）" class="headerlink" title="外角（Exterior Angle）"></a>外角（Exterior Angle）</h3><p>正多边形的外角是正多边形任意边与相邻边延长直线构成的角：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120201521.png" alt="image-20211120201521124"></p>
<p>正多边形所有外角之和等于360°。也就是说，每个外角α = 360° / n。比如n=8，一个正八边形，它的外角α = 360° / n = 360° / 8 = 45。著作权归作者所有。</p>
<h3 id="内角（Interior-Angles）"><a href="#内角（Interior-Angles）" class="headerlink" title="内角（Interior Angles）"></a>内角（Interior Angles）</h3><p>正多边形相邻两条边构成的夹角就是正多边形的一个内角。每个内角都有其相邻的一个外角，它们构成一条直线，也就是说内角加上外角，刚好是180°。也就是内角β = 180° - α。即：β = 180° - 360° /n。上面的公式可以转化为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">β = 180° - 360° / n</span><br><span class="line">  = (n × 180° / n) − (2 × 180° / n)</span><br><span class="line">  = (n − 2) × 180° / n</span><br></pre></td></tr></table></figure>

<p>同样的拿n = 8的正八边形为例：β = (n - 2) × 180° / n = (8 - 2) × 180° / 8，即β = 135°。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120201620.png" alt="image-20211120201620259"></p>
<h3 id="中心角"><a href="#中心角" class="headerlink" title="中心角"></a>中心角</h3><p>正多边形的中心点与正多边形顶点构成的角，即正多边形每条边对应的夹角称为正多边形的中心角θ。如果正边形有n条边，那么就有n个中心角θ，这样一来θ = 360° / n。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120201649.png" alt="image-20211120201649417"></p>
<h3 id="正多边形每个顶点的坐标"><a href="#正多边形每个顶点的坐标" class="headerlink" title="正多边形每个顶点的坐标"></a>正多边形每个顶点的坐标</h3><p>通过前面的介绍，我们可以很容易得到正多边形的中心角θ。但在Canvas中要绘制一个正多边形，需要知道正多边形每个顶点的坐标。而这个坐标(xPos, yPos)可以通过三角函数得到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xPos = cos(θ) * R</span><br><span class="line">yPos = sin(θ) * R</span><br></pre></td></tr></table></figure>

<p>而正多边形所有中心角的和是360°也就是2π，中心角 θ = 2π / n:<br>假设我们正多边形的中点心是(xCenter, yCenter)，这样就可以得到每个顶点坐标位置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xPos = xCenter + Math.cos(angle) * radius;</span><br><span class="line">yPos = yCenter + Math.sin(angle) * radius;</span><br></pre></td></tr></table></figure>

<h2 id="绘制正多边形"><a href="#绘制正多边形" class="headerlink" title="绘制正多边形"></a>绘制正多边形</h2><p>前面花了很长的篇幅来介绍正多边形相关知识点。因为只有了解这些基础，才能更好的绘制正多边形，这也是磨刀不误砍柴工。那么我们接下来看怎么绘制一个正多边形。</p>
<p>我们先来看一个简单的绘制方法，比如封装一个绘制正多边形的函数drawPolygons()，给它传几个参数：</p>
<ul>
<li>ctx：Canvas中绘图环境</li>
<li>num：正边形边数</li>
<li>radius：正边形外接圆半径</li>
<li>arc：是否显示正多边形的外接圆</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvas&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// @param &#123;CanvasRenderingContext2D&#125; ctx</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; xCenter 中心坐标X点</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; yCenter 中心坐标Y点</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; radius 外圆半径</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; sides 多边形边数</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; alpha 角度</span></span><br><span class="line"><span class="comment">// @param &#123;Boolean&#125; arc 是否显示外圆</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawPolygons</span>(<span class="params">ctx, xCenter, yCenter, radius, sides, alpha, arc</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> radAngle = <span class="built_in">Math</span>.PI * <span class="number">2</span> / sides;</span><br><span class="line">  <span class="keyword">let</span> radAlpha = (alpha != <span class="string">&#x27;undefined&#x27;</span>) ? alpha * <span class="built_in">Math</span>.PI / <span class="number">180</span> : <span class="number">0</span>;</span><br><span class="line">  ctx.save();</span><br><span class="line">  ctx.beginPath();</span><br><span class="line">  <span class="keyword">let</span> xPos = xCenter + <span class="built_in">Math</span>.cos(radAlpha) * radius;</span><br><span class="line">  <span class="keyword">let</span> yPos = yCenter + <span class="built_in">Math</span>.sin(radAlpha) * radius;</span><br><span class="line">  ctx.moveTo(xPos, yPos);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= sides; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> rad = radAngle * i + radAlpha;</span><br><span class="line">    xPos = xCenter + <span class="built_in">Math</span>.cos(rad) * radius;</span><br><span class="line">    yPos = yCenter + <span class="built_in">Math</span>.sin(rad) * radius;</span><br><span class="line">    ctx.lineTo(xPos, yPos);</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.closePath();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制填充的多边形</span></span><br><span class="line"><span class="comment">// @param &#123;CanvasRenderingContext2D&#125; ctx</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; xCenter 中心点X坐标点</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; yCenter 中心点Y坐标点</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; radius 外圆半径</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; sides 多边形边数</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; alpha 角度</span></span><br><span class="line"><span class="comment">// @param &#123;Boolean&#125; arc 是否显示外圆</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawFillPolygon</span>(<span class="params">ctx, xCenter, yCenter, radius, sides, style, alpha, arc</span>) </span>&#123;</span><br><span class="line">  drawPolygons(ctx, xCenter, yCenter, radius, sides, alpha, arc);</span><br><span class="line">  ctx.fillStyle = style;</span><br><span class="line">  ctx.fill();</span><br><span class="line">  <span class="comment">// 画外接圆</span></span><br><span class="line">  <span class="keyword">if</span> (arc) &#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.arc(xCenter, yCenter, radius, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI, <span class="literal">true</span>);</span><br><span class="line">    ctx.stroke();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制描边的多边形</span></span><br><span class="line"><span class="comment">// @param &#123;CanvasRenderingContext2D&#125; ctx</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; xCenter 中心点X坐标点</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; yCenter 中心点Y坐标点</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; radius 外圆半径</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; sides 多边形边数</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; alpha 角度 默认270度</span></span><br><span class="line"><span class="comment">// @param &#123;Boolean&#125; arc 是否显示外圆</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawStrokePolygon</span>(<span class="params">ctx, xCenter, yCenter, radius, sides, style, alpha, arc</span>) </span>&#123;</span><br><span class="line">  drawPolygons(ctx, xCenter, yCenter, radius, sides, alpha, arc);</span><br><span class="line">  ctx.strokeStyle = style;</span><br><span class="line">  ctx.stroke();</span><br><span class="line">  <span class="comment">// 画外接圆</span></span><br><span class="line">  <span class="keyword">if</span> (arc) &#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.arc(xCenter, yCenter, radius, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI, <span class="literal">true</span>);</span><br><span class="line">    ctx.stroke();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">drawFillPolygon(ctx, <span class="number">50</span>,<span class="number">50</span>,<span class="number">50</span>,<span class="number">5</span>,<span class="string">&#x27;#f00&#x27;</span>,<span class="number">0</span>,<span class="literal">false</span>)</span><br><span class="line">drawStrokePolygon(ctx, <span class="number">100</span>,<span class="number">100</span>,<span class="number">50</span>,<span class="number">5</span>,<span class="string">&#x27;#00f&#x27;</span>,<span class="number">0</span>,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120201914.png" alt="image-20211120201914824"></p>
<p>演示：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120201954.png" alt="image-20211120201954267"></p>
<h2 id="绘制星形"><a href="#绘制星形" class="headerlink" title="绘制星形"></a>绘制星形</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvas&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// @param &#123;CanvasRenderingContext2D&#125; ctx</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; xCenter 中心坐标X点</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; yCenter 中心坐标Y点</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; radius 外圆半径</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; sides 多边形边数</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; sideIndent (0 ~ 1)</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; alpha 角度 默认270度</span></span><br><span class="line"><span class="comment">// @param &#123;Boolean&#125; arc 是否显示外圆</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawStarPolygons</span>(<span class="params">ctx, xCenter, yCenter, radius, sides, sideIndent, alpha, arc</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sideIndentRadius = radius * (sideIndent || <span class="number">0.38</span>);</span><br><span class="line">  <span class="keyword">let</span> radAngle = alpha ? alpha * <span class="built_in">Math</span>.PI / <span class="number">180</span> : -<span class="built_in">Math</span>.PI / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">let</span> radAlpha = <span class="built_in">Math</span>.PI * <span class="number">2</span> / sides / <span class="number">2</span>;</span><br><span class="line">  ctx.save(); ctx.beginPath();</span><br><span class="line">  <span class="keyword">let</span> xPos = xCenter + <span class="built_in">Math</span>.cos(radAngle) * radius;</span><br><span class="line">  <span class="keyword">let</span> yPos = yCenter + <span class="built_in">Math</span>.sin(radAngle) * radius;</span><br><span class="line">  ctx.moveTo(xPos, yPos);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= sides * <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> rad = radAlpha * i + radAngle;</span><br><span class="line">    <span class="keyword">let</span> len = (i % <span class="number">2</span>) ? sideIndentRadius : radius;</span><br><span class="line">    <span class="keyword">let</span> xPos = xCenter + <span class="built_in">Math</span>.cos(rad) * len;</span><br><span class="line">    <span class="keyword">let</span> yPos = yCenter + <span class="built_in">Math</span>.sin(rad) * len;</span><br><span class="line">    ctx.lineTo(xPos, yPos);</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.closePath();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制填充的多边形</span></span><br><span class="line"><span class="comment">// @param &#123;CanvasRenderingContext2D&#125; ctx</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; xCenter 中心点X坐标点</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; yCenter 中心点Y坐标点</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; radius 外圆半径</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; sides 多边形边数</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; style 填充样式</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; sideIndent (0 ~ 1)</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; alpha 角度 默认270度</span></span><br><span class="line"><span class="comment">// @param &#123;Boolean&#125; arc 是否显示外圆</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawFillStarPolygon</span>(<span class="params">ctx, xCenter, yCenter, radius, sides, style, sideIndent, alpha, arc</span>) </span>&#123;</span><br><span class="line">  drawStarPolygons(ctx, xCenter, yCenter, radius, sides, sideIndent, alpha, arc);</span><br><span class="line">  ctx.fillStyle = style;</span><br><span class="line">  ctx.fill();</span><br><span class="line">  <span class="comment">// 画外接圆</span></span><br><span class="line">  <span class="keyword">if</span> (arc) &#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.arc(xCenter, yCenter, radius, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI, <span class="literal">true</span>);</span><br><span class="line">    ctx.arc(xCenter, yCenter, radius * sideIndent, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI, <span class="literal">true</span>);</span><br><span class="line">    ctx.stroke();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制描边的多边形</span></span><br><span class="line"><span class="comment">// @param &#123;CanvasRenderingContext2D&#125; ctx</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; xCenter 中心点X坐标点</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; yCenter 中心点Y坐标点</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; radius 外圆半径</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; sides 多边形边数</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; style 填充样式</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; sideIndent (0 ~ 1)</span></span><br><span class="line"><span class="comment">// @param &#123;Number&#125; alpha 角度 默认270度</span></span><br><span class="line"><span class="comment">// @param &#123;Boolean&#125; arc 是否显示外圆</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawStrokeStarPolygon</span>(<span class="params">ctx, xCenter, yCenter, radius, sides, style, sideIndent, alpha, arc</span>) </span>&#123;</span><br><span class="line">  drawStarPolygons(ctx, xCenter, yCenter, radius, sides, sideIndent, alpha, arc);</span><br><span class="line">  ctx.strokeStyle = style;</span><br><span class="line">  ctx.stroke();</span><br><span class="line">  <span class="comment">// 画外接圆</span></span><br><span class="line">  <span class="keyword">if</span> (arc) &#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.arc(xCenter, yCenter, radius, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI, <span class="literal">true</span>);</span><br><span class="line">    ctx.arc(xCenter, yCenter, radius * sideIndent, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI, <span class="literal">true</span>);</span><br><span class="line">    ctx.stroke();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">drawFillStarPolygon(ctx, <span class="number">50</span>,<span class="number">50</span>,<span class="number">50</span>,<span class="number">5</span>,<span class="string">&#x27;#f00&#x27;</span>,<span class="number">.5</span>,<span class="number">0</span>,<span class="literal">false</span>)</span><br><span class="line">drawStrokeStarPolygon(ctx, <span class="number">100</span>,<span class="number">100</span>,<span class="number">50</span>,<span class="number">5</span>,<span class="string">&#x27;#00f&#x27;</span>,<span class="number">.3</span>,<span class="number">0</span>,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120202033.png" alt="image-20211120202033920"></p>
<h2 id="案例：星星"><a href="#案例：星星" class="headerlink" title="案例：星星"></a>案例：星星</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvas&#x27;</span>).getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">  ctx.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">300</span>,<span class="number">300</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++) &#123;</span><br><span class="line">      ctx.save();</span><br><span class="line">      ctx.strokeStyle = <span class="string">&quot;#9CFF00&quot;</span>;</span><br><span class="line">      ctx.translate(<span class="number">50</span>+j*<span class="number">100</span>,<span class="number">50</span>+i*<span class="number">100</span>);</span><br><span class="line">      drawSpirograph(ctx,<span class="number">20</span>*(j+<span class="number">2</span>)/(j+<span class="number">1</span>),-<span class="number">8</span>*(i+<span class="number">3</span>)/(i+<span class="number">1</span>),<span class="number">10</span>);</span><br><span class="line">      ctx.restore();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawSpirograph</span>(<span class="params">ctx,R,r,O</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x1 = R-O;</span><br><span class="line">  <span class="keyword">var</span> y1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> i    = <span class="number">1</span>;</span><br><span class="line">  ctx.beginPath();</span><br><span class="line">  ctx.moveTo(x1,y1);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i&gt;<span class="number">20000</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">var</span> x2 = (R+r)*<span class="built_in">Math</span>.cos(i*<span class="built_in">Math</span>.PI/<span class="number">72</span>) - (r+O)*<span class="built_in">Math</span>.cos(((R+r)/r)*(i*<span class="built_in">Math</span>.PI/<span class="number">72</span>))</span><br><span class="line">    <span class="keyword">var</span> y2 = (R+r)*<span class="built_in">Math</span>.sin(i*<span class="built_in">Math</span>.PI/<span class="number">72</span>) - (r+O)*<span class="built_in">Math</span>.sin(((R+r)/r)*(i*<span class="built_in">Math</span>.PI/<span class="number">72</span>))</span><br><span class="line">    ctx.lineTo(x2,y2);</span><br><span class="line">    x1 = x2;</span><br><span class="line">    y1 = y2;</span><br><span class="line">    i++;</span><br><span class="line">  &#125; <span class="keyword">while</span> (x2 != R-O &amp;&amp; y2 != <span class="number">0</span> );</span><br><span class="line">  ctx.stroke();</span><br><span class="line">&#125;</span><br><span class="line">draw();</span><br></pre></td></tr></table></figure>

<p>效果:</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120202158.png" alt="image-20211120202158850"></p>
<h1 id="状态保存与恢复"><a href="#状态保存与恢复" class="headerlink" title="状态保存与恢复"></a>状态保存与恢复</h1><p>save 和 restore 方法是用来保存和恢复 canvas 状态的，都没有参数。</p>
<p>Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。</p>
<h2 id="save"><a href="#save" class="headerlink" title="save()"></a>save()</h2><p>Canvas状态存储在栈中，每当save()方法被调用后，当前的状态就被推送到栈中保存(类似数组的push())。</p>
<p>一个绘画状态包括：</p>
<ul>
<li>当前应用的变形（即移动，旋转和缩放）</li>
<li>strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation 的值</li>
<li>当前的裁切路径（clipping path）</li>
</ul>
<h2 id="restore"><a href="#restore" class="headerlink" title="restore()"></a>restore()</h2><p>每一次调用 restore 方法，上一个保存的状态就从栈中弹出，所有设定都恢复。(类似数组的pop())</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.fillStyle = <span class="string">&#x27;#f00&#x27;</span></span><br><span class="line">ctx.fillRect(<span class="number">10</span>,<span class="number">10</span>,<span class="number">150</span>,<span class="number">150</span>)</span><br><span class="line">ctx.save()</span><br><span class="line"></span><br><span class="line">ctx.fillStyle = <span class="string">&#x27;#0f0&#x27;</span></span><br><span class="line">ctx.fillRect(<span class="number">20</span>,<span class="number">20</span>,<span class="number">100</span>,<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">ctx.restore() <span class="comment">// 恢复 ctx.fillStyle = &#x27;#f00&#x27; 的状态</span></span><br><span class="line">ctx.fillRect(<span class="number">30</span>,<span class="number">30</span>,<span class="number">50</span>,<span class="number">50</span>)</span><br></pre></td></tr></table></figure>

<h1 id="剪裁路径"><a href="#剪裁路径" class="headerlink" title="剪裁路径"></a>剪裁路径</h1><p>Canvas中有一个很有用的功能：剪裁路径。</p>
<p>它是Canvas之中由路径所定义的一块区域，浏览器会将所有的绘图操作都限制在本区域内执行。在默认情况下，剪辑区域的大小与Canvas画布大小一致。除非你通过创建路径并调用Canvas绘图环境对象的clip()方法来显式的设定剪辑区域，否则默认的剪辑区域不会影响Canvas之中所绘制的内容。然而，一旦设置好剪辑区域，那么你在Canvas之中绘制的所有内容都将局限在该区域内。这也意味着在剪辑区域以外进行绘制是没有任何效果的。</p>
<h2 id="剪切区域"><a href="#剪切区域" class="headerlink" title="剪切区域"></a>剪切区域</h2><p>裁剪路径的作用是遮罩。只显示裁剪路径内的区域，裁剪路径外的区域会被隐藏，这一块区域就是剪切区域 。</p>
<p>设定裁选区之后，无论在Canvas上绘制什么，只有落在裁选区内的那部分才能得以显示，其余都会被遮蔽掉。</p>
<p>Canvas中的clip()方法是裁切区可用于限制图像描绘的区域，具体的用法：</p>
<ul>
<li>使用Canvas的绘制函数比如，rect()、arc()之类的方法选择好绘图区域</li>
<li>使用clip()函数将该区域（由rect()、arc()方法指定的绘图区域）设定为裁选区</li>
</ul>
<p>clip() 只能遮罩在这个方法调用之后绘制的图像，如果是clip()方法调用之前绘制的图像，则无法实现遮罩。</p>
<p>如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.beginPath();</span><br><span class="line">ctx.arc(<span class="number">20</span>,<span class="number">20</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">&quot;pink&quot;</span>;</span><br><span class="line">ctx.save();</span><br><span class="line"></span><br><span class="line">ctx.clip();</span><br><span class="line">ctx.fillRect(<span class="number">20</span>, <span class="number">20</span>, <span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">ctx.restore()</span><br><span class="line">ctx.fillRect(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120202440.png" alt="image-20211120202440579"></p>
<h3 id="剪裁示例"><a href="#剪裁示例" class="headerlink" title="剪裁示例"></a>剪裁示例</h3><p>原始图像：在画布上绘制三个圆，分别为 蓝、红、绿，初始的时候不设置剪裁</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvas&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> context = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">250</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="number">150</span></span><br><span class="line"><span class="keyword">let</span> radius = <span class="number">50</span></span><br><span class="line"><span class="keyword">let</span> startAngle = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> endAngle = <span class="number">360</span></span><br><span class="line"><span class="keyword">let</span> anticlockwise = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个圆: 蓝色</span></span><br><span class="line">context.fillStyle=<span class="string">&#x27;#00f&#x27;</span>;</span><br><span class="line">context.beginPath();</span><br><span class="line">context.arc(x, y, radius, <span class="built_in">Math</span>.PI / <span class="number">180</span> * startAngle, <span class="built_in">Math</span>.PI / <span class="number">180</span> * endAngle, anticlockwise);</span><br><span class="line">context.fill();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个圆: 红色</span></span><br><span class="line">context.fillStyle=<span class="string">&#x27;#f00&#x27;</span>;</span><br><span class="line">context.beginPath();</span><br><span class="line">context.arc(x - <span class="number">40</span>, y + <span class="number">50</span>, radius, <span class="built_in">Math</span>.PI / <span class="number">180</span> * startAngle, <span class="built_in">Math</span>.PI / <span class="number">180</span> * endAngle, anticlockwise);</span><br><span class="line">context.fill();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三个圆: 绿色</span></span><br><span class="line">context.fillStyle=<span class="string">&#x27;#0f0&#x27;</span>;</span><br><span class="line">context.beginPath();</span><br><span class="line">context.arc(x + <span class="number">40</span>, y + <span class="number">50</span>, radius, <span class="built_in">Math</span>.PI / <span class="number">180</span> * startAngle, <span class="built_in">Math</span>.PI / <span class="number">180</span> * endAngle, anticlockwise);</span><br><span class="line">context.fill();</span><br></pre></td></tr></table></figure>

<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120202513.png" alt="image-20211120202513386"></p>
<p><strong>将第一个圆设置为剪裁区域</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">context.fillStyle=<span class="string">&#x27;#00f&#x27;</span>;</span><br><span class="line">context.beginPath();</span><br><span class="line">context.arc(x, y, radius, <span class="built_in">Math</span>.PI / <span class="number">180</span> * startAngle, <span class="built_in">Math</span>.PI / <span class="number">180</span> * endAngle, anticlockwise);</span><br><span class="line">context.fill();</span><br><span class="line">context.clip();</span><br></pre></td></tr></table></figure>

<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120202601.png" alt="image-20211120202601728"></p>
<p>将第二个圆设置为剪裁区域</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">context.fillStyle=<span class="string">&#x27;#f00&#x27;</span>;</span><br><span class="line">context.beginPath();</span><br><span class="line">context.arc(x - <span class="number">40</span>, y + <span class="number">50</span>, radius, <span class="built_in">Math</span>.PI / <span class="number">180</span> * startAngle, <span class="built_in">Math</span>.PI / <span class="number">180</span> * endAngle, anticlockwise);</span><br><span class="line">context.fill();</span><br><span class="line">context.clip();</span><br></pre></td></tr></table></figure>

<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120202629.png" alt="image-20211120202629039"></p>
<h2 id="取消裁切区"><a href="#取消裁切区" class="headerlink" title="取消裁切区"></a>取消裁切区</h2><p>当使用裁切区clip()进行绘图后，可能需要取消该裁选区或者重新定义裁切区。在Canvas中，可以通过save()函数和restore()函数来实现——在构建裁切区之前保存状态，完成裁切区内的绘图之后进行状态读取。</p>
<h2 id="图像剪裁"><a href="#图像剪裁" class="headerlink" title="图像剪裁"></a>图像剪裁</h2><p>前面说过，drawImage 如果有9个参数，image参数后的四个参数可以指定剪裁区域</p>
<p><code>drawImage(image,sx,sy,sw,sh,dx,dy,dw,dh)</code></p>
<p>如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> context = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> image = <span class="keyword">new</span> Image();</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  canvas.width = <span class="number">640</span>;</span><br><span class="line">  canvas.height = <span class="number">337</span>;</span><br><span class="line">  image.src = <span class="string">&#x27;http://localhost/bg.jpg&#x27;</span>;</span><br><span class="line">  image.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    context.drawImage(image, <span class="number">50</span>,<span class="number">50</span>,<span class="number">200</span>,<span class="number">200</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码，表示将原图从左上角50,50处开始截取，截取200,200的宽和高，绘制到canvas中100，100，开始200,200大小的画布上，此时效果如下：</p>
<h2 id="使用剪裁实现缩放"><a href="#使用剪裁实现缩放" class="headerlink" title="使用剪裁实现缩放"></a><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120203134.png" alt="image-20211120203134252">使用剪裁实现缩放</h2><p>其实使用剪裁也可以实现图片缩放，只需将裁剪宽高设置为整个图片的宽高即可，但是图像可能会发生伸缩现象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> context = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> image = <span class="keyword">new</span> Image();</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  canvas.width = <span class="number">640</span>;</span><br><span class="line">  canvas.height = <span class="number">337</span>;</span><br><span class="line">  image.src = <span class="string">&#x27;http://localhost/bg.jpg&#x27;</span>;</span><br><span class="line">  image.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    context.drawImage(image, <span class="number">0</span>, <span class="number">0</span>, image.width, image.height, <span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120203410.png" alt="006"></p>
<h1 id="图像缩放"><a href="#图像缩放" class="headerlink" title="图像缩放"></a>图像缩放</h1><p>原理图：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120203438.png" alt="image-20211120203438129"></p>
<p>绿色边框为图片(img)区域，蓝色边框为canvas区域</p>
<p>根据上图可以得出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dx = canvas.width / <span class="number">2</span> - img.width / <span class="number">2</span>;</span><br><span class="line">dy = canvas.height / <span class="number">2</span> - img.height / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>根据 drawImage 的特性，指定起始点坐标和宽高即可实现图像缩放，配合着input[type=range]即可实现图片的缩放，这种缩放得到的是一个等比缩放的图像。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#x27;padding: 2em; border: 1px solid black&#x27;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;range&quot;</span> <span class="attr">id</span>=<span class="string">&quot;scale_range&quot;</span> <span class="attr">min</span>=<span class="string">&quot;0.5&quot;</span> <span class="attr">max</span>=<span class="string">&quot;3.0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1.0&quot;</span> <span class="attr">step</span>=<span class="string">&quot;0.02&quot;</span> <span class="attr">style</span>=<span class="string">&#x27;width:100%&#x27;</span>/&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> context = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> slide = <span class="built_in">document</span>.getElementById(<span class="string">&quot;scale_range&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> image = <span class="keyword">new</span> Image();</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  canvas.width = <span class="number">640</span>;</span><br><span class="line">  canvas.height = <span class="number">337</span>;</span><br><span class="line">  <span class="keyword">var</span> scale = slide.value; <span class="comment">// 获得初始的缩放值</span></span><br><span class="line">  image.src = <span class="string">&#x27;http://localhost/bg.jpg&#x27;</span>;</span><br><span class="line">  image.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当图片完全加载完成，在进行绘制</span></span><br><span class="line">    drawScaleImage(scale);</span><br><span class="line">    <span class="comment">// 为slide添加鼠标移动的事件，每次鼠标在该slide上移动的时候更具新的value重新绘制image</span></span><br><span class="line">    slide.onmousemove = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      scale = slide.value; <span class="comment">// 获得当前的缩放值</span></span><br><span class="line">      drawScaleImage(scale); <span class="comment">// 根据新的scale重新绘制image</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawScaleImage</span>(<span class="params">scale</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获得缩放以后的图片的宽和高</span></span><br><span class="line">  <span class="keyword">var</span> imageWidth = canvas.width * scale;</span><br><span class="line">  <span class="keyword">var</span> imageHeight = canvas.height * scale;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> dx = canvas.width / <span class="number">2</span> - imageWidth / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> dy = canvas.height / <span class="number">2</span> - imageHeight / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每次在绘制新的image之前先清除当前canvas</span></span><br><span class="line">  context.clearRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line">  context.drawImage(image, dx, dy, imageWidth, imageHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120204822.png" alt="image-20211120204822023"></p>
<h1 id="图像合成"><a href="#图像合成" class="headerlink" title="图像合成"></a>图像合成</h1><p>合成是指如何精细控制画布上对象的透明度和分层效果。在默认情况之下，如果在Canvas之中将某个物体（源）绘制在另一个物体（目标）之上，那么浏览器就会简单地把源特体的图像叠放在目标物体图像上面。</p>
<p>控制图像合成操作<br>在 Canvas 中有两个属性 globalAlpha 和 globalCompositeOperation 来控制图像合成操作：</p>
<ul>
<li>globalAlpha：设置图像的透明度。globalAlpha属性默认值为1，表示完全不透明，并且可以设置从0（完全透明）到1（完全不透明）。这个值必须设置在图形绘制之前</li>
<li>globalCompositeOperation：该属性的值在globalAlpha以及所有变换都生效后控制在当前Canvas位图中绘制图形</li>
</ul>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.fillStyle = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">ctx.globalCompositeOperation = <span class="string">&quot;source-over&quot;</span>; <span class="comment">//全局合成操作</span></span><br><span class="line">ctx.fillStyle = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">ctx.fillRect(<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure>

<h2 id="图像合成类型"><a href="#图像合成类型" class="headerlink" title="图像合成类型"></a>图像合成类型</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.globalCompositeOperation = type</span><br></pre></td></tr></table></figure>

<p>在 Canvas 中 globalCompositeOperation 属性的值总共有26种类型</p>
<p>常见的有以下几种：</p>
<ol>
<li>source-over (default) 这是默认设置，新图像会覆盖在原有图像。</li>
<li>source-in 仅仅会出现新图像与原来图像重叠的部分，其他区域都变成透明的。(包括其他的老图像区域也会透明)</li>
<li>source-out 仅仅显示新图像与老图像没有重叠的部分，其余部分全部透明。(老图像也不显示)</li>
<li>source-atop 新图像仅仅显示与老图像重叠区域。老图像仍然可以显示。</li>
<li>destination-over 新图像会在老图像的下面。</li>
<li>destination-in 仅仅新老图像重叠部分的老图像被显示，其他区域全部透明。</li>
<li>destination-out 仅仅老图像与新图像没有重叠的部分。 注意显示的是老图像的部分区域。</li>
<li>destination-atop 老图像仅仅仅仅显示重叠部分，新图像会显示在老图像的下面。</li>
<li>lighter 新老图像都显示，但是重叠区域的颜色做加处理。</li>
<li>darken 保留重叠部分最黑的像素。(每个颜色位进行比较，得到最小的)。</li>
<li>lighten 保证重叠部分最量的像素。(每个颜色位进行比较，得到最大的)。</li>
<li>xor 重叠部分会变成透明。</li>
<li>copy 只有新图像会被保留，其余的全部被清除(边透明)。</li>
</ol>
<h1 id="图像特效"><a href="#图像特效" class="headerlink" title="图像特效"></a>图像特效</h1><h2 id="相片底片"><a href="#相片底片" class="headerlink" title="相片底片"></a>相片底片</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param &#123;object&#125; img 要实现反相的图片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRevertPic</span>(<span class="params">img</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line">  canvas.width = img.width;</span><br><span class="line">  canvas.height = img.height;</span><br><span class="line">  <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">  ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">var</span> c = ctx.getImageData(<span class="number">0</span>, <span class="number">0</span>, img.width, img.height);</span><br><span class="line">  <span class="comment">// chrome浏览器报错，ie浏览器报安全错误信息，原因往下看</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; c.height; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; c.width; ++j) &#123;</span><br><span class="line">      <span class="keyword">var</span> x = i * <span class="number">4</span> * c.width + <span class="number">4</span> * j,  <span class="comment">// imagedata读取的像素数据存储在data属性里，是从上到下，从左到右的，每个像素需要占用4位数据，分别是r,g,b,alpha透明通道</span></span><br><span class="line">        r = c.data[x],</span><br><span class="line">        g = c.data[x + <span class="number">1</span>],</span><br><span class="line">        b = c.data[x + <span class="number">2</span>];</span><br><span class="line">      <span class="comment">//图片反相：</span></span><br><span class="line">      c.data[x] = <span class="number">255</span> - r;</span><br><span class="line">      c.data[x + <span class="number">1</span>] = <span class="number">255</span> - g;</span><br><span class="line">      c.data[x + <span class="number">2</span>] = <span class="number">255</span> - b;</span><br><span class="line">      c.data[x + <span class="number">3</span>] = <span class="number">255</span>;    <span class="comment">// 透明度设置为150,0表示完全透明</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.putImageData(c, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> canvas.toDataURL(); <span class="comment">// 返回canvas图片数据url</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> targetCanvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;targetCanvas&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> context = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> ctx = targetCanvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">  image.src = <span class="string">&#x27;http://localhost/bg.jpg&#x27;</span>;</span><br><span class="line">  image.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    context.drawImage(image, <span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">    img.src = createRevertPic(image)</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, targetCanvas.width, targetCanvas.height);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120205224.webp" alt="008"></p>
<p>如果将 ctx.putImageData(c, 0, 0) 改为 ctx.putImageData(c, 0, 0, 50, 50, img.width/2, img.height/2) 将会看到剪裁效果，效果如下：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120205257.webp" alt="009"></p>
<h2 id="灰度图像"><a href="#灰度图像" class="headerlink" title="灰度图像"></a>灰度图像</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param &#123;object&#125; img 要实现灰度的图片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createGreyPic</span>(<span class="params">img</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line">  canvas.width = img.width;</span><br><span class="line">  canvas.height = img.height;</span><br><span class="line">  <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">  ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">var</span> c = ctx.getImageData(<span class="number">0</span>, <span class="number">0</span>, img.width, img.height);</span><br><span class="line">  <span class="keyword">var</span> pxData = c.data;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; c.height; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; c.width; ++j) &#123;</span><br><span class="line">      <span class="keyword">var</span> x = i * <span class="number">4</span> * c.width + <span class="number">4</span> * j,</span><br><span class="line">        r = c.data[x],</span><br><span class="line">        g = c.data[x + <span class="number">1</span>],</span><br><span class="line">        b = c.data[x + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> grey = r * <span class="number">0.3</span> + g * <span class="number">0.59</span> + b * <span class="number">0.11</span>; <span class="comment">// 转换函数</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 灰度图片</span></span><br><span class="line">      c.data[x] = grey;</span><br><span class="line">      c.data[x + <span class="number">1</span>] = grey;</span><br><span class="line">      c.data[x + <span class="number">2</span>] = grey;</span><br><span class="line">      c.data[x + <span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.putImageData(c, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> canvas.toDataURL();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> targetCanvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;targetCanvas&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> context = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> ctx = targetCanvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">  image.src = <span class="string">&#x27;http://localhost/bg.jpg&#x27;</span>;</span><br><span class="line">  image.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    context.drawImage(image, <span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">    img.src = createGreyPic(image)</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, targetCanvas.width, targetCanvas.height);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120205336.webp" alt="010"></p>
<p>注意到，相比图像反向，只是更改了公式: grey = r * 0.3 + g * 0.59 + b * 0.11;</p>
<p>其实图像处理就是各像素点之间的函数映射，不同的图像处理公式对应不同的结果而已。</p>
<p>可以根据这些公式，制作各种不同的图像处理滤镜。</p>
<h1 id="添加水印"><a href="#添加水印" class="headerlink" title="添加水印"></a>添加水印</h1><p>使用drawImage甚至可以接受另一个canvas的dom作为参数，因此可以在此基础上得到很多奇妙的效果，比如为图像添加水印。</p>
<p>比如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#water</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;water&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;40&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> context = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> water = <span class="built_in">document</span>.getElementById(<span class="string">&quot;water&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = water.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> image = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  canvas.width = <span class="number">640</span>;</span><br><span class="line">  canvas.height = <span class="number">337</span>;</span><br><span class="line">  image.src = <span class="string">&#x27;https://img.xiaoyulive.top/img/date/20180913/005.jpg&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  ctx.fillStyle=<span class="string">&#x27;#fff&#x27;</span>;</span><br><span class="line">  ctx.font = <span class="string">&quot;20px sans-serif&quot;</span></span><br><span class="line">  ctx.fillText(<span class="string">&#x27;小昱版权所有&#x27;</span>, <span class="number">0</span>, water.height / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  image.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    context.drawImage(image, <span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line">    context.drawImage(water, canvas.width - water.width, canvas.height - water.height, water.width, water.height);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120205615.jpg" alt="下载-jpg"></p>
<h1 id="图像像素点的处理"><a href="#图像像素点的处理" class="headerlink" title="图像像素点的处理"></a>图像像素点的处理</h1><h2 id="使用getImageData获取图像数据"><a href="#使用getImageData获取图像数据" class="headerlink" title="使用getImageData获取图像数据"></a>使用getImageData获取图像数据</h2><p>getImageData() 方法返回 ImageData 对象，该对象拷贝了画布指定矩形的像素数据。</p>
<p>比如获取整个画布的所有像素点数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, eventWindowLoaded, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eventWindowLoaded</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvasOne&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line">  draw(ctx, canvas)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">context, canvas</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> w = canvas.width</span><br><span class="line">  <span class="keyword">let</span> h = canvas.height</span><br><span class="line">  context.fillStyle=<span class="string">&#x27;#0f0&#x27;</span></span><br><span class="line">  context.fillRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">  <span class="keyword">let</span> imgData = context.getImageData(<span class="number">0</span>, <span class="number">0</span>, w, h)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到控制台打印出的 imgData 长这样</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120205707.png" alt="image-20211120205706947"></p>
<p>以看到，imgData.width 和 imgData.height 都为100，则有 100*100 个像素点</p>
<p>其中 imgData.data 是一个 Uint8ClampedArray，简单理解为一个数组就行</p>
<h2 id="每个像素点的值"><a href="#每个像素点的值" class="headerlink" title="每个像素点的值"></a>每个像素点的值</h2><p>对于 ImageData 对象中的每个像素，都存在着四方面的信息，即 RGBA 值：</p>
<ul>
<li>R - 红色 (0-255)</li>
<li>G - 绿色 (0-255)</li>
<li>B - 蓝色 (0-255)</li>
<li>A - alpha 通道 (0-255; 0 是透明的，255 是完全可见的)</li>
</ul>
<p>这些值以数组形式存在，并存储于 ImageData 对象的 data 属性中。</p>
<p>比如获取第一个像素点的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> red = imgData.data[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> green = imgData.data[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> blue = imgData.data[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> alpha = imgData.data[<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(red, green, blue, alpha)</span><br></pre></td></tr></table></figure>

<p>可以看到 imgData.data 每四个元素组成一个像素点，上面说了，我们获取到 100<em>100 个像素点，则整个 imgData.data 数组包括 100</em>100*4 个元素，也就是 40000 个元素。</p>
<p>因此可以使用循环获取到每个像素点的值，针对这些像素点进行数字图像处理。</p>
<p>使用putImageData绘制图像数据<br>putImageData() 方法将图像数据（从指定的 ImageData 对象）放回画布上。</p>
<p>putImageData 可以有三个参数，也可以有七个参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">putImageData(imgData, x, y)</span><br><span class="line">putImageData(imgData, x, y, dx, dy, dw, dh)</span><br></pre></td></tr></table></figure>

<p>其中第一个参数imgData规定要放回画布的 ImageData 对象。</p>
<ul>
<li>x 和 y 为 ImageData 对象左上角坐标 (x, y)，以像素计。</li>
<li>后四个参数为剪裁区域，规定在画布上放置图像的位置 (dx, dy)，宽高分别为 dw，dh，以像素计。</li>
</ul>
<p>比如将一个图像反转：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, eventWindowLoaded, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eventWindowLoaded</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvasOne&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line">  draw(ctx, canvas)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">context, canvas</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> w = canvas.width</span><br><span class="line">  <span class="keyword">let</span> h = canvas.height</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> lg = context.createLinearGradient(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">100</span>)</span><br><span class="line">  lg.addColorStop(<span class="number">0</span>, <span class="string">&#x27;#f00&#x27;</span>)</span><br><span class="line">  lg.addColorStop(<span class="number">.5</span>, <span class="string">&#x27;#0f0&#x27;</span>)</span><br><span class="line">  lg.addColorStop(<span class="number">1</span>, <span class="string">&#x27;#00f&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  context.fillStyle = lg</span><br><span class="line">  context.fillRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> imgData = context.getImageData(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(imgData)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; imgData.data.length; i += <span class="number">4</span>) &#123;</span><br><span class="line">    imgData.data[i] = <span class="number">255</span>-imgData.data[i];</span><br><span class="line">    imgData.data[i+<span class="number">1</span>] = <span class="number">255</span>-imgData.data[i+<span class="number">1</span>];</span><br><span class="line">    imgData.data[i+<span class="number">2</span>] = <span class="number">255</span>-imgData.data[i+<span class="number">2</span>];</span><br><span class="line">    imgData.data[i+<span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  context.putImageData(imgData, <span class="number">150</span>, <span class="number">150</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120205917.png" alt="image-20211120205917385"></p>
<h2 id="使用createImageData创建图像数据"><a href="#使用createImageData创建图像数据" class="headerlink" title="使用createImageData创建图像数据"></a>使用createImageData创建图像数据</h2><p>createImageData() 方法创建新的空白 ImageData 对象。新对象的默认像素值 transparent black。</p>
<p>对于 ImageData 对象中的每个像素，都存在着四方面的信息，即 RGBA 值：</p>
<ul>
<li>R - 红色 (0-255)</li>
<li>G - 绿色 (0-255)</li>
<li>B - 蓝色 (0-255)</li>
<li>A - alpha 通道 (0-255; 0 是透明的，255 是完全可见的)</li>
</ul>
<p>因此，transparent black 表示 (0,0,0,0)。</p>
<p>color/alpha 以数组形式存在，并且既然数组包含了每个像素的四条信息，数组的大小是 ImageData 对象的四倍。（获得数组大小有更简单的办法，就是使用 ImageDataObject.data.length）</p>
<p>比如绘制一个随机杂色：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = c.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> imgData = ctx.createImageData(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; imgData.data.length; i += <span class="number">4</span>) &#123;</span><br><span class="line">  imgData.data[i] = (i * <span class="number">2</span> + <span class="built_in">Math</span>.random() * <span class="number">1000</span>) % <span class="number">256</span>;</span><br><span class="line">  imgData.data[i + <span class="number">1</span>] = (i * <span class="number">3</span> + <span class="built_in">Math</span>.random() * <span class="number">500</span>) % <span class="number">256</span>;</span><br><span class="line">  imgData.data[i + <span class="number">2</span>] = (i * <span class="number">4</span> + <span class="built_in">Math</span>.random() * <span class="number">200</span>) % <span class="number">256</span>;</span><br><span class="line">  imgData.data[i + <span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line">ctx.putImageData(imgData, <span class="number">10</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120210018.png" alt="image-20211120210018930"></p>
<h1 id="捕捉视频图像"><a href="#捕捉视频图像" class="headerlink" title="捕捉视频图像"></a>捕捉视频图像</h1><p>使用drawImage可以接受一个video的dom作为参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;video src=<span class="string">&quot;http://xiaoyulive.oss-cn-beijing.aliyuncs.com/imgs/mov_bbb.mp4&quot;</span> controls&gt;&lt;/video&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">let</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvas&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">let</span> video = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;video&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">let</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">let</span> i = <span class="literal">undefined</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  video.addEventListener(<span class="string">&#x27;play&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    i = <span class="built_in">window</span>.setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      ctx.drawImage(video, <span class="number">0</span>, <span class="number">0</span>, <span class="number">270</span>, <span class="number">135</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;, <span class="number">20</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;, <span class="literal">false</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  video.addEventListener(<span class="string">&#x27;pause&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="built_in">window</span>.clearInterval(i);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;, <span class="literal">false</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  video.addEventListener(<span class="string">&#x27;ended&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="built_in">clearInterval</span>(i);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;, <span class="literal">false</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>通过这种方式，我们可以实现很多自定义的视频播放功能。首先隐藏源video标签，然后在canvas中添加各种控制控件、弹幕、滤镜等等。这样做还能防止视频被很容易地窃取。</p>
<h1 id="向原型中添加绘制方法"><a href="#向原型中添加绘制方法" class="headerlink" title="向原型中添加绘制方法"></a>向原型中添加绘制方法</h1><h2 id="绘制圆点线"><a href="#绘制圆点线" class="headerlink" title="绘制圆点线"></a>绘制圆点线</h2><p>在 Canvas 中没有直接绘制圆点(dotted)线的 API，需要的时候可以自行扩展 CanvasRenderingContext2D 原型，进行绘制圆点线。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> canvasPrototype = <span class="built_in">window</span>.CanvasRenderingContext2D &amp;&amp; CanvasRenderingContext2D.prototype;</span><br><span class="line">canvasPrototype.dottedLine = <span class="function"><span class="keyword">function</span> (<span class="params">x1, y1, x2, y2, interval</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!interval) &#123;</span><br><span class="line">    interval = <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> isHorizontal = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (x1 == x2) &#123;</span><br><span class="line">    isHorizontal = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> len = isHorizontal ? x2 - x1 : y2 - y1;</span><br><span class="line">  <span class="built_in">this</span>.moveTo(x1, y1);</span><br><span class="line">  <span class="keyword">let</span> progress = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (len &gt; progress) &#123;</span><br><span class="line">    progress += interval;</span><br><span class="line">    <span class="keyword">if</span> (progress &gt; len) &#123;</span><br><span class="line">      progress = len;</span><br><span class="line">    &#125; <span class="keyword">if</span> (isHorizontal) &#123;</span><br><span class="line">      <span class="built_in">this</span>.moveTo(x1 + progress, y1);</span><br><span class="line">      <span class="built_in">this</span>.arc(x1 + progress, y1, <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">      <span class="built_in">this</span>.fill();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.moveTo(x1, y1 + progress);</span><br><span class="line">      <span class="built_in">this</span>.arc(x1, y1 + progress, <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">      <span class="built_in">this</span>.fill();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认绘制圆点线</span></span><br><span class="line">context.dottedLine(<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line"><span class="comment">// 指定圆点间距</span></span><br><span class="line">context.dottedLine(<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120210342.png" alt="image-20211120210341980"></p>
<h1 id="Canvas-坐标系"><a href="#Canvas-坐标系" class="headerlink" title="Canvas 坐标系"></a>Canvas 坐标系</h1><p>在了解Canvas坐标系之前，先看看我们比较熟悉的一些坐标系统。</p>
<h2 id="笛卡坐标系"><a href="#笛卡坐标系" class="headerlink" title="笛卡坐标系"></a>笛卡坐标系</h2><p>笛卡坐标系（Cartesian Coordinate system），这个坐标系统也称为直角坐标系，是一种正交坐标系。</p>
<p>二维的直角坐标系是由两条相互垂直、0点重合的数轴构成的。在平面内，任何一点的坐标是根据数轴上对应的点的坐标设定的。在平面内，任何一点与坐标的对应关系，类似于数轴上点与坐标的对应关系。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120210438.png" alt="image-20211120210438281"></p>
<p>可以看到，每个点都有一双与之关联的值。这些被称为坐标点，通常表示为(x,y)。x位于水平轴上，y位于垂直轴上。其中(0,0)点是坐标原点。x轴从原点向右方向为正值，反之为负值，y轴从原点向上为正值，反之为负值。</p>
<h2 id="Web-坐标系统"><a href="#Web-坐标系统" class="headerlink" title="Web 坐标系统"></a>Web 坐标系统</h2><p>在Web页面中，或者说我们的浏览器中也有一个坐标系统。只是他和我们数学中的坐标系统不一样。Web的坐标系统的原点是在屏幕（浏览器屏幕）的左上角。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120210517.png" alt="image-20211120210517285"></p>
<p>它有两个坐标轴，x轴（水平轴）和y轴（垂直轴）。两轴的交汇点（左上角）为坐标原点(0,0)。原点沿x轴向右是正值，原点沿y轴向下是正值。</p>
<h2 id="Canvas-坐标系统"><a href="#Canvas-坐标系统" class="headerlink" title="Canvas 坐标系统"></a>Canvas 坐标系统</h2><p>在Canvas中有2D和3D之分，可以通过getContext(‘2d’)让Canvas得到一个2D环境。言外之意，它还有一个3D环境。这样一来，在Canvas中坐标系统也是有分的。</p>
<h3 id="Canvas-2D-坐标系统"><a href="#Canvas-2D-坐标系统" class="headerlink" title="Canvas 2D 坐标系统"></a>Canvas 2D 坐标系统</h3><p>在Canvas中2D环境中其坐标系统和Web的坐标系统是一致的。坐标原点(0,0)在<canvas> 画布的的左上角。同样的分为x和y两个轴。x轴向右为正值，y轴向下为正值。同样在canvas中，是没有办法直接看到。但同样，在canvas中使用负坐标不会导致canvas不能使用，只不过会移到canvas画布的外面。</p>
<p>比如我们在画布中绘制一个矩形</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.fillStyle = <span class="string">&#x27;#f36&#x27;</span>;</span><br><span class="line">ctx.fillRect(<span class="number">15</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120210602.png" alt="image-20211120210602394"></p>
<h3 id="Canvas-3D-坐标系统"><a href="#Canvas-3D-坐标系统" class="headerlink" title="Canvas 3D 坐标系统"></a>Canvas 3D 坐标系统</h3><p>3D坐标系统多了一个z轴，用来描述深度。比如说一个物体在绘制时，在屏幕之内或之外多远的距离。这里简单的介绍一下3D坐标系统。</p>
<p>如图所示，x轴从左向右在水平方向延展，y轴纵向延展，z轴的正值从屏幕中穿出。如果你熟悉2D坐标系统的概念，那么过渡到3D坐标系统会相当直观容易。<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120210632.png" alt="image-20211120210632345"></p>
<h3 id="绘制2D坐标系"><a href="#绘制2D坐标系" class="headerlink" title="绘制2D坐标系"></a>绘制2D坐标系</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myCanvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvas&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> ctx = myCanvas.getContext(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line">drawScreen()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawScreen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 横线与竖线的是距</span></span><br><span class="line">  <span class="keyword">var</span> dx = <span class="number">50</span>;</span><br><span class="line">  <span class="keyword">var</span> dy = <span class="number">50</span>;</span><br><span class="line">  <span class="comment">// 初始坐标原点</span></span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> w = myCanvas.width;</span><br><span class="line">  <span class="keyword">var</span> h = myCanvas.height;</span><br><span class="line">  <span class="comment">// 单个步长所表示的长度</span></span><br><span class="line">  <span class="keyword">var</span> xy = <span class="number">10</span>;</span><br><span class="line">  ctx.lineWidth = <span class="number">.1</span>;</span><br><span class="line">  ctx.strokeStyle = <span class="string">&#x27;rgba(100,100,100,.4)&#x27;</span></span><br><span class="line">  <span class="comment">// 画横线</span></span><br><span class="line">  <span class="keyword">while</span> (y &lt; h) &#123;</span><br><span class="line">    y += dy;</span><br><span class="line">    ctx.moveTo(x, y);</span><br><span class="line">    ctx.lineTo(w, y);</span><br><span class="line">    ctx.stroke();</span><br><span class="line">    <span class="comment">//横坐标的数字</span></span><br><span class="line">    ctx.fillText(xy, x, y - <span class="number">2</span>);</span><br><span class="line">    xy += <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 画竖线</span></span><br><span class="line">  y = <span class="number">0</span>;</span><br><span class="line">  xy = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">while</span> (x &lt; w) &#123;</span><br><span class="line">    x = x + dx;</span><br><span class="line">    ctx.moveTo(x, y);</span><br><span class="line">    ctx.lineTo(x, h);</span><br><span class="line">    ctx.stroke(); <span class="comment">//纵坐标的数字</span></span><br><span class="line">    ctx.fillText(xy, x + <span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">    xy += <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120210723.png" alt="image-20211120210723185"></p>
<h1 id="坐标变换原理"><a href="#坐标变换原理" class="headerlink" title="坐标变换原理"></a>坐标变换原理</h1><p>在使用Canvas坐标变换之前，需要先了解Canvas的坐标系统。详细请参考 Canvas 坐标系</p>
<p>Canvas 的坐标系统并不是一尘不变的。可以对 Canvas 坐标系统进行移动、旋转和缩放等操作。而这些操作被称为坐标变换。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120210917.png" alt="image-20211120210917041"></p>
<p>坐标变换包括: translate、rotate、scale。</p>
<h2 id="平移-translate"><a href="#平移-translate" class="headerlink" title="平移 translate"></a>平移 translate</h2><p><code>translate(x, y);</code></p>
<p>用来移动 canvas 的原点到指定的位置(坐标变换)</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120210952.png" alt="image-20211120210952385"></p>
<p>translate方法接受两个参数：</p>
<ul>
<li>x 是左右偏移量</li>
<li>y 是上下偏移量</li>
</ul>
<p>在做变形之前先保存状态是一个良好的习惯。大多数情况下，调用 restore 方法比手动恢复原先的状态要简单得多。又如果你是在一个循环中做位移但没有保存和恢复canvas 的状态，很可能到最后会发现怎么有些东西不见了，那是因为它很可能已经超出 canvas 范围以外了。</p>
<p>比如通过 translate 绘制重复的图形：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvas&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, draw(canvas), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">canvas</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">      context.save();</span><br><span class="line">      context.fillStyle=<span class="string">`rgb(<span class="subst">$&#123;i*<span class="number">40</span>&#125;</span>, <span class="subst">$&#123;j*<span class="number">30</span>&#125;</span>, <span class="subst">$&#123;(i + j)*<span class="number">20</span>&#125;</span>)`</span>;</span><br><span class="line">      context.translate(i * <span class="number">100</span>, j * <span class="number">100</span>);</span><br><span class="line">      context.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">80</span>, <span class="number">50</span>);</span><br><span class="line">      context.restore();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果:</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120211220.png" alt="image-20211120211220525"></p>
<h2 id="旋转-rotate"><a href="#旋转-rotate" class="headerlink" title="旋转 rotate"></a>旋转 rotate</h2><p><code>rotate(angle);</code></p>
<p>旋转坐标轴， 旋转的中心是 坐标原点。</p>
<p>这个方法只接受一个参数：旋转的角度(angle)，它是 顺时针方向 的，以 弧度 为单位的值。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120211306.png" alt="image-20211120211306856"></p>
<p>比如通过 translate 绘制旋转的图形：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvas&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, draw(canvas), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">canvas</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> context = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> w = canvas.width</span><br><span class="line">  <span class="keyword">let</span> h = canvas.height</span><br><span class="line"></span><br><span class="line">  context.save();</span><br><span class="line">  context.translate(w / <span class="number">2</span>, h / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">360</span>; i = i + <span class="number">45</span>) &#123;</span><br><span class="line">    index ++</span><br><span class="line">    context.rotate(<span class="built_in">Math</span>.PI/<span class="number">180</span> * i)</span><br><span class="line">    context.fillStyle = <span class="string">`rgb(<span class="subst">$&#123;index * <span class="number">10</span>&#125;</span>, <span class="subst">$&#123;index * <span class="number">20</span>&#125;</span>, <span class="subst">$&#123;index * <span class="number">50</span>&#125;</span>)`</span></span><br><span class="line">    context.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">20</span>,<span class="number">100</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  context.restore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120211359.png" alt="image-20211120211359755"></p>
<p>再比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvas&#x27;</span>).getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">  ctx.translate(<span class="number">75</span>,<span class="number">75</span>);  <span class="comment">// 移动原点到(75,75)处</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;<span class="number">6</span>;i++)&#123; <span class="comment">// 里往外画5圈圆</span></span><br><span class="line">    ctx.save(); <span class="comment">// 先保存状态</span></span><br><span class="line">    ctx.fillStyle = <span class="string">&#x27;rgb(&#x27;</span>+ (<span class="number">50</span>*i) +<span class="string">&#x27;,&#x27;</span>+ (<span class="number">255</span>-<span class="number">20</span>*i) +<span class="string">&#x27;,&#x27;</span> + (<span class="number">30</span>*i) + <span class="string">&#x27;)&#x27;</span>; <span class="comment">// 圆的颜色</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面实现效果是：通过旋转画板，在x轴上画圆。这样的好处是方便计算，所有圆在x轴上实现，通过旋转画板来画所有圆。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;i*<span class="number">6</span>; j++) &#123;</span><br><span class="line">      ctx.rotate(<span class="built_in">Math</span>.PI*<span class="number">2</span>/(i*<span class="number">6</span>)); <span class="comment">// 顺时针旋转Math.PI*2/(i*6)度</span></span><br><span class="line">      ctx.beginPath();</span><br><span class="line">      ctx.arc(<span class="number">0</span>,i*<span class="number">12.5</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="built_in">Math</span>.PI*<span class="number">2</span>,<span class="literal">true</span>); <span class="comment">// 在(0,12.5*i)处画圆，半径为5px，画360度。</span></span><br><span class="line">      ctx.fill();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx.restore(); <span class="comment">// 还原到保存前的状态</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">draw();</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120211448.png" alt="image-20211120211448201"></p>
<p>在很多实际场景中，我们对某个图形元素做旋转，默认情况之下，其旋转都会围绕Canvas坐标系统原点(0,0)进行旋转。但实际上，我们需要围绕元素中心点来做旋转。在CSS中，我们有一个transform-origin属性可以修改原点。但在Canvas中，就需要借助Canvas的坐标变换中的translate()方法来修改元素的原点，也就是将原点移动到元素的中心位置。</p>
<p>比如我们绘制一个矩形：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> width = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> height = <span class="number">100</span>;</span><br><span class="line">ctx.strokeRect(x, y, width, height);</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120211535.png" alt="image-20211120211535706"></p>
<p>时，我们可以将坐标中心移到矩形的中心，即</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctx.translate(x + width / 2; y + height / 2)</span><br></pre></td></tr></table></figure>

<p>此时再针对矩形做旋转即可：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120211608.png" alt="image-20211120211608142"></p>
<h2 id="拉伸-scale"><a href="#拉伸-scale" class="headerlink" title="拉伸 scale"></a>拉伸 scale</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scale(x, y)</span><br></pre></td></tr></table></figure>

<p>我们用它来增减图形在 canvas 中的像素数目，对形状，位图进行缩小或者放大。</p>
<p>scale方法接受两个参数。x,y分别是横轴和纵轴的缩放因子，它们都必须是正值。值比 1.0 小表示缩 小，比 1.0 大则表示放大，值为 1.0 时什么效果都没有。</p>
<p>举例说，如果 canvas 的 1 单位就是 1 个像素。我们设置缩放因子是 0.5，1 个单位就变成对应 0.5 个像素，这样绘制出来的形状就会是原先的一半。同理，设置为 2.0 时，1 个单位就对应变成了 2 像素，绘制的结果就是图形放大了 2 倍。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120211757.png" alt="image-20211120211757539"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.save()</span><br><span class="line"></span><br><span class="line">ctx.translate(<span class="number">120</span>, <span class="number">120</span>)</span><br><span class="line"></span><br><span class="line">ctx.strokeStyle = <span class="string">&#x27;#f00&#x27;</span></span><br><span class="line">ctx.strokeRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">50</span>,<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">ctx.scale(<span class="number">.5</span>, <span class="number">.5</span>)</span><br><span class="line">ctx.fillStyle = <span class="string">&#x27;#0f0&#x27;</span></span><br><span class="line">ctx.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">50</span>,<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">ctx.restore()</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120211832.png" alt="image-20211120211831985"></p>
<blockquote>
<p>同样的，缩放中心默认也是坐标原点，需要配合 translate 实现围绕元素的中心进行旋转。</p>
<p>只要在缩放、旋转或者组合旋转缩放前将原点平移到形状的中心，都可以得到想要的效果。记住，任何形状的中心点都是半宽的x值和半高的y值。这需要使用边界框理论找到中心点。</p>
</blockquote>
<p>坐标变换中的缩放可以用于实现很多不同的效果，比如说，在绘制了某个图形后，可以调用ctx.scale(-1, 1)来绘制其水平镜像或者调用ctx.scale(1, -1)来绘制其垂直镜像。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvas&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, draw(canvas), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">canvas</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line">  ctx.save();</span><br><span class="line">  ctx.strokeStyle = <span class="string">&#x27;#f36&#x27;</span>;</span><br><span class="line">  ctx.beginPath();</span><br><span class="line">  ctx.moveTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">  ctx.lineTo(<span class="number">150</span>, <span class="number">150</span>);</span><br><span class="line">  ctx.lineTo(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">  ctx.closePath();</span><br><span class="line">  ctx.stroke();</span><br><span class="line">  ctx.translate(<span class="number">350</span>, <span class="number">0</span>);</span><br><span class="line">  ctx.strokeStyle = <span class="string">&#x27;lime&#x27;</span>;</span><br><span class="line">  ctx.beginPath();</span><br><span class="line">  ctx.moveTo(-<span class="number">175</span>, <span class="number">0.5</span>);</span><br><span class="line">  ctx.lineTo(-<span class="number">175</span>, <span class="number">300.5</span>);</span><br><span class="line">  ctx.stroke();</span><br><span class="line">  ctx.scale(-<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  ctx.save();</span><br><span class="line">  ctx.strokeStyle = <span class="string">&#x27;#000&#x27;</span>;</span><br><span class="line">  ctx.beginPath();</span><br><span class="line">  ctx.moveTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">  ctx.lineTo(<span class="number">150</span>, <span class="number">150</span>);</span><br><span class="line">  ctx.lineTo(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">  ctx.closePath();</span><br><span class="line">  ctx.stroke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211120211924.png" alt="image-20211120211924527"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">满天鑫</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://smanman.github.io/post/40cf0c06.html">https://smanman.github.io/post/40cf0c06.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://smanman.github.io" target="_blank">满天鑫</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a><a class="post-meta__tags" href="/tags/canvas/">canvas</a></div><div class="post_share"><div class="social-share" data-image="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082219.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/9ecf1f9f.html"><img class="prev-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082137.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Node 第 4 天笔记</div></div></a></div><div class="next-post pull-right"><a href="/post/89c27a45.html"><img class="next-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212104.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Gulp--基于流的自动化构建工具</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/7e996e60.html" title="JavaScript基础第02天笔记"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082010.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-18</div><div class="title">JavaScript基础第02天笔记</div></div></a></div><div><a href="/post/2e39ac9e.html" title="day04 - Web APIs"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212050.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-18</div><div class="title">day04 - Web APIs</div></div></a></div><div><a href="/post/29321e82.html" title="CSS从入门到精通"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082219.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-18</div><div class="title">CSS从入门到精通</div></div></a></div><div><a href="/post/89c27a45.html" title="Gulp--基于流的自动化构建工具"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212104.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-19</div><div class="title">Gulp--基于流的自动化构建工具</div></div></a></div><div><a href="/post/3d42c651.html" title="PM2一键部署"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082231.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-19</div><div class="title">PM2一键部署</div></div></a></div><div><a href="/post/76016aa3.html" title="H5项目"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082159.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-19</div><div class="title">H5项目</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Canvas%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">Canvas概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BACanvas"><span class="toc-number">1.1.</span> <span class="toc-text">创建Canvas</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">1.2.</span> <span class="toc-text">渲染上下文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81"><span class="toc-number">1.3.</span> <span class="toc-text">检测浏览器是否支持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%85%E6%A0%BC%E5%92%8C%E5%9D%90%E6%A0%87%E7%A9%BA%E9%97%B4"><span class="toc-number">1.4.</span> <span class="toc-text">栅格和坐标空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E7%BD%91%E6%A0%BC"><span class="toc-number">1.5.</span> <span class="toc-text">绘制网格</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E5%9F%BA%E7%A1%80%E5%9B%BE%E5%BD%A2"><span class="toc-number">2.</span> <span class="toc-text">绘制基础图形</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E7%9F%A9%E5%BD%A2"><span class="toc-number">2.1.</span> <span class="toc-text">绘制矩形</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E8%B7%AF%E5%BE%84"><span class="toc-number">2.2.</span> <span class="toc-text">绘制路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E7%BA%BF%E6%AE%B5"><span class="toc-number">2.2.1.</span> <span class="toc-text">绘制线段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E5%9B%BE%E5%BD%A2"><span class="toc-number">2.2.2.</span> <span class="toc-text">绘制图形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E8%99%9A%E7%BA%BF"><span class="toc-number">2.2.3.</span> <span class="toc-text">绘制虚线</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E6%A0%B7%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">绘制样式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E9%A2%9C%E8%89%B2"><span class="toc-number">2.3.1.</span> <span class="toc-text">添加颜色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%A0%B7%E5%BC%8F"><span class="toc-number">2.3.2.</span> <span class="toc-text">添加样式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E6%96%87%E5%AD%97"><span class="toc-number">2.4.</span> <span class="toc-text">绘制文字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E6%A0%B7%E5%BC%8F"><span class="toc-number">2.4.1.</span> <span class="toc-text">文本样式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E5%9B%BE%E7%89%87"><span class="toc-number">2.5.</span> <span class="toc-text">绘制图片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E5%9C%86%E5%BC%A7"><span class="toc-number">2.6.</span> <span class="toc-text">绘制圆弧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#arc"><span class="toc-number">2.6.1.</span> <span class="toc-text">arc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arcTo"><span class="toc-number">2.6.2.</span> <span class="toc-text">arcTo</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF"><span class="toc-number">2.7.</span> <span class="toc-text">贝塞尔曲线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E5%8A%A8%E7%94%BB"><span class="toc-number">2.7.1.</span> <span class="toc-text">原理动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E4%BA%8C%E6%AC%A1%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF"><span class="toc-number">2.7.2.</span> <span class="toc-text">绘制二次贝塞尔曲线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E4%B8%89%E6%AC%A1%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF"><span class="toc-number">2.7.3.</span> <span class="toc-text">绘制三次贝塞尔曲线</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%90%E5%8F%98"><span class="toc-number">2.8.</span> <span class="toc-text">渐变</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%B8%90%E5%8F%98"><span class="toc-number">2.8.1.</span> <span class="toc-text">线性渐变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%84%E5%90%91%E6%B8%90%E5%8F%98"><span class="toc-number">2.8.2.</span> <span class="toc-text">径向渐变</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E5%A4%8D%E6%9D%82%E5%9B%BE%E5%BD%A2"><span class="toc-number">3.</span> <span class="toc-text">绘制复杂图形</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">3.1.</span> <span class="toc-text">正多边形基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">3.1.1.</span> <span class="toc-text">正多边形的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%B1%9E%E6%80%A7"><span class="toc-number">3.1.2.</span> <span class="toc-text">正多边形属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E8%A7%92%EF%BC%88Exterior-Angle%EF%BC%89"><span class="toc-number">3.1.3.</span> <span class="toc-text">外角（Exterior Angle）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%A7%92%EF%BC%88Interior-Angles%EF%BC%89"><span class="toc-number">3.1.4.</span> <span class="toc-text">内角（Interior Angles）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BF%83%E8%A7%92"><span class="toc-number">3.1.5.</span> <span class="toc-text">中心角</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%A4%9A%E8%BE%B9%E5%BD%A2%E6%AF%8F%E4%B8%AA%E9%A1%B6%E7%82%B9%E7%9A%84%E5%9D%90%E6%A0%87"><span class="toc-number">3.1.6.</span> <span class="toc-text">正多边形每个顶点的坐标</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E6%AD%A3%E5%A4%9A%E8%BE%B9%E5%BD%A2"><span class="toc-number">3.2.</span> <span class="toc-text">绘制正多边形</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E6%98%9F%E5%BD%A2"><span class="toc-number">3.3.</span> <span class="toc-text">绘制星形</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9A%E6%98%9F%E6%98%9F"><span class="toc-number">3.4.</span> <span class="toc-text">案例：星星</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98%E4%B8%8E%E6%81%A2%E5%A4%8D"><span class="toc-number">4.</span> <span class="toc-text">状态保存与恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#save"><span class="toc-number">4.1.</span> <span class="toc-text">save()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#restore"><span class="toc-number">4.2.</span> <span class="toc-text">restore()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%AA%E8%A3%81%E8%B7%AF%E5%BE%84"><span class="toc-number">5.</span> <span class="toc-text">剪裁路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%AA%E5%88%87%E5%8C%BA%E5%9F%9F"><span class="toc-number">5.1.</span> <span class="toc-text">剪切区域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%AA%E8%A3%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.1.1.</span> <span class="toc-text">剪裁示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%96%E6%B6%88%E8%A3%81%E5%88%87%E5%8C%BA"><span class="toc-number">5.2.</span> <span class="toc-text">取消裁切区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E5%89%AA%E8%A3%81"><span class="toc-number">5.3.</span> <span class="toc-text">图像剪裁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%89%AA%E8%A3%81%E5%AE%9E%E7%8E%B0%E7%BC%A9%E6%94%BE"><span class="toc-number">5.4.</span> <span class="toc-text">使用剪裁实现缩放</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E7%BC%A9%E6%94%BE"><span class="toc-number">6.</span> <span class="toc-text">图像缩放</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E5%90%88%E6%88%90"><span class="toc-number">7.</span> <span class="toc-text">图像合成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E5%90%88%E6%88%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.1.</span> <span class="toc-text">图像合成类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E7%89%B9%E6%95%88"><span class="toc-number">8.</span> <span class="toc-text">图像特效</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E7%89%87%E5%BA%95%E7%89%87"><span class="toc-number">8.1.</span> <span class="toc-text">相片底片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%81%B0%E5%BA%A6%E5%9B%BE%E5%83%8F"><span class="toc-number">8.2.</span> <span class="toc-text">灰度图像</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%B0%B4%E5%8D%B0"><span class="toc-number">9.</span> <span class="toc-text">添加水印</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E5%83%8F%E7%B4%A0%E7%82%B9%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">10.</span> <span class="toc-text">图像像素点的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8getImageData%E8%8E%B7%E5%8F%96%E5%9B%BE%E5%83%8F%E6%95%B0%E6%8D%AE"><span class="toc-number">10.1.</span> <span class="toc-text">使用getImageData获取图像数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%8F%E4%B8%AA%E5%83%8F%E7%B4%A0%E7%82%B9%E7%9A%84%E5%80%BC"><span class="toc-number">10.2.</span> <span class="toc-text">每个像素点的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8createImageData%E5%88%9B%E5%BB%BA%E5%9B%BE%E5%83%8F%E6%95%B0%E6%8D%AE"><span class="toc-number">10.3.</span> <span class="toc-text">使用createImageData创建图像数据</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8D%95%E6%8D%89%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F"><span class="toc-number">11.</span> <span class="toc-text">捕捉视频图像</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%91%E5%8E%9F%E5%9E%8B%E4%B8%AD%E6%B7%BB%E5%8A%A0%E7%BB%98%E5%88%B6%E6%96%B9%E6%B3%95"><span class="toc-number">12.</span> <span class="toc-text">向原型中添加绘制方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E5%9C%86%E7%82%B9%E7%BA%BF"><span class="toc-number">12.1.</span> <span class="toc-text">绘制圆点线</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Canvas-%E5%9D%90%E6%A0%87%E7%B3%BB"><span class="toc-number">13.</span> <span class="toc-text">Canvas 坐标系</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%9B%E5%8D%A1%E5%9D%90%E6%A0%87%E7%B3%BB"><span class="toc-number">13.1.</span> <span class="toc-text">笛卡坐标系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web-%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F"><span class="toc-number">13.2.</span> <span class="toc-text">Web 坐标系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Canvas-%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F"><span class="toc-number">13.3.</span> <span class="toc-text">Canvas 坐标系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Canvas-2D-%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F"><span class="toc-number">13.3.1.</span> <span class="toc-text">Canvas 2D 坐标系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Canvas-3D-%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F"><span class="toc-number">13.3.2.</span> <span class="toc-text">Canvas 3D 坐标系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%88%B62D%E5%9D%90%E6%A0%87%E7%B3%BB"><span class="toc-number">13.3.3.</span> <span class="toc-text">绘制2D坐标系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E5%8E%9F%E7%90%86"><span class="toc-number">14.</span> <span class="toc-text">坐标变换原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E7%A7%BB-translate"><span class="toc-number">14.1.</span> <span class="toc-text">平移 translate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC-rotate"><span class="toc-number">14.2.</span> <span class="toc-text">旋转 rotate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%89%E4%BC%B8-scale"><span class="toc-number">14.3.</span> <span class="toc-text">拉伸 scale</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 满天鑫</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="framework-info"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202301132049386.png"/><span> </span><a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">晋ICP备2022012091号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'pinglun-9gh2lmcnd8587831',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'pinglun-9gh2lmcnd8587831',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@latest/source/js/issues.min.js"></script><script src="//code.tidio.co/smwivpnwumemac2wohardi3d3gpud1ag.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>