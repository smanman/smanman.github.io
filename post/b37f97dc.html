<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Redis企业实战 | 小肥龙吃大冰淇淋</title><meta name="keywords" content="Redis"><meta name="author" content="小肥龙吃大冰淇淋"><meta name="copyright" content="小肥龙吃大冰淇淋"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="企业实战架构设计组件选择&#x2F;多级缓存的设计要分多个层次，在不同的层次上选择不同的缓存，包括JVM缓存、文件缓存和Redis缓存 JVM缓存JVM缓存就是本地缓存，设计在应用服务器中（tomcat）。 通常可以采用Ehcache和Guava Cache，在互联网应用中，由于要处理高并发，通常选择Guava Cache。 适用本地（JVM）缓存的场景：  1、对性能有非常高的要求。  2、不经常变化">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis企业实战">
<meta property="og:url" content="https://andice-cream.github.io/post/b37f97dc.html">
<meta property="og:site_name" content="小肥龙吃大冰淇淋">
<meta property="og:description" content="企业实战架构设计组件选择&#x2F;多级缓存的设计要分多个层次，在不同的层次上选择不同的缓存，包括JVM缓存、文件缓存和Redis缓存 JVM缓存JVM缓存就是本地缓存，设计在应用服务器中（tomcat）。 通常可以采用Ehcache和Guava Cache，在互联网应用中，由于要处理高并发，通常选择Guava Cache。 适用本地（JVM）缓存的场景：  1、对性能有非常高的要求。  2、不经常变化">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165213.jpg">
<meta property="article:published_time" content="2021-08-13T10:58:00.000Z">
<meta property="article:modified_time" content="2022-11-27T09:16:39.780Z">
<meta property="article:author" content="小肥龙吃大冰淇淋">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165213.jpg"><link rel="shortcut icon" href="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210805191028.png"><link rel="canonical" href="https://andice-cream.github.io/post/b37f97dc"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis企业实战',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-27 17:16:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/ali_icon.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mogai.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="小肥龙吃大冰淇淋" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">178</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">73</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">40</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165213.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小肥龙吃大冰淇淋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis企业实战</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-13T10:58:00.000Z" title="发表于 2021-08-13 18:58:00">2021-08-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-27T09:16:39.780Z" title="更新于 2022-11-27 17:16:39">2022-11-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis/">Redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis企业实战"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="企业实战"><a href="#企业实战" class="headerlink" title="企业实战"></a>企业实战</h1><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h3 id="组件选择-多级"><a href="#组件选择-多级" class="headerlink" title="组件选择/多级"></a>组件选择/多级</h3><p>缓存的设计要分多个层次，在不同的层次上选择不同的缓存，包括JVM缓存、文件缓存和Redis缓存</p>
<h4 id="JVM缓存"><a href="#JVM缓存" class="headerlink" title="JVM缓存"></a>JVM缓存</h4><p>JVM缓存就是本地缓存，设计在应用服务器中（tomcat）。 通常可以采用Ehcache和Guava Cache，在互联网应用中，由于要处理高并发，通常选择Guava Cache。 适用本地（JVM）缓存的场景： </p>
<p>1、对性能有非常高的要求。 </p>
<p>2、不经常变化 </p>
<p>3、占用内存不大 </p>
<p>4、有访问整个集合的需求 </p>
<p>5、数据允许不实时一致</p>
<h4 id="文件缓存"><a href="#文件缓存" class="headerlink" title="文件缓存"></a>文件缓存</h4><p> 这里的文件缓存是基于http协议的文件缓存，一般放在nginx中。 因为静态文件（比如css，js， 图片）中，很多都是不经常更新的。nginx使用proxy_cache将用户的请 求缓存到本地一个目录。下一个相同请求可以直接调取缓存文件，就不用去请求服务器了。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span> default_server;</span><br><span class="line">        <span class="attribute">server_name</span> localhost;</span><br><span class="line">        <span class="attribute">root</span> /mnt/note/;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">#要缓存文件的后缀，可以在以下设置。</span></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ .*\.(gif|jpg|png|css|js)(.*)</span> &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://ip地址:90;</span><br><span class="line">            <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host $host;</span><br><span class="line">            <span class="attribute">proxy_cache</span> cache_one;</span><br><span class="line">            <span class="attribute">proxy_cache_valid</span> <span class="number">200</span> <span class="number">302</span> <span class="number">24h</span>;</span><br><span class="line">            <span class="attribute">proxy_cache_valid</span> <span class="number">301</span> <span class="number">30d</span>;</span><br><span class="line">            <span class="attribute">proxy_cache_valid</span> any <span class="number">5m</span>;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">90d</span>;</span><br><span class="line">            <span class="attribute">add_header</span> wall <span class="string">&quot;hello lagou.&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h4><p>分布式缓存，采用主从+哨兵或RedisCluster的方式缓存数据库的数据。 在实际开发中 作为数据库使用，数据要完整 作为缓存使用 作为Mybatis的二级缓存使用</p>
<h3 id="缓存大小"><a href="#缓存大小" class="headerlink" title="缓存大小"></a>缓存大小</h3><p>GuavaCache的缓存设置方式:</p>
<p><code>CacheBuilder.newBuilder().maximumSize(num) // 超过num会按照LRU算法来移除缓存</code></p>
<p>Nginx的缓存设置方式：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attribute">proxy_cache_path</span> /path/to/cache levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=my_cache:<span class="number">10m</span> max_size=<span class="number">10g</span></span><br><span class="line">    inactive=<span class="number">60m</span> use_temp_path=<span class="literal">off</span>;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">proxy_cache</span> mycache;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://localhost:8000;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Redis缓存设置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">maxmemory</span>=<span class="string">num # 最大缓存量 一般为内存的3/4</span></span><br><span class="line"><span class="meta">maxmemory-policy</span> <span class="string">allkeys lru #</span></span><br></pre></td></tr></table></figure>

<p><strong>缓存淘汰策略的选择</strong></p>
<ul>
<li>allkeys-lru ： 在不确定时一般采用策略。 </li>
<li>volatile-lru ： 比allkeys-lru性能差 存 : 过期时间 </li>
<li>allkeys-random ： 希望请求符合平均分布(每个元素以相同的概率被访问) </li>
<li>自己控制：volatile-ttl 缓存穿透</li>
<li>禁止驱逐 用作DB 不设置maxmemory</li>
</ul>
<h3 id="key数量"><a href="#key数量" class="headerlink" title="key数量"></a>key数量</h3><p>官方说Redis单例能处理key：2.5亿个 一个key或是value大小最大是512M</p>
<h3 id="读写峰值"><a href="#读写峰值" class="headerlink" title="读写峰值"></a>读写峰值</h3><p>Redis采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由C语言编写，官方提供的数据是 可以达到110000+的QPS（每秒内查询次数）。80000的写</p>
<h3 id="命中率"><a href="#命中率" class="headerlink" title="命中率"></a>命中率</h3><p>命中：可以直接通过缓存获取到需要的数据。 </p>
<p>不命中：无法直接通过缓存获取到想要的数据，需要再次查询数据库或者执行其它的操作。原因可能是 由于缓存中根本不存在，或者缓存已经过期。 </p>
<p>通常来讲，缓存的命中率越高则表示使用缓存的收益越高，应用的性能越好（响应时间越短、吞吐量越 高），抗并发的能力越强。 由此可见，在高并发的互联网系统中，缓存的命中率是至关重要的指标。 通过info命令可以监控服务器状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info</span><br><span class="line"><span class="comment"># Server</span></span><br><span class="line">redis_version:5.0.5</span><br><span class="line">redis_git_sha1:00000000</span><br><span class="line">redis_git_dirty:0</span><br><span class="line">redis_build_id:e188a39ce7a16352</span><br><span class="line">redis_mode:standalone</span><br><span class="line">os:Linux 3.10.0-229.el7.x86_64 x86_64</span><br><span class="line">arch_bits:64</span><br><span class="line"><span class="comment">#缓存命中</span></span><br><span class="line">keyspace_hits:1000</span><br><span class="line"><span class="comment">#缓存未命中</span></span><br><span class="line">keyspace_misses:20</span><br><span class="line">used_memory:433264648</span><br><span class="line">expired_keys:1333536</span><br><span class="line">evicted_keys:1547380</span><br></pre></td></tr></table></figure>

<p>命中率=1000/1000+20=83%</p>
<p> 一个缓存失效机制，和过期时间设计良好的系统，命中率可以做到95%以上。 </p>
<p>影响缓存命中率的因素： </p>
<p>1、缓存的数量越少命中率越高，比如缓存单个对象的命中率要高于缓存集合 </p>
<p>2、过期时间越长命中率越高 </p>
<p>3、缓存越大缓存的对象越多，则命中的越多</p>
<h3 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h3><p>Redis的过期策略是定时删除+惰性删除。</p>
<h3 id="性能监控指标"><a href="#性能监控指标" class="headerlink" title="性能监控指标"></a>性能监控指标</h3><p>利用info命令就可以了解Redis的状态了，主要监控指标有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">connected_clients:68 #连接的客户端数量</span><br><span class="line">used_memory_rss_human:847.62M #系统给redis分配的内存</span><br><span class="line">used_memory_peak_human:794.42M #内存使用的峰值大小</span><br><span class="line">total_connections_received:619104 #服务器已接受的连接请求数量</span><br><span class="line">instantaneous_ops_per_sec:1159 #服务器每秒钟执行的命令数量 qps</span><br><span class="line">instantaneous_input_kbps:55.85 #redis网络入口kps</span><br><span class="line">instantaneous_output_kbps:3553.89 #redis网络出口kps</span><br><span class="line">rejected_connections:0 #因为最大客户端数量限制而被拒绝的连接请求数量</span><br><span class="line">expired_keys:0 #因为过期而被自动删除的数据库键数量</span><br><span class="line">evicted_keys:0 #因为最大内存容量限制而被驱逐（evict）的键数量</span><br><span class="line">keyspace_hits:0 #查找数据库键成功的次数</span><br><span class="line">keyspace_misses:0 #查找数据库键失败的次</span><br></pre></td></tr></table></figure>

<p>Redis监控平台： grafana、prometheus以及redis_exporter。</p>
<h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><p>缓存预热就是系统启动前,提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候,先查询 数据库,然后再将数据缓存的问题!用户直接查询实现被预热的缓存数据。 </p>
<p>加载缓存思路：</p>
<ul>
<li>数据量不大，可以在项目启动的时候自动进行加载 </li>
<li>利用定时任务刷新缓存，将数据库的数据刷新到缓存中</li>
</ul>
<h2 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如 DB）。 </p>
<p>缓存穿透是指在高并发下查询key不存在的数据，会穿过缓存查询数据库。导致数据库压力过大而宕机 </p>
<p>解决方案：</p>
<ul>
<li><p>对查询结果为空的情况也进行缓存，缓存时间（ttl）设置短一点，或者该key对应的数据insert了 之后清理缓存。</p>
<p>   问题：缓存太多空值占用了更多的空间 </p>
</li>
<li><p>使用布隆过滤器。在缓存之前在加一层布隆过滤器，在查询的时候先去布隆过滤器查询 key 是否 存在，如果不存在就直接返回，存在再查缓存和DB。</p>
</li>
</ul>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210813182300.png" alt="image-20210813182300818"></p>
<p>布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机hash映射函数。<br>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法。  </p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210813182418.png" alt="image-20210813182418912"></p>
<p>布隆过滤器的原理是，当一个元素被加入集合时，通过K个Hash函数将这个元素映射成一个数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。  </p>
<p>把字符串——&gt;位 省空间 （1或0）</p>
<p>不用循环——&gt;比较位置 省时间  </p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。<br>突然间大量的key失效了或redis重启，大量访问数据库，数据库崩溃<br>解决方案:</p>
<ol>
<li> key的失效期分散开 不同的key设置不同的有效期</li>
<li>设置二级缓存（数据不一定一致）</li>
<li>高可用（脏读）  </li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。<br>缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓<br>存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。<br>解决方案：</p>
<ol>
<li>用分布式锁控制访问的线程<br> 使用redis的setnx互斥锁先进行判断，这样其他线程就处于等待状态，保证不会有大并发操作去操作数据库。</li>
<li>不设超时时间，volatile-lru 但会造成写一致问题<br> 当数据库数据发生更新时，缓存中的数据不会及时更新，这样会造成数据库中的数据与缓存中的数据的不一致，应用会从缓存中读取到脏数据。可采用延时双删策略处理，这个我们后面会详细讲到。  </li>
</ol>
<h3 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h3><p>缓存和DB的数据不一致的根源 ： 数据源不一样<br>如何解决<br>强一致性很难，追求最终一致性（时间）<br>互联网业务数据处理的特点<br>高吞吐量<br>低延迟<br>数据敏感性低于金融业<br>时序控制是否可行？<br>先更新数据库再更新缓存或者先更新缓存再更新数据库<br>本质上不是一个原子操作，所以时序控制不可行  </p>
<p>高并发情况下会产生不一致  </p>
<p><strong>保证数据的最终一致性(延时双删)</strong><br>1、先更新数据库同时删除缓存项(key)，等读的时候再填充缓存<br>2、2秒后再删除一次缓存项(key)<br>3、设置缓存过期时间 Expired Time 比如 10秒 或1小时<br>4、将缓存删除失败记录到日志中，利用脚本提取失败记录再次删除（缓存失效期过长 7*24）<br>升级方案<br>通过数据库的binlog来异步淘汰key，利用工具(canal)将binlog日志采集发送到MQ中，然后通过ACK机<br>制确认处理删除缓存。  </p>
<h3 id="数据并发竞争"><a href="#数据并发竞争" class="headerlink" title="数据并发竞争"></a>数据并发竞争</h3><p>这里的并发指的是多个redis的client同时set 同一个key引起的并发问题。<br>多客户端（Jedis）同时并发写一个key，一个key的值是1，本来按顺序修改为2,3,4，最后是4，但是顺序变成了4,3,2，最后变成了2。  </p>
<p><strong>第一种方案：分布式锁+时间戳</strong><br><strong>1.整体技术方案</strong>  </p>
<p>这种情况，主要是准备一个分布式锁，大家去抢锁，抢到锁就做set操作。<br>加锁的目的实际上就是把并行读写改成串行读写的方式，从而来避免资源竞争  </p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210813182938.png" alt="image-20210813182938600"></p>
<p><strong>2.Redis分布式锁的实现</strong><br>主要用到的redis函数是setnx()<br>用SETNX实现分布式锁<br>时间戳<br>由于上面举的例子，要求key的操作需要顺序执行，所以需要保存一个时间戳判断set顺序。  </p>
<blockquote>
<p>系统A key 1 {ValueA 7:00}<br>系统B key 1 { ValueB 7:05}  </p>
</blockquote>
<p>假设系统B先抢到锁，将key1设置为{ValueB 7:05}。接下来系统A抢到锁，发现自己的key1的时间戳早于缓存中的时间戳（7:00&lt;7:05），那就不做set操作了。  </p>
<p><strong>第二种方案：利用消息队列</strong>  </p>
<p>在并发量过大的情况下,可以通过消息中间件进行处理,把并行读写进行串行化。<br>把Redis的set操作放在队列中使其串行化,必须的一个一个执行。  </p>
<h3 id="Hot-Key"><a href="#Hot-Key" class="headerlink" title="Hot Key"></a>Hot Key</h3><p>当有大量的请求(几十万)访问某个Redis某个key时，由于流量集中达到网络上限，从而导致这个redis的服务器宕机。造成缓存击穿，接下来对这个key的访问将直接访问数据库造成数据库崩溃，或者访问数据库回填Redis再访问Redis，继续崩溃。  </p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210813183117.png" alt="image-20210813183117663"></p>
<p><strong>如何发现热key</strong><br>1、预估热key，比如秒杀的商品、火爆的新闻等<br>2、在客户端进行统计，实现简单，加一行代码即可<br>3、如果是Proxy，比如Codis，可以在Proxy端收集<br>4、利用Redis自带的命令，monitor、hotkeys。但是执行缓慢（不要用）<br>5、利用基于大数据领域的流式计算技术来进行实时数据访问次数的统计，比如 Storm、Spark<br>Streaming、Flink，这些技术都是可以的。发现热点数据后可以写到zookeeper中  </p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210813183143.png" alt="image-20210813183142992"></p>
<p>如何处理热Key：<br>1、变分布式缓存为本地缓存<br>发现热key后，把缓存数据取出后，直接加载到本地缓存中。可以采用Ehcache、Guava Cache都可<br>以，这样系统在访问热key数据时就可以直接访问自己的缓存了。（数据不要求时时一致）<br>2、在每个Redis主节点上备份热key数据，这样在读取时可以采用随机读取的方式，将访问压力负载到每个Redis上。<br>3、利用对热点数据访问的限流熔断保护措施<br>每个系统实例每秒最多请求缓存集群读操作不超过 400 次，一超过就可以熔断掉，不让请求缓存集群，直接返回一个空白信息，然后用户稍后会自行再次重新刷新页面之类的。（首页不行，系统友好性差）<br>通过系统层自己直接加限流熔断保护措施，可以很好的保护后面的缓存集群。  </p>
<h3 id="Big-Key"><a href="#Big-Key" class="headerlink" title="Big Key"></a>Big Key</h3><p>大key指的是存储的值（Value）非常大，常见场景：</p>
<ul>
<li>热门话题下的讨论</li>
<li>大V的粉丝列表</li>
<li>序列化后的图片</li>
<li>没有及时处理的垃圾数据  </li>
</ul>
<p><strong>大key的影响：</strong></p>
<ul>
<li>大key会大量占用内存，在集群中无法均衡</li>
<li>Redis的性能下降，主从复制异常</li>
<li>在主动删除或过期删除时会操作时间过长而引起服务阻塞  </li>
</ul>
<p>如何发现大key：<br>1、redis-cli –bigkeys命令。可以找到某个实例5种数据类型(String、hash、list、set、zset)的最大<br>key。  </p>
<p>但如果Redis 的key比较多，执行该命令会比较慢<br>2、获取生产Redis的rdb文件，通过rdbtools分析rdb生成csv文件，再导入MySQL或其他数据库中进行<br>分析统计，根据size_in_bytes统计bigkey  </p>
<p>大key的处理：<br>优化big key的原则就是string减少字符串长度，list、hash、set、zset等减少成员数。<br>1、string类型的big key，尽量不要存入Redis中，可以使用文档型数据库MongoDB或缓存到CDN上。<br>如果必须用Redis存储，最好单独存储，不要和其他的key一起存储。采用一主一从或多从。<br>2、单个简单的key存储的value很大，可以尝试将对象分拆成几个key-value， 使用mget获取值，这样<br>分拆的意义在于分拆单次操作的压力，将操作压力平摊到多次操作中，降低对redis的IO影响。<br>2、hash， set，zset，list 中存储过多的元素，可以将这些元素分拆。（常见）  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">以hash类型举例来说，对于field过多的场景，可以根据field进行hash取模，生成一个新的key，例如原</span><br><span class="line">来的</span><br><span class="line">hash_key:&#123;filed1:value, filed2:value, filed3:value ...&#125;，可以hash取模后形成如下</span><br><span class="line">key:value形式</span><br><span class="line">hash_key:1:&#123;filed1:value&#125;</span><br><span class="line">hash_key:2:&#123;filed2:value&#125;</span><br><span class="line">hash_key:3:&#123;filed3:value&#125;</span><br><span class="line">...</span><br><span class="line">取模后，将原先单个key分成多个key，每个key filed个数为原先的1/N</span><br></pre></td></tr></table></figure>

<p>3.删除大key时不要使用del,因为del是阻塞命令，删除时会影响性能。<br>4、使用 lazy delete (unlink命令)<br>删除指定的key(s),若key不存在则该key被跳过。但是，相比DEL会产生阻塞，该命令会在另一个线程中<br>回收内存，因此它是非阻塞的。 这也是该命令名字的由来：仅将keys从key空间中删除，真正的数据删<br>除会在后续异步操作。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis&gt; SET key1 <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line">redis&gt; SET key2 <span class="string">&quot;World&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line">redis&gt; UNLINK key1 key2 key3</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>

<h2 id="缓存与数据库一致性"><a href="#缓存与数据库一致性" class="headerlink" title="缓存与数据库一致性"></a>缓存与数据库一致性</h2><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><ul>
<li>利用Redis的缓存淘汰策略被动更新 LRU 、LFU</li>
<li>利用TTL被动更新</li>
<li>在更新数据库时主动更新 （先更数据库再删缓存—-延时双删）</li>
<li>异步更新 定时任务 数据不保证时时一致 不穿DB</li>
</ul>
<h3 id="不同策略之间的优缺点"><a href="#不同策略之间的优缺点" class="headerlink" title="不同策略之间的优缺点"></a>不同策略之间的优缺点</h3><table>
<thead>
<tr>
<th>策略</th>
<th>一致性</th>
<th>维护成本</th>
</tr>
</thead>
<tbody><tr>
<td>利用Redis的缓存淘汰策略被动更新</td>
<td>最差</td>
<td>最低</td>
</tr>
<tr>
<td>利用TTL被动更新</td>
<td>较差</td>
<td>较低</td>
</tr>
<tr>
<td>在更新数据库时主动更新</td>
<td>较强</td>
<td>最高</td>
</tr>
</tbody></table>
<h3 id="与Mybatis整合"><a href="#与Mybatis整合" class="headerlink" title="与Mybatis整合"></a>与Mybatis整合</h3><p>可以使用Redis做Mybatis的二级缓存，在分布式环境下可以使用。<br>框架采用springboot+Mybatis+Redis。框架的搭建就不赘述了。<br>1、在pom.xml中添加Redis依赖  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、在application.yml中添加Redis配置  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开发配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#数据源配置</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.127.128:3306/test?</span></span><br><span class="line">    <span class="string">serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.127</span><span class="number">.128</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">-1ms</span></span><br><span class="line"><span class="comment">#公共配置与profiles选择无关</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">typeAliasesPackage:</span> <span class="string">com.lagou.rcache.entity</span></span><br><span class="line">  <span class="attr">mapperLocations:</span> <span class="string">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure>

<p>3、缓存实现<br>ApplicationContextHolder 用于注入RedisTemplate  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lagou.rcache.utils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextHolder</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext ctx;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//向工具类注入applicationContext</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    	ctx = applicationContext; <span class="comment">//ctx就是注入的applicationContext</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//外部调用ctx</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title">getCtx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; tClass)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ctx.getBean(tClass);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) ctx.getBean(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RedisCache 使用redis实现mybatis二级缓存  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lagou.rcache.utils;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisCallback;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.ValueOperations;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用redis实现mybatis二级缓存</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">    <span class="comment">//缓存对象唯一标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String id; <span class="comment">//orm的框架都是按对象的方式缓存，而每个对象都需要一个唯一标</span></span><br><span class="line">    识.</span><br><span class="line">    <span class="comment">//用于事务性缓存操作的读写锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="comment">//处理事务性缓存中做的</span></span><br><span class="line">    <span class="comment">//操作数据缓存的--跟着线程走的</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate; <span class="comment">//Redis的模板负责将缓存对象写到redis服务器里面去</span></span><br><span class="line">    <span class="comment">//缓存对象的是失效时间，30分钟</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> EXPRIRE_TIME_IN_MINUT = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">//构造方法---把对象唯一标识传进来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisCache</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;缓存对象id是不能为空的&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//给模板对象RedisTemplate赋值，并传出去</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RedisTemplate <span class="title">getRedisTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (redisTemplate == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">//每个连接池的连接都要获得RedisTemplate</span></span><br><span class="line">        	redisTemplate = ApplicationContextHolder.getBean(<span class="string">&quot;redisTemplate&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	保存缓存对象的方法</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RedisTemplate redisTemplate = getRedisTemplate();</span><br><span class="line">            <span class="comment">//使用redisTemplate得到值操作对象</span></span><br><span class="line">            ValueOperations operation = redisTemplate.opsForValue();</span><br><span class="line">            <span class="comment">//使用值操作对象operation设置缓存对象</span></span><br><span class="line">            operation.set(key, value, EXPRIRE_TIME_IN_MINUT, TimeUnit.MINUTES);</span><br><span class="line">            <span class="comment">//TimeUnit.MINUTES系统当前时间的分钟数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;缓存对象保存成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;缓存对象保存失败&quot;</span> + t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取缓存对象的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RedisTemplate redisTemplate = getRedisTemplate();</span><br><span class="line">            ValueOperations operations = redisTemplate.opsForValue();</span><br><span class="line">            Object result = operations.get(key);</span><br><span class="line">            System.out.println(<span class="string">&quot;获取缓存对象&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;缓存对象获取失败&quot;</span> + t);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Object</span> <span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RedisTemplate redisTemplate = getRedisTemplate();</span><br><span class="line">            redisTemplate.delete(key);</span><br><span class="line">            System.out.println(<span class="string">&quot;删除缓存对象成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除缓存对象失败！&quot;</span> + t);</span><br><span class="line">        &#125; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RedisTemplate redisTemplate = getRedisTemplate();</span><br><span class="line">        <span class="comment">//回调函数</span></span><br><span class="line">        redisTemplate.execute((RedisCallback) collection -&gt; &#123;</span><br><span class="line">        collection.flushDb();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;清空缓存对象成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReadWriteLock <span class="title">getReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> readWriteLock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、在mapper中增加二级缓存开启（默认不开启）  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.lagou.rcache.dao.UserDao&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;com.lagou.rcache.utils.RedisCache&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.lagou.rcache.entity.TUser&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;address&quot;</span> <span class="attr">property</span>=<span class="string">&quot;address&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Base_Column_List&quot;</span> &gt;</span></span><br><span class="line">    id, name, address</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUser&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">    select</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Base_Column_List&quot;</span> /&gt;</span></span><br><span class="line">    from tuser</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>5、在启动时允许缓存  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lagou.rcache;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.lagou.rcache.dao&quot;)</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RcacheApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	SpringApplication.run(RcacheApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>控制台：  </p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210813184441.png" alt="image-20210813184441873"></p>
<p>Redis客户端：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;\xac\xed\x00\x05sr\x00</span></span><br><span class="line"><span class="string">org.apache.ibatis.cache.CacheKey\x0f\xe9\xd5\xb4\xcd3\xa8\x82\x02\x00\x05J\x00\b</span></span><br><span class="line"><span class="string">checksumI\x00\x05countI\x00\bhashcodeI\x00\nmultiplierL\x00\nupdateListt\x00\x10</span></span><br><span class="line"><span class="string">Ljava/util/List;xp\x00\x00\x00\x00\x87\xd8u%\x00\x00\x00\x05\xb0\xf6RU\x00\x00\x</span></span><br><span class="line"><span class="string">00%sr\x00\x13java.util.ArrayListx\x81\xd2\x1d\x99\xc7a\x9d\x03\x00\x01I\x00\x04s</span></span><br><span class="line"><span class="string">izexp\x00\x00\x00\x05w\x04\x00\x00\x00\x05t\x00&#x27;com.lagou.rcache.dao.UserDao.sel</span></span><br><span class="line"><span class="string">ectUsersr\x00\x11java.lang.Integer\x12\xe2\xa0\xa4\xf7\x81\x878\x02\x00\x01I\x00</span></span><br><span class="line"><span class="string">\x05valuexr\x00\x10java.lang.Number\x86\xac\x95\x1d\x0b\x94\xe0\x8b\x02\x00\x00x</span></span><br><span class="line"><span class="string">p\x00\x00\x00\x00sq\x00~\x00\x06\x7f\xff\xff\xfft\x00Cselect\n \n</span></span><br><span class="line"><span class="string">id, name, address\n \n from tusert\x00\x15SqlSessionFactoryBeanx&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><h4 id="利用Watch实现Redis乐观锁"><a href="#利用Watch实现Redis乐观锁" class="headerlink" title="利用Watch实现Redis乐观锁"></a>利用Watch实现Redis乐观锁</h4><p>乐观锁基于CAS（Compare And Swap）思想（比较并替换），是不具有互斥性，不会产生锁等待而消<br>耗资源，但是需要反复的重试，但也是因为重试的机制，能比较快的响应。因此我们可以利用redis来实<br>现乐观锁。具体思路如下：<br>1、利用redis的watch功能，监控这个redisKey的状态值<br>2、获取redisKey的值<br>3、创建redis事务<br>4、给这个key的值+1<br>5、然后去执行这个事务，如果key的值被修改过则回滚，key不加1<br><strong>Redis乐观锁实现秒杀</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Second</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span> </span>&#123;</span><br><span class="line">        String redisKey = <span class="string">&quot;lock&quot;</span>;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6378</span>);</span><br><span class="line">            <span class="comment">// 初始值</span></span><br><span class="line">            jedis.set(redisKey, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                Jedis jedis1 = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6378</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    jedis1.watch(redisKey);</span><br><span class="line">                    String redisValue = jedis1.get(redisKey);</span><br><span class="line">                    <span class="keyword">int</span> valInteger = Integer.valueOf(redisValue);</span><br><span class="line">                    String userInfo = UUID.randomUUID().toString();</span><br><span class="line">                    <span class="comment">// 没有秒完</span></span><br><span class="line">                    <span class="keyword">if</span> (valInteger &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                        Transaction tx = jedis1.multi();</span><br><span class="line">                        tx.incr(redisKey);</span><br><span class="line">                        List list = tx.exec();</span><br><span class="line">                        <span class="comment">// 秒成功 失败返回空list而不是空</span></span><br><span class="line">                        <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;用户：&quot;</span> + userInfo + <span class="string">&quot;，秒杀成功！</span></span><br><span class="line"><span class="string">                                    当前成功人数：&quot;</span> + (valInteger + <span class="number">1</span>));</span><br><span class="line">                        &#125; <span class="comment">// 版本变化，被别人抢了。</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;用户：&quot;</span> + userInfo + <span class="string">&quot;，秒杀失败&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="comment">// 秒完了</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;已经有20人秒杀成功，秒杀结束&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    jedis1.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="setnx"><a href="#setnx" class="headerlink" title="setnx"></a>setnx</h3><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>共享资源互斥<br>共享资源串行化<br>单应用中使用锁：（单进程多线程）<br>synchronized、ReentrantLock<br>分布式应用中使用锁：（多进程多线程）<br>分布式锁是控制分布式系统之间同步访问共享资源的一种方式。<br>利用Redis的单线程特性对共享资源进行串行化处理  </p>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>获取锁<br>方式1（使用set命令实现）–推荐  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 使用redis的set命令实现获取分布式锁</span><br><span class="line">    *</span><br><span class="line">    * @param lockKey    可以就是锁</span><br><span class="line">    * @param requestId  请求ID，保证同一性 uuid+threadID</span><br><span class="line">    * @param expireTime 过期时间，避免死锁</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public boolean getLock(String lockKey, String requestId, int expireTime) &#123;</span><br><span class="line">       //NX:保证互斥性</span><br><span class="line">       // hset 原子性操作 只要lockKey有效 则说明有进程在使用分布式锁</span><br><span class="line">       String result = jedis.set(lockKey, requestId, &quot;NX&quot;, &quot;EX&quot;, expireTime);</span><br><span class="line">       if (&quot;OK&quot;.equals(result)) &#123;</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>方式2（使用setnx命令实现） – 并发会产生问题  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getLock</span><span class="params">(String lockKey,String requestId,<span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">	Long result = jedis.setnx(lockKey, requestId);</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//成功设置 进程down 永久有效 别的进程就无法获得锁</span></span><br><span class="line">    jedis.expire(lockKey, expireTime);</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放锁<br>方式1（del命令实现） – 并发  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/</span><br><span class="line">**</span><br><span class="line">* 释放分布式锁</span><br><span class="line">* @param lockKey</span><br><span class="line">* @param requestId</span><br><span class="line">*/</span><br><span class="line">public static void releaseLock(String lockKey,String requestId) &#123;</span><br><span class="line">    if (requestId.equals(jedis.get(lockKey))) &#123;</span><br><span class="line">    	jedis.del(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题在于如果调用jedis.del()方法的时候，这把锁已经不属于当前客户端的时候会解除他人加的锁。那么是否真的有这种场景？答案是肯定的，比如客户端A加锁，一段时间之后客户端A解锁，在执行jedis.del()之前，锁突然过期了，此时客户端B尝试加锁成功，然后客户端A再执行del()方法，则将客户端B的锁给解除了。  </p>
<p>方式2（redis+lua脚本实现）–推荐  </p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">public static boolean releaseLock(String lockKey, String requestId) &#123;</span><br><span class="line">String script = <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return</span></span><br><span class="line"><span class="string">redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">Object result = jedis.eval(script, Collections.singletonList(lockKey),</span><br><span class="line">Collections.singletonList(requestId));</span><br><span class="line">    <span class="keyword">if</span> (result.equals(<span class="number">1</span>L)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h4><p>单机<br>无法保证高可用<br>主–从<br>无法保证数据的强一致性，在主机宕机时会造成锁的重复获得。  </p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210813185301.png" alt="image-20210813185301017"></p>
<p>无法续租<br>超过expireTime后，不能继续使用  </p>
<h4 id="本质分析"><a href="#本质分析" class="headerlink" title="本质分析"></a>本质分析</h4><p>CAP模型分析<br>在分布式环境下不可能满足三者共存，只能满足其中的两者共存，在分布式下P不能舍弃(舍弃P就是单<br>机了)。<br>所以只能是CP（强一致性模型）和AP(高可用模型)。<br>分布式锁是CP模型，Redis集群是AP模型。 (base)<br>Redis集群不能保证数据的随时一致性，只能保证数据的最终一致性。<br>为什么还可以用Redis实现分布式锁？  </p>
<p>与业务有关<br>当业务不需要数据强一致性时，比如：社交场景，就可以使用Redis实现分布式锁<br>当业务必须要数据的强一致性，即不允许重复获得锁，比如金融场景（重复下单，重复转账）就不要使用<br>可以使用CP模型实现，比如：zookeeper和etcd。  </p>
<h3 id="分布式锁特性"><a href="#分布式锁特性" class="headerlink" title="分布式锁特性"></a>分布式锁特性</h3><ul>
<li>互斥性<br>  任意时刻，只能有一个客户端获取锁，不能同时有两个客户端获取到锁。</li>
<li>同一性<br>  锁只能被持有该锁的客户端删除，不能由其它客户端删除。</li>
<li>可重入性<br>  持有某个锁的客户端可继续对该锁加锁，实现锁的续租</li>
<li>容错性<br>  锁失效后（超过生命周期）自动释放锁（key失效），其他客户端可以继续获得该锁，防止死锁  </li>
</ul>
<h3 id="分布式锁的实际应用"><a href="#分布式锁的实际应用" class="headerlink" title="分布式锁的实际应用"></a>分布式锁的实际应用</h3><p>数据并发竞争<br>利用分布式锁可以将处理串行化，前面已经讲过了。<br>防止库存超卖  </p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210813185548.png" alt="image-20210813185548268"></p>
<p>订单1下单前会先查看库存，库存为10，所以下单5本可以成功；<br>订单2下单前会先查看库存，库存为10，所以下单8本可以成功；<br>订单1和订单2 同时操作，共下单13本，但库存只有10本，显然库存不够了，这种情况称为库存超卖。<br>可以采用分布式锁解决这个问题。  </p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210813185604.png" alt="image-20210813185604783"></p>
<p>订单1和订单2都从Redis中获得分布式锁(setnx)，谁能获得锁谁进行下单操作，这样就把订单系统下单的顺序串行化了，就不会出现超卖的情况了。伪码如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加锁并设置有效期</span></span><br><span class="line"><span class="keyword">if</span>(redis.lock(<span class="string">&quot;RDL&quot;</span>,<span class="number">200</span>))&#123;</span><br><span class="line">    <span class="comment">//判断库存</span></span><br><span class="line">    <span class="keyword">if</span> (orderNum&lt;getCount())&#123;</span><br><span class="line">        <span class="comment">//加锁成功 ,可以下单</span></span><br><span class="line">        order(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        redis,unlock(<span class="string">&quot;RDL&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意此种方法会降低处理效率，这样不适合秒杀的场景，秒杀可以使用CAS和Redis队列的方式。  </p>
<h3 id="Zookeeper分布式锁的对比"><a href="#Zookeeper分布式锁的对比" class="headerlink" title="Zookeeper分布式锁的对比"></a>Zookeeper分布式锁的对比</h3><ul>
<li>基于Redis的set实现分布式锁</li>
<li>基于zookeeper临时节点的分布式锁  </li>
</ul>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210813185716.png" alt="image-20210813185715898"></p>
<p>基于etcd实现<br>三者的对比，如下表  </p>
<table>
<thead>
<tr>
<th>Redis</th>
<th>zookeeper</th>
<th>etcd</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>一致性算法</td>
<td>无</td>
<td>paxos（ZAB）</td>
<td>raft</td>
</tr>
<tr>
<td>CAP</td>
<td>AP</td>
<td>CP</td>
<td>CP</td>
</tr>
<tr>
<td>高可用</td>
<td>主从集群</td>
<td>n+1 （n至少为2）</td>
<td>n+1</td>
</tr>
<tr>
<td>接口类型</td>
<td>客户端</td>
<td>客户端</td>
<td>http/grpc</td>
</tr>
<tr>
<td>实现</td>
<td>setNX</td>
<td>createEphemeral</td>
<td>restful API</td>
</tr>
</tbody></table>
<h2 id="分布式集群架构中的session分离"><a href="#分布式集群架构中的session分离" class="headerlink" title="分布式集群架构中的session分离"></a>分布式集群架构中的session分离</h2><p>传统的session是由tomcat自己进行维护和管理，但是对于集群或分布式环境，不同的tomcat管理各自<br>的session，很难进行session共享，通过传统的模式进行session共享，会造成session对象在各个<br>tomcat之间，通过网络和Io进行复制，极大的影响了系统的性能。<br>可以将登录成功后的Session信息，存放在Redis中，这样多个服务器(Tomcat)可以共享Session信息。<br>利用spring-session-data-redis（SpringSession），可以实现基于redis来实现的session分离。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小肥龙吃大冰淇淋</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://andice-cream.github.io/post/b37f97dc.html">https://andice-cream.github.io/post/b37f97dc.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://andice-cream.github.io" target="_blank">小肥龙吃大冰淇淋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post_share"><div class="social-share" data-image="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165213.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/191eb6da.html"><img class="prev-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165215.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">设计模式-策略模式</div></div></a></div><div class="next-post pull-right"><a href="/post/d68a7f61.html"><img class="next-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165209.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redis大厂面试汇总</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/f345cc71.html" title="Redis-数据类型与底层数据结构"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165241.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-13</div><div class="title">Redis-数据类型与底层数据结构</div></div></a></div><div><a href="/post/e34f1f32.html" title="Redis-高可用"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165211.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-13</div><div class="title">Redis-高可用</div></div></a></div><div><a href="/post/d68a7f61.html" title="Redis大厂面试汇总"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165209.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-13</div><div class="title">Redis大厂面试汇总</div></div></a></div><div><a href="/post/8a1c1c9f.html" title="Redis扩展功能"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165212.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-13</div><div class="title">Redis扩展功能</div></div></a></div><div><a href="/post/119ed1dc.html" title="Redis持久化"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212104.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-13</div><div class="title">Redis持久化</div></div></a></div><div><a href="/post/bae4ff13.html" title="Redis"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082249.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-08</div><div class="title">Redis</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98"><span class="toc-number">1.</span> <span class="toc-text">企业实战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.1.</span> <span class="toc-text">架构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%80%89%E6%8B%A9-%E5%A4%9A%E7%BA%A7"><span class="toc-number">1.1.1.</span> <span class="toc-text">组件选择&#x2F;多级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM%E7%BC%93%E5%AD%98"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">JVM缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BC%93%E5%AD%98"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">文件缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E7%BC%93%E5%AD%98"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">Redis缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.1.2.</span> <span class="toc-text">缓存大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#key%E6%95%B0%E9%87%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text">key数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%B3%B0%E5%80%BC"><span class="toc-number">1.1.4.</span> <span class="toc-text">读写峰值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%B8%AD%E7%8E%87"><span class="toc-number">1.1.5.</span> <span class="toc-text">命中率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="toc-number">1.1.6.</span> <span class="toc-text">过期策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87"><span class="toc-number">1.1.7.</span> <span class="toc-text">性能监控指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="toc-number">1.1.8.</span> <span class="toc-text">缓存预热</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.</span> <span class="toc-text">缓存问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">1.2.2.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">1.2.3.</span> <span class="toc-text">缓存击穿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="toc-number">1.2.4.</span> <span class="toc-text">数据不一致</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%8F%91%E7%AB%9E%E4%BA%89"><span class="toc-number">1.2.5.</span> <span class="toc-text">数据并发竞争</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hot-Key"><span class="toc-number">1.2.6.</span> <span class="toc-text">Hot Key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Big-Key"><span class="toc-number">1.2.7.</span> <span class="toc-text">Big Key</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">1.3.</span> <span class="toc-text">缓存与数据库一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">1.3.1.</span> <span class="toc-text">缓存更新策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%AD%96%E7%95%A5%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.3.2.</span> <span class="toc-text">不同策略之间的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8EMybatis%E6%95%B4%E5%90%88"><span class="toc-number">1.3.3.</span> <span class="toc-text">与Mybatis整合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">1.4.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#watch"><span class="toc-number">1.4.1.</span> <span class="toc-text">watch</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8Watch%E5%AE%9E%E7%8E%B0Redis%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">利用Watch实现Redis乐观锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setnx"><span class="toc-number">1.4.2.</span> <span class="toc-text">setnx</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">存在问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E8%B4%A8%E5%88%86%E6%9E%90"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">本质分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%89%B9%E6%80%A7"><span class="toc-number">1.4.3.</span> <span class="toc-text">分布式锁特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="toc-number">1.4.4.</span> <span class="toc-text">分布式锁的实际应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.4.5.</span> <span class="toc-text">Zookeeper分布式锁的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84%E4%B8%AD%E7%9A%84session%E5%88%86%E7%A6%BB"><span class="toc-number">1.5.</span> <span class="toc-text">分布式集群架构中的session分离</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 小肥龙吃大冰淇淋</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="framework-info"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202301132049386.png"/><span> </span><a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">晋ICP备2022012091号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'pinglun-9gh2lmcnd8587831',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'pinglun-9gh2lmcnd8587831',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@latest/source/js/issues.min.js"></script><script src="//code.tidio.co/smwivpnwumemac2wohardi3d3gpud1ag.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>