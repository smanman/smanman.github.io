<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>集合面试题 | 小肥龙吃大冰淇淋</title><meta name="keywords" content="面试题"><meta name="author" content="小肥龙吃大冰淇淋"><meta name="copyright" content="小肥龙吃大冰淇淋"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="ArrayList和LinkedList有什么区别？首先，他们的底层数据结构不同，ArrayList底层是基于数组实现的，LinkedList底层是基于链表实现的由于底层数据结构不同，他们所适用的场景也不同，ArrayList更适合随机查找，LinkedList更适合删除和添加，查询、添加、删除的时间复杂度不同另外ArrayList和LinkedList都实现了List接口，但是LinkedLis">
<meta property="og:type" content="article">
<meta property="og:title" content="集合面试题">
<meta property="og:url" content="http://lvxueyang.vip/post/4f9185fb.html">
<meta property="og:site_name" content="小肥龙吃大冰淇淋">
<meta property="og:description" content="ArrayList和LinkedList有什么区别？首先，他们的底层数据结构不同，ArrayList底层是基于数组实现的，LinkedList底层是基于链表实现的由于底层数据结构不同，他们所适用的场景也不同，ArrayList更适合随机查找，LinkedList更适合删除和添加，查询、添加、删除的时间复杂度不同另外ArrayList和LinkedList都实现了List接口，但是LinkedLis">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/bg.jpg">
<meta property="article:published_time" content="2021-08-17T13:28:00.000Z">
<meta property="article:modified_time" content="2022-11-27T09:16:47.974Z">
<meta property="article:author" content="小肥龙吃大冰淇淋">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/bg.jpg"><link rel="shortcut icon" href="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210805191028.png"><link rel="canonical" href="http://lvxueyang.vip/post/4f9185fb"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '集合面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-27 17:16:47'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/ali_icon.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mogai.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="小肥龙吃大冰淇淋" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">303</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">108</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">73</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/bg.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小肥龙吃大冰淇淋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">集合面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-17T13:28:00.000Z" title="发表于 2021-08-17 21:28:00">2021-08-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-27T09:16:47.974Z" title="更新于 2022-11-27 17:16:47">2022-11-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">50.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>191分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="集合面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="ArrayList和LinkedList有什么区别？"><a href="#ArrayList和LinkedList有什么区别？" class="headerlink" title="ArrayList和LinkedList有什么区别？"></a>ArrayList和LinkedList有什么区别？</h2><p>首先，他们的底层数据结构不同，ArrayList底层是基于数组实现的，LinkedList底层是基于链表实现的<br>由于底层数据结构不同，他们所适用的场景也不同，ArrayList更适合随机查找，LinkedList更适合删除和添加，查询、添加、删除的时间复杂度不同<br>另外ArrayList和LinkedList都实现了List接口，但是LinkedList还额外实现了Deque接口，所以LinkedList还可以当做队列来使用。</p>
<h2 id="ArrayList的sublist修改是否影响list本身？"><a href="#ArrayList的sublist修改是否影响list本身？" class="headerlink" title="ArrayList的sublist修改是否影响list本身？"></a>ArrayList的sublist修改是否影响list本身？</h2><p>方法实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fromIndex: 集合开始的索引，toIndex:集合结束的索引，左开右闭</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex， <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 边界校验</span></span><br><span class="line">	subListRangeCheck(fromIndex， toIndex， size);</span><br><span class="line">	<span class="comment">// subList 返回是一个视图</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> SubList(<span class="keyword">this</span>， <span class="number">0</span>， fromIndex， toIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ArrayList 的内部类，这个类中单独定义了 set、get、size、add、remove 等方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SubList</span> <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AbstractList&lt;E&gt; parent; <span class="comment">// parent的具体实现类是 ArrayList</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parentOffset;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line">	SubList(AbstractList&lt;E&gt; parent，<span class="keyword">int</span> offset， <span class="keyword">int</span> fromIndex， <span class="keyword">int</span> toIndex) &#123;</span><br><span class="line">		<span class="keyword">this</span>.parent = parent;</span><br><span class="line">		<span class="keyword">this</span>.parentOffset = fromIndex;</span><br><span class="line">		<span class="keyword">this</span>.offset = offset + fromIndex;</span><br><span class="line">		<span class="keyword">this</span>.size = toIndex - fromIndex;</span><br><span class="line">		<span class="keyword">this</span>.modCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">          rangeCheck(index);</span><br><span class="line">          checkForComodification();</span><br><span class="line">          E oldValue = ArrayList.<span class="keyword">this</span>.elementData(offset + index);</span><br><span class="line">          ArrayList.<span class="keyword">this</span>.elementData[offset + index] = e;</span><br><span class="line">          <span class="keyword">return</span> oldValue;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">          rangeCheck(index);</span><br><span class="line">          checkForComodification();</span><br><span class="line">          <span class="keyword">return</span> ArrayList.<span class="keyword">this</span>.elementData(offset + index);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          checkForComodification();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">          rangeCheckForAdd(index);</span><br><span class="line">          checkForComodification();</span><br><span class="line">		<span class="comment">// 添加直接调用父类的添加元素的方法</span></span><br><span class="line">          parent.add(parentOffset + index, e);</span><br><span class="line">		<span class="comment">// subList 添加的元素后，会同步父集合的modCount 修改到 subList的modCount，</span></span><br><span class="line">          <span class="keyword">this</span>.modCount = parent.modCount;</span><br><span class="line">          <span class="keyword">this</span>.size++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">          rangeCheck(index);</span><br><span class="line">          checkForComodification();</span><br><span class="line">          E result = parent.remove(parentOffset + index);</span><br><span class="line">          <span class="keyword">this</span>.modCount = parent.modCount;</span><br><span class="line">          <span class="keyword">this</span>.size--;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (ArrayList.<span class="keyword">this</span>.modCount != <span class="keyword">this</span>.modCount)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>subList 可以做集合的任何操作</p>
</li>
<li><p>调用该方法后的生成的新的集合的操作都会对原集合有影响，在subList集合后面添加元素，添加的第一个元素的位置就是上述toIndex的值，而原始集合中toIndex的元素往后移动。其add方法调用过程：</p>
<p>  <code>add(element) --&gt; AbstractList.add(e) --&gt; SubList.add(index， e) --&gt; parent.add(index + parentOffset， e) --&gt; ArrayList.add(newIndex， e)</code></p>
</li>
<li><p>List 的 subList 方法并没有创建一个新的 List，而是使用了 原 List 的视图，这个视图使用内部类 SubList 表示；不能把 subList 方法返回的 List 强制转换成 ArrayList 等类，因为他 们之间没有继承关系；</p>
</li>
</ul>
<p>视图和原 List 的修改还需要注意几点，尤其是他们之间的相互影响：</p>
<ul>
<li>对 父 (sourceList) 子 (subList)List 做 的 非 结 构 性 修 改(non-structural changes)，都会影响到彼此；</li>
<li>对<code>子List</code> 做结构性修改，操作同样会反映到<code>父List</code> 上；子List的 add 是直接调用父集合的add方法来添加的元素的：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">	rangeCheckForAdd(index);</span><br><span class="line">	checkForComodification();</span><br><span class="line">	parent.add(parentOffset + index, e);</span><br><span class="line">	<span class="keyword">this</span>.modCount = parent.modCount;</span><br><span class="line">	<span class="keyword">this</span>.size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对<code>父List</code> 做结构性修改（增加、删除），均会导致<code>子List</code>的遍历、增加、删除抛出异常 ConcurrentModificationException；因为其迭代的时候会对比<code>父List的modCount</code>和<code>子集合的modCount</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ArrayList.this.modCount 表示父List的 modCount，this.modCount表示 子List的modCount</span></span><br><span class="line">	<span class="keyword">if</span> (ArrayList.<span class="keyword">this</span>.modCount != <span class="keyword">this</span>.modCount)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SynchronizedList、Vector有什么区别"><a href="#SynchronizedList、Vector有什么区别" class="headerlink" title="SynchronizedList、Vector有什么区别?"></a>SynchronizedList、Vector有什么区别?</h2><ul>
<li>SynchronizedList 是java.util.Collections的静态内部类；Vector是java.util包中的一个类；</li>
<li>使用add方法时，扩容机制不一样；</li>
<li>SynchronizedList有很好的扩展和兼容功能，可以将所有的List的子类转成线程安全的类；</li>
<li>使用SynchronizedList的时候，进行遍历时需要手动进行同步处理；</li>
<li>SynchronizedList可以指定锁的对象</li>
</ul>
<h2 id="Arrays-asList-T…args-获得的List特点"><a href="#Arrays-asList-T…args-获得的List特点" class="headerlink" title="Arrays.asList(T…args)获得的List特点?"></a>Arrays.asList(T…args)获得的List特点?</h2><ul>
<li>其返回的List是Arrays的一个内部类，是原来数组的视图，不支持增删操作；</li>
<li>如果需要对其进行操作的话，可以通过ArrayList的构造器将其转为ArrayList；</li>
</ul>
<h2 id="Iterator和ListIterator区别"><a href="#Iterator和ListIterator区别" class="headerlink" title="Iterator和ListIterator区别?"></a>Iterator和ListIterator区别?</h2><ul>
<li>都是用于遍历集合的，Iterator可以用于遍历Set、List；ListIterator只可用于List；</li>
<li>ListIterator实现的Iterator接口；</li>
<li>ListIterator可向前和向后遍历；Iterator只可向后遍历；</li>
</ul>
<h2 id="ArrayList是怎么扩容的？"><a href="#ArrayList是怎么扩容的？" class="headerlink" title="ArrayList是怎么扩容的？"></a>ArrayList是怎么扩容的？</h2><p>ArrayList内部使用数组存储元素，当数组长度不够时进行扩容，每次加一半的空间，ArrayList不会进行缩容；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="comment">// 新容量为旧容量的1.5倍</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 如果新容量发现比需要的容量还小，则以需要的容量为准</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">// 如果新容量已经超过最大容量了，则使用最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// 以新容量拷贝出来一个新数组</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ArrayList插入、删除、查询元素的时间复杂度各是多少？"><a href="#ArrayList插入、删除、查询元素的时间复杂度各是多少？" class="headerlink" title="ArrayList插入、删除、查询元素的时间复杂度各是多少？"></a>ArrayList插入、删除、查询元素的时间复杂度各是多少？</h2><p>ArrayList支持随机访问，通过索引访问元素极快，时间复杂度为O(1)；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查是否越界</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        <span class="comment">// 返回数组index位置的元素</span></span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果根据比较对象的话时间复杂度就是O(n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList添加元素到尾部极快，平均时间复杂度为O(1)；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查是否需要扩容</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">// 把元素插入到最后一位</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList添加元素到中间比较慢，因为要搬移元素，平均时间复杂度为O(n)；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查是否越界</span></span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        <span class="comment">// 检查是否需要扩容</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">// 将index及其之后的元素往后挪一位，则index位置处就空出来了</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">        <span class="comment">// 将元素插入到index的位置</span></span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="comment">// 大小加</span></span><br><span class="line">        size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList从尾部删除元素极快，时间复杂度为O(1)；</p>
<p>ArrayList从中间删除元素比较慢，因为要搬移元素，平均时间复杂度为O(n)；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历整个数组，找到元素第一次出现的位置，并将其快速删除</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="comment">// 如果要删除的元素为null，则以null进行比较，使用==</span></span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历整个数组，找到元素第一次出现的位置，并将其快速删除</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="comment">// 如果要删除的元素不为null，则进行比较，使用equals()方法</span></span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 少了一个越界的检查</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">// 如果index不是最后一位，则将index之后的元素往前挪一位</span></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        <span class="comment">// 将最后一个元素删除，帮助GC</span></span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="怎么求两个集合的并集、交集、差集？"><a href="#怎么求两个集合的并集、交集、差集？" class="headerlink" title="怎么求两个集合的并集、交集、差集？"></a>怎么求两个集合的并集、交集、差集？</h2><p>ArrayList支持求并集，调用addAll(Collection&lt;? extends E&gt; c)方法即可；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将集合c转为数组</span></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        <span class="comment">// 检查是否需要扩容</span></span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">        <span class="comment">// 将c中元素全部拷贝到数组的最后</span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">        <span class="comment">// 大小增加c的大小</span></span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="comment">// 如果c不为空就返回true，否则返回false</span></span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList支持求交集，调用retainAll(Collection&lt;? extends E&gt; c)方法即可；<br>ArrayList支持求单向差集，调用removeAll(Collection&lt;? extends E&gt; c)方法即可；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量删除元素</span></span><br><span class="line"><span class="comment">     * complement为true表示删除c中不包含的元素</span></span><br><span class="line"><span class="comment">     * complement为false表示删除c中包含的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="comment">// 使用读写两个指针同时遍历数组</span></span><br><span class="line">        <span class="comment">// 读指针每次自增1，写指针放入元素的时候才加1</span></span><br><span class="line">        <span class="comment">// 这样不需要额外的空间，只需要在原有的数组上操作就可以了</span></span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历整个数组，如果c中包含该元素，则把该元素放到写指针的位置（以complement为准）</span></span><br><span class="line">            <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">                <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                    elementData[w++] = elementData[r];</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 正常来说r最后是等于size的，除非c.contains()抛出了异常</span></span><br><span class="line">            <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">                System.arraycopy(elementData, r,</span><br><span class="line">                                 elementData, w,</span><br><span class="line">                                 size - r);</span><br><span class="line">                w += size - r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 原有的:a:1 3 4</span></span><br><span class="line"><span class="comment">             * 比较的:b:1 3 2</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">                <span class="comment">// 将写指针之后的元素置为空，帮助GC</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">                    elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">                modCount += size - w;</span><br><span class="line">                <span class="comment">// 新大小等于写指针的位置（因为每写一次写指针就加1，所以新大小正好等于写指针的位置）</span></span><br><span class="line">                size = w;</span><br><span class="line">                modified = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ArrayList是怎么实现序列化和反序列化的？"><a href="#ArrayList是怎么实现序列化和反序列化的？" class="headerlink" title="ArrayList是怎么实现序列化和反序列化的？"></a>ArrayList是怎么实现序列化和反序列化的？</h2><p>序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">       <span class="comment">// 防止序列化期间被修改</span></span><br><span class="line">       <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">       <span class="comment">// 写出非transient非static属性（会写出size属性）</span></span><br><span class="line">       s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 写出元素个数</span></span><br><span class="line">       s.writeInt(size);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 依次写出元素</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">           s.writeObject(elementData[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果有修改，抛出异常</span></span><br><span class="line">       <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>反序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">       <span class="comment">// 声明为空数组</span></span><br><span class="line">       elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 读入非transient非static属性（会读取size属性）</span></span><br><span class="line">       s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 读入元素个数，没什么用，只是因为写出的时候写了size属性，读的时候也要按顺序来读</span></span><br><span class="line">       s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 计算容量</span></span><br><span class="line">           ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">           Object[] a = elementData;</span><br><span class="line">           <span class="comment">//  // 依次读取元素到数组中</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">               a[i] = s.readObject();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>查看writeObject()方法可知，先调用s.defaultWriteObject()方法，再把size写入到流中，再把元素一个一个的写入到流中。</p>
<p>一般地，只要实现了Serializable接口即可自动序列化，writeObject()和readObject()是为了自己控制序列化的方式，这两个方法必须声明为private，在java.io.ObjectStreamClass#getPrivateMethod()方法中通过反射获取到writeObject()这个方法。</p>
<p>在ArrayList的writeObject()方法中先调用了s.defaultWriteObject()方法，这个方法是写入非static非transient的属性，在ArrayList中也就是size属性。同样地，在readObject()方法中先调用了s.defaultReadObject()方法解析出了size属性。</p>
<p>elementData定义为transient的优势，自己根据size序列化真实的元素，而不是根据数组的长度序列化元素，减少了空间占用。</p>
<h2 id="集合的方法toArray-有什么问题？"><a href="#集合的方法toArray-有什么问题？" class="headerlink" title="集合的方法toArray()有什么问题？"></a>集合的方法toArray()有什么问题？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           Father[] fathers = <span class="keyword">new</span> Son[]&#123;&#125;;</span><br><span class="line">           <span class="comment">// 打印结果为class [Lcom.coolcoding.code.Son;</span></span><br><span class="line">           System.out.println(fathers.getClass());</span><br><span class="line">   </span><br><span class="line">           List&lt;String&gt; strList = <span class="keyword">new</span> MyList();</span><br><span class="line">           <span class="comment">// 打印结果为class [Ljava.lang.String;</span></span><br><span class="line">           System.out.println(strList.toArray().getClass());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;&#125;</span><br><span class="line">   </span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;&#125;</span><br><span class="line">   </span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">MyList</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 子类重写父类的方法，返回值可以不一样</span></span><br><span class="line"><span class="comment">        * 但这里只能用数组类型，换成Object就不行</span></span><br><span class="line"><span class="comment">        * 应该算是java本身的bug</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> String[] toArray() &#123;</span><br><span class="line">           <span class="comment">// 为了方便举例直接写死</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<h2 id="什么是fail-fast？"><a href="#什么是fail-fast？" class="headerlink" title="什么是fail-fast？"></a>什么是fail-fast？</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>“快速失败”也就是fail-fast，它是Java集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。记住是有可能，而不是一定。例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailFastTest</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">threadOne</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">                <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">                    <span class="keyword">int</span> i = iterator.next();</span><br><span class="line">                    System.out.println(<span class="string">&quot;ThreadOne 遍历:&quot;</span> + i);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">      </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">threadTwo</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; <span class="number">6</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;ThreadTwo run：&quot;</span> + i);</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">3</span>)&#123;</span><br><span class="line">                        list.remove(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">new</span> threadOne().start();</span><br><span class="line">            <span class="keyword">new</span> threadTwo().start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210817152045.png" alt="image-20210817152038167"></p>
<p>通过上面的示例和讲解，我初步知道fail-fast产生的原因就在于程序在对 collection 进行迭代时，某个线程对该 collection 在结构上对其做了修改，这时迭代器就会抛出 ConcurrentModificationException 异常信息，从而产生 fail-fast。</p>
<p>要了解fail-fast机制，我们首先要对ConcurrentModificationException 异常有所了解。当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常。同时需要注意的是，该异常不会始终指出对象已经由不同线程并发修改，如果单线程违反了规则，同样也有可能会抛出改异常。</p>
<p>诚然，迭代器的快速失败行为无法得到保证，它不能保证一定会出现该错误，但是快速失败操作会尽最大努力抛出ConcurrentModificationException异常，所以因此，为提高此类操作的正确性而编写一个依赖于此异常的程序是错误的做法，正确做法是：ConcurrentModificationException 应该仅用于检测 bug。下面我将以ArrayList为例进一步分析fail-fast产生的原因。</p>
<h3 id="fail-fast解决办法"><a href="#fail-fast解决办法" class="headerlink" title="fail-fast解决办法"></a>fail-fast解决办法</h3><ul>
<li><strong>方案一：</strong> 在遍历过程中所有涉及到改变modCount值得地方全部加上synchronized或者直接使用Collections.synchronizedList，这样就可以解决。但是不推荐，因为增删造成的同步锁可能会阻塞遍历操作。</li>
<li><strong>方案二：</strong> 使用CopyOnWriteArrayList来替换ArrayList。推荐使用该方案。</li>
</ul>
<h2 id="LinkedList是单链表还是双链表实现的？"><a href="#LinkedList是单链表还是双链表实现的？" class="headerlink" title="LinkedList是单链表还是双链表实现的？"></a>LinkedList是单链表还是双链表实现的？</h2><p>LinkedList是一个以双链表实现的List；</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210817152520.png" alt="image-20210817152520441"></p>
<h2 id="LinkedList除了作为List还有什么用处？"><a href="#LinkedList除了作为List还有什么用处？" class="headerlink" title="LinkedList除了作为List还有什么用处？"></a>LinkedList除了作为List还有什么用处？</h2><p>LinkedList还是一个双端队列，具有队列、双端队列、栈的特性；</p>
<p>看一下它继承了哪些接口</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210817152719.png" alt="image-20210817152719416"></p>
<h2 id="LinkedList插入、删除、查询元素的时间复杂度各是多少？"><a href="#LinkedList插入、删除、查询元素的时间复杂度各是多少？" class="headerlink" title="LinkedList插入、删除、查询元素的时间复杂度各是多少？"></a>LinkedList插入、删除、查询元素的时间复杂度各是多少？</h2><p>LinkedList在队列首尾添加、删除元素非常高效，时间复杂度为O(1)；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从队列首添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从队列首添加元素</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="comment">// 创建新节点，新节点的next是首节点</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">        <span class="comment">// 让新节点作为新的首节点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">        <span class="comment">// 判断是不是第一个添加的元素</span></span><br><span class="line">        <span class="comment">// 如果是就把last也置为新节点</span></span><br><span class="line">        <span class="comment">// 否则把原首节点的prev指针置为新节点</span></span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            last = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f.prev = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从队尾添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 队列尾节点</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="comment">// 创建新节点，新节点的prev是尾节点</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 让新节点成为新的尾节点</span></span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="comment">// 判断是不是第一个添加的元素</span></span><br><span class="line">        <span class="comment">// 如果是就把first也置为新节点</span></span><br><span class="line">        <span class="comment">// 否则把原尾节点的next指针置为新节点</span></span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 删除首节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首节点的元素值</span></span><br><span class="line">        <span class="keyword">final</span> E element = f.item;</span><br><span class="line">        <span class="comment">// 首节点的next指针</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">        <span class="comment">// 添加首节点的内容，协助GC</span></span><br><span class="line">        f.item = <span class="keyword">null</span>;</span><br><span class="line">        f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        <span class="comment">// 把首节点的next作为新的首节点</span></span><br><span class="line">        first = next;</span><br><span class="line">        <span class="comment">// 如果只有一个元素，删除了，把last也置为空</span></span><br><span class="line">        <span class="comment">// 否则把next的前置指针置为空</span></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">            last = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            next.prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 元素个数减1</span></span><br><span class="line">        size--;</span><br><span class="line">        <span class="comment">// 修改次数加1</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">// 返回删除的元素</span></span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除尾节点</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 尾节点的元素值</span></span><br><span class="line">        <span class="keyword">final</span> E element = l.item;</span><br><span class="line">        <span class="comment">// 尾节点的前置指针</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">        <span class="comment">// 清空尾节点的内容，协助GC</span></span><br><span class="line">        l.item = <span class="keyword">null</span>;</span><br><span class="line">        l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        <span class="comment">// 让前置节点成为新的尾节点</span></span><br><span class="line">        last = prev;</span><br><span class="line">        <span class="comment">// 如果只有一个元素，删除了把first置为空</span></span><br><span class="line">        <span class="comment">// 否则把前置节点的next置为空</span></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">            first = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            prev.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 元素个数减1</span></span><br><span class="line">        size--;</span><br><span class="line">        <span class="comment">// 修改次数加1</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">// 返回删除的元素</span></span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedList在中间添加、删除元素比较低效，时间复杂度为O(n)；</p>
<p>中间添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在节点succ之前添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// succ是待添加节点的后继节点</span></span><br><span class="line">        <span class="comment">// 找到待添加节点的前置节点</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">        <span class="comment">// 在其前置节点和后继节点之间创建一个新节点</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">        <span class="comment">// 修改后继节点的前置指针指向新节点</span></span><br><span class="line">        succ.prev = newNode;</span><br><span class="line">        <span class="comment">// 判断前置节点是否为空</span></span><br><span class="line">        <span class="comment">// 如果为空，说明是第一个添加的元素，修改first指针</span></span><br><span class="line">        <span class="comment">// 否则修改前置节点的next为新节点</span></span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        <span class="comment">// 修改元素个数</span></span><br><span class="line">        size++;</span><br><span class="line">        <span class="comment">// 修改次数加1</span></span><br><span class="line">        modCount++;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 寻找index位置的节点</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为是双链表</span></span><br><span class="line">        <span class="comment">// 所以根据index是在前半段还是后半段决定从前遍历还是从后遍历</span></span><br><span class="line">        <span class="comment">// 这样index在后半段的时候可以少遍历一半的元素</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果是在前半段</span></span><br><span class="line">            <span class="comment">// 就从前遍历</span></span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是在后半段</span></span><br><span class="line">            <span class="comment">// 就从后遍历</span></span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 在指定index位置处添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否越界</span></span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line">        <span class="comment">// 如果index是在队列尾节点之后的一个位置</span></span><br><span class="line">        <span class="comment">// 把新节点直接添加到尾节点之后</span></span><br><span class="line">        <span class="comment">// 否则调用linkBefore()方法在中间添加节点</span></span><br><span class="line">        <span class="keyword">if</span> (index == size)</span><br><span class="line">            linkLast(element);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在中间删除或者删除指定节点x</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除指定节点x</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// x的元素值</span></span><br><span class="line">        <span class="keyword">final</span> E element = x.item;</span><br><span class="line">        <span class="comment">// x的前置节点</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">        <span class="comment">// x的后置节点</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果前置节点为空</span></span><br><span class="line">        <span class="comment">// 说明是首节点，让first指向x的后置节点</span></span><br><span class="line">        <span class="comment">// 否则修改前置节点的next为x的后置节点</span></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            x.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果后置节点为空</span></span><br><span class="line">        <span class="comment">// 说明是尾节点，让last指向x的前置节点</span></span><br><span class="line">        <span class="comment">// 否则修改后置节点的prev为x的前置节点</span></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            x.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空x的元素值，协助GC</span></span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 元素个数减1</span></span><br><span class="line">        size--;</span><br><span class="line">        <span class="comment">// 修改次数加1</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">// 返回删除的元素</span></span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove的时候如果没有元素抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove的时候如果没有元素抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// poll的时候如果没有元素返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// poll的时候如果没有元素返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除中间节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查是否越界</span></span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="comment">// 删除指定index位置的节点</span></span><br><span class="line">        <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="什么是随机访问？"><a href="#什么是随机访问？" class="headerlink" title="什么是随机访问？"></a>什么是随机访问？</h2><p>java集合类中元素的访问分为随机访问和顺序访问。随机访问一般是通过index下标访问，行为类似数组的访问。而顺序访问类似于链表的访问，通常为迭代器遍历。<br>以List接口及其实例为例。ArrayList是典型的随机访问型，而LinkedList则是顺序访问型。List接口既定义了下标访问方法又定义了迭代器方法。所以其实例既可使用下标随机访问也可以使用迭代器进行遍历。但这两种方式的性能差异很明显。</p>
<p>随机访问是说你可以随意访问该数据结构中的任意一个节点，假设该数据结构有10个节点，你可以随意访问第1个到第10个节点。<br>对于列表而言，如果其存在10个节点，如果你要访问第5个节点，你只能从列表的头或者尾，依次遍历相邻的每一个节点；</p>
<h4 id="RandomAccess接口"><a href="#RandomAccess接口" class="headerlink" title="RandomAccess接口"></a>RandomAccess接口</h4><p>JDK中的RandomAccess接口是一个标记接口，它并未定义方法。其目的是用于指示实现类具有随机访问特性，在遍历时使用下标访问较迭代器更快。如果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, n = list.size(); i &lt; n; i++)</span><br><span class="line">    list.get(i);</span><br></pre></td></tr></table></figure>

<p>的运行比</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Interator i = list.iterator();i.hasNext();)</span><br><span class="line">    i.next();</span><br></pre></td></tr></table></figure>

<p>快，则应实现RandomAccess接口。</p>
<h2 id="哪些集合支持随机访问？他们都有哪些共性？"><a href="#哪些集合支持随机访问？他们都有哪些共性？" class="headerlink" title="哪些集合支持随机访问？他们都有哪些共性？"></a>哪些集合支持随机访问？他们都有哪些共性？</h2><p>ArrayList、HashMap、TreeMap和HashTable类提供对元素的随机访问。</p>
<h2 id="CopyOnWriteArrayList是怎么保证并发安全的？"><a href="#CopyOnWriteArrayList是怎么保证并发安全的？" class="headerlink" title="CopyOnWriteArrayList是怎么保证并发安全的？"></a>CopyOnWriteArrayList是怎么保证并发安全的？</h2><p>CopyOnWriteArrayList使用ReentrantLock重入锁加锁，保证线程安全；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 用于修改时加锁 */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 真正存储元素的地方，只能通过getArray()/setArray()访问 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure>

<h2 id="CopyOnWriteArrayList的实现采用了什么思想？"><a href="#CopyOnWriteArrayList的实现采用了什么思想？" class="headerlink" title="CopyOnWriteArrayList的实现采用了什么思想？"></a>CopyOnWriteArrayList的实现采用了什么思想？</h2><p>CopyOnWriteArrayList采用读写分离的思想，读操作不加锁，写操作加锁，且写操作占用较大内存空间，所以适用于读多写少的场合；它不存在扩容的概念，每次写操作都要复制一个副本，在副本的基础上修改后改变Array引用。CopyOnWriteArrayList中写操作需要大面积复制数组，所以性能肯定很差。</p>
<h2 id="CopyOnWriteArrayList是不是强一致性的？"><a href="#CopyOnWriteArrayList是不是强一致性的？" class="headerlink" title="CopyOnWriteArrayList是不是强一致性的？"></a>CopyOnWriteArrayList是不是强一致性的？</h2><p>不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个set操作后，读取到数据可能还是旧的,虽然CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性一致性要求；</p>
<h2 id="CopyOnWriteArrayListaddIfAbsent-E-e-了解吗？"><a href="#CopyOnWriteArrayListaddIfAbsent-E-e-了解吗？" class="headerlink" title="CopyOnWriteArrayListaddIfAbsent(E e)了解吗？"></a>CopyOnWriteArrayListaddIfAbsent(E e)了解吗？</h2><p>添加一个元素如果这个元素不存在于集合中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addIfAbsent</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取元素数组, 取名为快照</span></span><br><span class="line">        Object[] snapshot = getArray();</span><br><span class="line">        <span class="comment">// 检查如果元素不存在,直接返回false</span></span><br><span class="line">        <span class="comment">// 如果存在再调用addIfAbsent()方法添加元素</span></span><br><span class="line">        <span class="keyword">return</span> indexOf(e, snapshot, <span class="number">0</span>, snapshot.length) &gt;= <span class="number">0</span> ? <span class="keyword">false</span> :</span><br><span class="line">            addIfAbsent(e, snapshot);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addIfAbsent</span><span class="params">(E e, Object[] snapshot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 重新获取旧数组</span></span><br><span class="line">            Object[] current = getArray();</span><br><span class="line">            <span class="keyword">int</span> len = current.length;</span><br><span class="line">            <span class="comment">// 如果快照与刚获取的数组不一致</span></span><br><span class="line">            <span class="comment">// 说明有修改</span></span><br><span class="line">            <span class="keyword">if</span> (snapshot != current) &#123;</span><br><span class="line">                <span class="comment">// 重新检查元素是否在刚获取的数组里</span></span><br><span class="line">                <span class="keyword">int</span> common = Math.min(snapshot.length, len);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; common; i++)</span><br><span class="line">                    <span class="comment">// 到这个方法里面了, 说明元素不在快照里面</span></span><br><span class="line">                    <span class="keyword">if</span> (current[i] != snapshot[i] &amp;&amp; eq(e, current[i]))</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (indexOf(e, current, common, len) &gt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 拷贝一份n+1的数组</span></span><br><span class="line">            Object[] newElements = Arrays.copyOf(current, len + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 将元素放在最后一位</span></span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>（1）检查这个元素是否存在于数组快照中；</p>
<p>（2）如果存在直接返回false，如果不存在调用addIfAbsent(E e, Object[] snapshot)处理;</p>
<p>（3）加锁；</p>
<p>（4）如果当前数组不等于传入的快照，说明有修改，检查待添加的元素是否存在于当前数组中，如果存在直接返回false;</p>
<p>（5）拷贝一个新数组，长度等于原数组长度加1，并把原数组元素拷贝到新数组中；</p>
<p>（6）把新元素添加到数组最后一位；</p>
<p>（7）把新数组赋值给当前对象的array属性，覆盖原数组；</p>
<p>（8）解锁；</p>
<h2 id="CopyOnWriteArrayList适用于什么样的场景？"><a href="#CopyOnWriteArrayList适用于什么样的场景？" class="headerlink" title="CopyOnWriteArrayList适用于什么样的场景？"></a>CopyOnWriteArrayList适用于什么样的场景？</h2><p>CopyOnWriteArrayList采用读写分离的思想，读操作不加锁，写操作加锁，且写操作占用较大内存空间，所以适用于读多写少的场合,比如缓存；不过这类慎用 ，因为谁也没法保证CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点多，每次add/set都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种操作分分钟引起故障。</p>
<h2 id="CopyOnWriteArrayList插入、删除、查询元素的时间复杂度各是多少？"><a href="#CopyOnWriteArrayList插入、删除、查询元素的时间复杂度各是多少？" class="headerlink" title="CopyOnWriteArrayList插入、删除、查询元素的时间复杂度各是多少？"></a>CopyOnWriteArrayList插入、删除、查询元素的时间复杂度各是多少？</h2><p>CopyOnWriteArrayList的写操作都要先拷贝一份新数组，在新数组中做修改，修改完了再用新数组替换老数组，所以空间复杂度是O(n)，性能比较低下；</p>
<p>CopyOnWriteArrayList的读操作支持随机访问，时间复杂度为O(1)；</p>
<p>添加一个元素到末尾。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取旧数组</span></span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            <span class="comment">// 将旧数组元素拷贝到新数组中</span></span><br><span class="line">            <span class="comment">// 新数组大小是旧数组大小加1</span></span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 将元素放在最后一位</span></span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加一个元素在指定索引处</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       <span class="comment">// 加锁</span></span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 获取旧数组</span></span><br><span class="line">           Object[] elements = getArray();</span><br><span class="line">           <span class="keyword">int</span> len = elements.length;</span><br><span class="line">           <span class="comment">// 检查是否越界, 可以等于len</span></span><br><span class="line">           <span class="keyword">if</span> (index &gt; len || index &lt; <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;Index: &quot;</span>+index+</span><br><span class="line">                                                   <span class="string">&quot;, Size: &quot;</span>+len);</span><br><span class="line">           Object[] newElements;</span><br><span class="line">           <span class="keyword">int</span> numMoved = len - index;</span><br><span class="line">           <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">               <span class="comment">// 如果插入的位置是最后一位</span></span><br><span class="line">               <span class="comment">// 那么拷贝一个n+1的数组, 其前n个元素与旧数组一致</span></span><br><span class="line">               newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 如果插入的位置不是最后一位</span></span><br><span class="line">               <span class="comment">// 那么新建一个n+1的数组</span></span><br><span class="line">               newElements = <span class="keyword">new</span> Object[len + <span class="number">1</span>];</span><br><span class="line">               <span class="comment">// 拷贝旧数组前index的元素到新数组中</span></span><br><span class="line">               System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">               <span class="comment">// 将index及其之后的元素往后挪一位拷贝到新数组中</span></span><br><span class="line">               <span class="comment">// 这样正好index位置是空出来的</span></span><br><span class="line">               System.arraycopy(elements, index, newElements, index + <span class="number">1</span>,</span><br><span class="line">                                numMoved);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 将元素放置在index处</span></span><br><span class="line">           newElements[index] = element;</span><br><span class="line">           setArray(newElements);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// 释放锁</span></span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p>删除指定索引位置的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       <span class="comment">// 加锁</span></span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 获取旧数组</span></span><br><span class="line">           Object[] elements = getArray();</span><br><span class="line">           <span class="keyword">int</span> len = elements.length;</span><br><span class="line">           E oldValue = get(elements, index);</span><br><span class="line">           <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">               <span class="comment">// 如果移除的是最后一位</span></span><br><span class="line">               <span class="comment">// 那么直接拷贝一份n-1的新数组, 最后一位就自动删除了</span></span><br><span class="line">               setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 如果移除的不是最后一位</span></span><br><span class="line">               <span class="comment">// 那么新建一个n-1的新数组</span></span><br><span class="line">               Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">               <span class="comment">// 将前index的元素拷贝到新数组中</span></span><br><span class="line">               System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">               <span class="comment">// 将index后面(不包含)的元素往前挪一位</span></span><br><span class="line">               <span class="comment">// 这样正好把index位置覆盖掉了, 相当于删除了</span></span><br><span class="line">               System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                                numMoved);</span><br><span class="line">               setArray(newElements);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> oldValue;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// 释放锁</span></span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>获取指定索引的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取元素不需要加锁</span></span><br><span class="line">        <span class="comment">// 直接返回index位置的元素</span></span><br><span class="line">        <span class="comment">// 这里是没有做越界检查的, 因为数组本身会做越界检查</span></span><br><span class="line">        <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CopyOnWriteArrayList为什么没有size属性？"><a href="#CopyOnWriteArrayList为什么没有size属性？" class="headerlink" title="CopyOnWriteArrayList为什么没有size属性？"></a>CopyOnWriteArrayList为什么没有size属性？</h2><p>因为每次修改都是拷贝一份正好可以存储目标个数元素的数组，所以不需要size属性了，数组的长度就是集合的大小，而不像ArrayList数组的长度实际是要大于集合的大小的。</p>
<p>比如，add(E e)操作，先拷贝一份n+1个元素的数组，再把新元素放到新数组的最后一位，这时新数组的长度为len+1了，也就是集合的size了。</p>
<h2 id="比较古老的集合Vector和Stack有什么缺陷？"><a href="#比较古老的集合Vector和Stack有什么缺陷？" class="headerlink" title="比较古老的集合Vector和Stack有什么缺陷？"></a>比较古老的集合Vector和Stack有什么缺陷？</h2><p>Vector：线程安全的动态数组</p>
<p>Stack：继承Vector，基于动态数组实现的一个线程安全的栈；</p>
<p>Vector与ArrayList基本是一致的，不同的是Vector是线程安全的，会在可能出现线程安全的方法前面加上synchronized关键字；</p>
<p>Vector：随机访问速度快，插入和移除性能较差(数组的特点)；支持null元素；有顺序；元素可以重复；线程安全；</p>
<p>Stack：后进先出，实现了一些栈基本操作的方法（其实并不是只能后进先出，因为继承自Vector，可以有很多操作，从某种意义上来讲，不是一个栈）；</p>
<p>所以基本上来说vector 因为线程安全的实现方法比较粗暴效率较低。</p>
<h2 id="什么是散列表？"><a href="#什么是散列表？" class="headerlink" title="什么是散列表？"></a>什么是散列表？</h2><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8/10027933">散列表</a>（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450">数据结构</a>。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/2366288">散列函数</a>，存放记录的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84/3794097">数组</a>叫做<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8/10027933">散列表</a>。</p>
<p>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。</p>
<p><strong>hash就是找到一种数据内容和数据存放地址之间的映射关系。</strong></p>
<h2 id="常见的散列函数"><a href="#常见的散列函数" class="headerlink" title="常见的散列函数?"></a>常见的散列函数?</h2><ul>
<li>直接定址法：直接以关键字k或者k加上某个常数(k+c)作为哈希地址；</li>
<li>数字分析法：提取关键字中取值比较均匀的数字作为哈希地址；</li>
<li>除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址；</li>
<li>分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址；</li>
<li>平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求去中间几位作为哈希表地址；</li>
<li>伪随机数法：采用一个伪随机数作为哈希函数</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://note.csdn.net/yyyljw/article/details/80903391">有兴趣的可以访问</a></p>
<h2 id="碰撞解决方案"><a href="#碰撞解决方案" class="headerlink" title="碰撞解决方案?"></a>碰撞解决方案?</h2><p>衡量一个哈希函数的好坏的重要指标就是发生碰撞的概率以及发生碰撞的解决方案。任何哈希函数基本无法彻底避免碰撞。</p>
<p>常见解决碰撞的方法有以下几种：</p>
<ul>
<li>开发定址法：就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入；</li>
<li>链地址法：将哈希表的每个单元作为链表的头结点，所有哈希地址为 i 的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表尾部；</li>
<li>再哈希法：当哈希地址发生冲突用其他的函数计算另一个哈希地址，直到冲突不在产生为止；</li>
<li>建立公共溢出区：将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。</li>
</ul>
<h2 id="怎么实现一个散列表？"><a href="#怎么实现一个散列表？" class="headerlink" title="怎么实现一个散列表？"></a>怎么实现一个散列表？</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1K54y147TB?p=211">推荐小码哥的恋上数据结构与算法</a></p>
<h2 id="java中HashMap实现方式的演进？"><a href="#java中HashMap实现方式的演进？" class="headerlink" title="java中HashMap实现方式的演进？"></a>java中HashMap实现方式的演进？</h2><p>JDK1.7中底层是数组+链表，JDK1.8中底层是数组+链表+红黑树，加红黑树的目的是提高HashMap插入和查询整体效率JDK1.7中链表插入使用的是头插法，1.8中链表插入使用的是尾插法，因为1.8中插入key和value时需要判断链表元素个数，所以需要遍历链表统计链表元素个数，所以正好就直接使用尾插法JDK1.7中哈希算法比较复杂，存在各种右移与异或运算，JDK1.8中进行了简化，因为复杂的哈希算法的目的就是提高散列性，来提供HashMap的整体效率，而1.8中新增了红黑树，所以可以适当的简化哈希算法，节省CPU资源。</p>
<h2 id="HashMap的容量有什么特点？"><a href="#HashMap的容量有什么特点？" class="headerlink" title="HashMap的容量有什么特点？"></a>HashMap的容量有什么特点？</h2><p>默认情况下，当我们设置HashMap的初始化容量时，实际上HashMap会采用第一个大于该数值的2的幂作为初始化容量。HashMap默认容量为16,每次超过阀值时，按照两倍大小进行自动扩容，所以容量总是 2^N 次方。并且，底层的 <code>table</code> 数组是延迟初始化，在首次添加 key-value 键值对才进行初始化。在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考<a href="https://link.zhihu.com/?target=http://note.csdn.net/liuqiyao_01/article/details/14475159">http://note.csdn.net/liuqiyao_01/article/details/14475159</a>，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。</p>
<h2 id="HashMap如何确定哈希桶数组索引位置？"><a href="#HashMap如何确定哈希桶数组索引位置？" class="headerlink" title="HashMap如何确定哈希桶数组索引位置？"></a>HashMap如何确定哈希桶数组索引位置？</h2><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line">方法二：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的Hash算法本质上就是三步：<strong>取key的hashCode值、高位运算、取模运算</strong>。</p>
<p>对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。</p>
<p>这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p>
<p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p>
<p>下面举例说明下，n为table的长度。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210817164145.png" alt="img"></p>
<h2 id="HashMap是怎么进行扩容的？"><a href="#HashMap是怎么进行扩容的？" class="headerlink" title="HashMap是怎么进行扩容的？"></a>HashMap是怎么进行扩容的？</h2><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p>
<p>我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></span><br><span class="line">    Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line">   <span class="keyword">int</span> oldCapacity = oldTable.length;         </span><br><span class="line">     <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">        threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">     Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">    transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line">     table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">    Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">     <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">         Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                 Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">                 e.next = newTable[i]; <span class="comment">//标记[1]</span></span><br><span class="line">                 newTable[i] = e;      <span class="comment">//将元素放在数组上</span></span><br><span class="line">                 e = next;             <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">             &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p>
<p>下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210817165435.png" alt="img"></p>
<p>下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210817165518.png" alt="img"></p>
<p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210817165540.png" alt="img"></p>
<p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210817165555.png" alt="img"></p>
<p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。JDK1.8扩容步骤为:</p>
<p>（1）如果使用是默认构造方法，则第一次插入元素时初始化为默认值，容量为16，扩容门槛为12；</p>
<p>（2）如果使用的是非默认构造方法，则第一次插入元素时初始化容量等于扩容门槛，扩容门槛在构造方法里等于传入容量向上最近的2的n次方；</p>
<p>（3）如果旧容量大于0，则新容量等于旧容量的2倍，但不超过最大容量2的30次方，新扩容门槛为旧扩容门槛的2倍；</p>
<p>（4）创建一个新容量的桶；</p>
<p>（5）搬移元素，原链表分化成两个链表，低位链表存储在原来桶的位置，高位链表搬移到原来桶的位置加旧容量的位置；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K, V&gt;[] resize() &#123;</span><br><span class="line">       <span class="comment">// 旧数组</span></span><br><span class="line">       Node&lt;K, V&gt;[] oldTab = table;</span><br><span class="line">       <span class="comment">// 旧容量</span></span><br><span class="line">       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">       <span class="comment">// 旧扩容门槛</span></span><br><span class="line">       <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               <span class="comment">// 如果旧容量达到了最大容量，则不再进行扩容</span></span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               <span class="comment">// 如果旧容量的两倍小于最大容量并且旧容量大于默认初始容量（16），则容量扩大为两部，扩容门槛也扩大为两倍</span></span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           <span class="comment">// 使用非默认构造方法创建的map，第一次插入元素会走到这里</span></span><br><span class="line">           <span class="comment">// 如果旧容量为0且旧扩容门槛大于0，则把新容量赋值为旧门槛</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">           <span class="comment">// 调用默认构造方法创建的map，第一次插入元素会走到这里</span></span><br><span class="line">           <span class="comment">// 如果旧容量旧扩容门槛都是0，说明还未初始化过，则初始化容量为默认容量，扩容门槛为默认容量*默认装载因子</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           newThr = (<span class="keyword">int</span>) (DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果新扩容门槛为0，则计算为容量*装载因子，但不能超过最大容量</span></span><br><span class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>) newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>) MAXIMUM_CAPACITY ?</span><br><span class="line">                   (<span class="keyword">int</span>) ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 赋值扩容门槛为新门槛</span></span><br><span class="line">       threshold = newThr;</span><br><span class="line">       <span class="comment">// 新建一个新容量的数组</span></span><br><span class="line">       <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span></span><br><span class="line">       Node&lt;K, V&gt;[] newTab = (Node&lt;K, V&gt;[]) <span class="keyword">new</span> Node[newCap];</span><br><span class="line">       <span class="comment">// 把桶赋值为新数组</span></span><br><span class="line">       table = newTab;</span><br><span class="line">       <span class="comment">// 如果旧数组不为空，则搬移元素</span></span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 遍历旧数组</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K, V&gt; e;</span><br><span class="line">               <span class="comment">// 如果桶中第一个元素不为空，赋值给e</span></span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// 清空旧桶，便于GC回收  </span></span><br><span class="line">                   oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="comment">// 如果这个桶中只有一个元素，则计算它在新桶中的位置并把它搬移到新桶中</span></span><br><span class="line">                   <span class="comment">// 因为每次都扩容两倍，所以这里的第一个元素搬移到新桶的时候新桶肯定还没有元素</span></span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                       <span class="comment">// 如果第一个元素是树节点，则把这颗树打散成两颗树插入到新桶中去</span></span><br><span class="line">                       ((TreeNode&lt;K, V&gt;) e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                       <span class="comment">// 如果这个链表不止一个元素且不是一颗树</span></span><br><span class="line">                       <span class="comment">// 则分化成两个链表插入到新的桶中去</span></span><br><span class="line">                       <span class="comment">// 比如，假如原来容量为4，3、7、11、15这四个元素都在三号桶中</span></span><br><span class="line">                       <span class="comment">// 现在扩容到8，则3和11还是在三号桶，7和15要搬移到七号桶中去</span></span><br><span class="line">                       <span class="comment">// 也就是分化成了两个链表</span></span><br><span class="line">                       Node&lt;K, V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K, V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K, V&gt; next;</span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="comment">// (e.hash &amp; oldCap) == 0的元素放在低位链表中</span></span><br><span class="line">                           <span class="comment">// 比如，3 &amp; 4 == 0</span></span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="comment">// (e.hash &amp; oldCap) != 0的元素放在高位链表中</span></span><br><span class="line">                               <span class="comment">// 比如，7 &amp; 4 != 0</span></span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                       <span class="comment">// 遍历完成分化成两个链表了</span></span><br><span class="line">                       <span class="comment">// 低位链表在新桶中的位置与旧桶一样（即3和11还在三号桶中）</span></span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">// 高位链表在新桶中的位置正好是原来的位置加上旧容量（即7和15搬移到七号桶了）</span></span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<h2 id="HashMap的put方法"><a href="#HashMap的put方法" class="headerlink" title="HashMap的put方法?"></a>HashMap的put方法?</h2><p>先说HashMap的Put方法的大体流程：<br>1根据Key通过哈希算法与与运算得出数组下标<br>2如果数组下标位置元素为空，则将key和value封装为Entry对象（JDK1.7中是Entry对象，JDK1.8中是Node对象）并放入该位置<br>3如果数组下标位置元素不为空，则要分情况讨论<br>    a如果是JDK1.7，则先判断是否需要扩容，如果要扩容就进行扩容，如果不用扩容就生成Entry对象，并使用头插法添加到当前位置的链表中<br>    b如果是JDK1.8，则会先判断当前位置上的Node的类型，看是红黑树Node，还是链表Node<br>        ⅰ如果是红黑树Node，则将key和value封装为一个红黑树节点并添加到红黑树中去，在这个过程中会判断红黑树中是否存在当前key，如果存在则更新value<br>        ⅱ如果此位置上的Node对象是链表节点，则将key和value封装为一个链表Node并通过尾插法插入到链表的最后位置去，因为是尾插法，所以需要遍历链表，在遍历链表的过程中会判断是否存在当前key，如果存在则更新value，当遍历完链表后，将新链表Node插入到链表中，插入到链表后，会看当前链表的节点个数，如果大于等于8，那么则会将该链表转成红黑树<br>        ⅲ将key和value封装为Node插入到链表或红黑树中后，再判断是否需要进行扩容，如果需要就扩容，如果不需要就结束PUT方法</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210817162307.png" alt="HashMap的put方法过程"></p>
<p>代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用hash(key)计算出key的hash值</span></span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="comment">// 如果key为null，则hash值为0，否则调用key的hashCode()方法</span></span><br><span class="line">        <span class="comment">// 并让高16位与整个hash异或，这样做是为了使计算出的hash更分散</span></span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K, V&gt;[] tab;</span><br><span class="line">        Node&lt;K, V&gt; p;</span><br><span class="line">        <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">// 如果桶的数量为0，则初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 调用resize()初始化</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// (n - 1) &amp; hash 计算元素在哪个桶中</span></span><br><span class="line">        <span class="comment">// 如果这个桶中还没有元素，则把这个元素放在桶中的第一个位置</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 新建一个节点放在桶中</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果桶中已经有元素存在了</span></span><br><span class="line">            Node&lt;K, V&gt; e;</span><br><span class="line">            K k;</span><br><span class="line">            <span class="comment">// 如果桶中第一个元素的key与待插入元素的key相同，保存到e中用于后续修改value值</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 如果第一个元素是树节点，则调用树节点的putTreeVal插入元素</span></span><br><span class="line">                e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 遍历这个桶对应的链表，binCount用于存储链表中元素的个数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">// 如果链表遍历完了都没有找到相同key的元素，说明该key对应的元素不存在，则在链表最后插入一个新节点</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">// 如果插入新节点后链表长度大于8，则判断是否需要树化，因为第一个元素没有加到binCount中，所以这里-1</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果待插入的key在链表中找到了，则退出循环</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果找到了对应key的元素</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="comment">// 记录下旧值</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="comment">// 判断是否需要替换旧值</span></span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 替换旧值为新值</span></span><br><span class="line">                    e.value = value;</span><br><span class="line">                <span class="comment">// 在节点被访问后做点什么事，在LinkedHashMap中用到</span></span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="comment">// 返回旧值</span></span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 到这里了说明没有找到元素</span></span><br><span class="line">        <span class="comment">// 修改次数加1</span></span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="comment">// 元素数量加1，判断是否需要扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            <span class="comment">// 扩容</span></span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 在节点插入后做点什么事，在LinkedHashMap中用到</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="comment">// 没找到元素返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap中的元素是否是有序的？"><a href="#HashMap中的元素是否是有序的？" class="headerlink" title="HashMap中的元素是否是有序的？"></a>HashMap中的元素是否是有序的？</h2><p>HashMap中的元素是无序的</p>
<h2 id="HashMap何时进行树化？何时进行反树化？"><a href="#HashMap何时进行树化？何时进行反树化？" class="headerlink" title="HashMap何时进行树化？何时进行反树化？"></a>HashMap何时进行树化？何时进行反树化？</h2><p>如果冲突的节点数已经达到8个，看是否需要改变冲突节点的存储结构，treeifyBin首先判断当前hashMap的长度，如果不足64，只进行resize，扩容table，如果达到64，那么将冲突的存储结构为红黑树。</p>
<p>当链表的元素大于8时进行树化，小于6时进行反树化。</p>
<p><strong>选择 8 作为阀值和加载因子为0.75的原因是参考 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Poisson_distribution">泊松概率函数(Poisson distribution)</a></strong> </p>
<p>在hashCode离散性很好的情况下，红黑树用到的概率非常小，因为数据均匀分布在每个桶中，几乎不会有桶中链表长度会达到阈值(8)。但是在随机hashCode下，离散性可能会变差，然而JDK又不能阻止用户实现这种不好的hash算法，因此就可能导致不均匀的数据分布。<br>事实上，随机hashCode算法下所有桶中节点的分布频率遵循如下的泊松分布。在扩容阈值为0.75的情况下，（即使因为扩容而方差很大）遵循着参数平均为0.5的泊松分布。一个桶中链表长度达到8个元素的概率为0.00000006，几乎是不可能事件。之所以选择8，是时间和空间的权衡(trade-off)，是根据概率统计决定的, 是非常严谨和科学的。</p>
<p>通俗点将就是put进去的key进行计算hashCode时 只要选择计算hash值的算法足够好(hash碰撞率极低)，从而遵循泊松分布，使得桶中挂载的bin的数量等于8的概率非常小，从而转换为红黑树的概率也小，反之则概率大。</p>
<p><strong>为什么转化为红黑树的阈值8和转化为链表的阈值6不一样?</strong></p>
<p>为了避免频繁来回转化。</p>
<h2 id="泊松分布与指数分布"><a href="#泊松分布与指数分布" class="headerlink" title="泊松分布与指数分布"></a>泊松分布与指数分布</h2><h3 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h3><p>Poisson分布，是一种统计与概率论中常见的离散概率分布，其适合于描述单位时间内随机事件发生的次数的概率分布。</p>
<p>如某一服务设施在一定时间内受到的服务请求的次数，电话交换机接到呼叫的次数、汽车站台的候客人数、机器出现的故障数、自然灾害发生的次数、DNA序列的变异数、放射性原子核的衰变数、激光的光子数分布等等；</p>
<h3 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a>指数分布</h3><p>指数分布（Exponential distribution）是一种连续概率分布。指数分配可以用来表示独立随机事件发生的时间间隔，比如旅客进入机场的时间间隔、打进客服中心电话的时间间隔、中文维基百科新条目出现的时间间隔等等；</p>
<p>与泊松分布相比，其最大的差异就是指数分布是针对连续随机变量定义，即时间这个变量。时间必须是连续的。而泊松分布是针对随机事件发生次数定义的，发生次数是离散的。粗略地可以认为这两个分布之间有一种“倒数”的关系</p>
<h2 id="HashMap是怎么进行缩容的？"><a href="#HashMap是怎么进行缩容的？" class="headerlink" title="HashMap是怎么进行缩容的？"></a>HashMap是怎么进行缩容的？</h2><p> 它不会动态地进行缩容，也就是说，你不应该保留一个已经删除过大量Entry的HashMap（如果不打算继续添加元素的话），此时它的buckets数组经过多次扩容已经变得非常大了，这会占用非常多的无用内存，这样做的好处是不用多次对数组进行扩容或缩容操作。不过一般也不会出现这种情况，如果遇见了，请毫不犹豫地丢掉它，或者把数据转移到一个新的HashMap。</p>
<h2 id="HashMap插入、删除、查询元素的时间复杂度各是多少？"><a href="#HashMap插入、删除、查询元素的时间复杂度各是多少？" class="headerlink" title="HashMap插入、删除、查询元素的时间复杂度各是多少？"></a>HashMap插入、删除、查询元素的时间复杂度各是多少？</h2><p>因为HashMap很少出现hash冲突了，因为哈希算法足够优秀，那么全是o（1）</p>
<p>但是当有链表的时候，那么就是o（n）的复杂度</p>
<p>如果转成红黑树 也就是二叉树的一种，那么应该是o（logN）的平均复杂度</p>
<h2 id="HashMap中的红黑树实现部分可以用其它数据结构代替吗？"><a href="#HashMap中的红黑树实现部分可以用其它数据结构代替吗？" class="headerlink" title="HashMap中的红黑树实现部分可以用其它数据结构代替吗？"></a>HashMap中的红黑树实现部分可以用其它数据结构代替吗？</h2><p>之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构(这就跟原来使用链表结构一样了，造成很深的问题)，遍历查找会非常慢。</p>
<p>而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。</p>
<h2 id="LinkedHashMap是怎么实现的？"><a href="#LinkedHashMap是怎么实现的？" class="headerlink" title="LinkedHashMap是怎么实现的？"></a>LinkedHashMap是怎么实现的？</h2><p>LinkedHashMap内部维护了一个双向链表，能保证元素按插入的顺序访问，也能以访问顺序访问，可以用来实现LRU缓存策略。</p>
<p>LinkedHashMap可以看成是 LinkedList + HashMap。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210817171707.png" alt="202105091520406812.png"></p>
<h2 id="LinkedHashMap是有序的吗？怎么个有序法？"><a href="#LinkedHashMap是有序的吗？怎么个有序法？" class="headerlink" title="LinkedHashMap是有序的吗？怎么个有序法？"></a>LinkedHashMap是有序的吗？怎么个有序法？</h2><p>如果accessOrder为false，则可以按插入元素的顺序遍历元素；</p>
<p>如果accessOrder为true，则可以按访问元素的顺序遍历元素；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 双向链表头节点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 双向链表尾节点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否按访问顺序排序</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>

<p>LinkedHashMap 通过重写 HashMap 提供的回调方法，从而实现其对<strong>顺序</strong>的特性的处理。同时，因为 LinkedHashMap 的<strong>顺序</strong>特性，需要重写 <code>#keysToArray(T[] a)</code> 等<strong>遍历</strong>相关的方法。</p>
<h2 id="LinkedHashMap如何实现LRU缓存淘汰策略？"><a href="#LinkedHashMap如何实现LRU缓存淘汰策略？" class="headerlink" title="LinkedHashMap如何实现LRU缓存淘汰策略？"></a>LinkedHashMap如何实现LRU缓存淘汰策略？</h2><p>首先，我们先来看看LRU是个什么鬼。LRU，Least Recently Used，最近最少使用，也就是优先淘汰最近最少使用的元素。</p>
<p>如果使用LinkedHashMap，我们把accessOrder设置为true是不是就差不多能实现这个策略了呢？答案是肯定的。请看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个只有5个元素的缓存</span></span><br><span class="line">        LRU&lt;Integer, Integer&gt; lru = <span class="keyword">new</span> LRU&lt;&gt;(<span class="number">5</span>, <span class="number">0.75f</span>);</span><br><span class="line">        lru.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        lru.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        lru.put(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        lru.put(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">        lru.put(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">        lru.put(<span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">        lru.put(<span class="number">7</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(lru.get(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">        lru.put(<span class="number">6</span>, <span class="number">666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出: &#123;3=3, 5=5, 7=7, 4=4, 6=666&#125;</span></span><br><span class="line">        <span class="comment">// 可以看到最旧的元素被删除了</span></span><br><span class="line">        <span class="comment">// 且最近访问的4被移到了后面</span></span><br><span class="line">        System.out.println(lru);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRU</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存缓存的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRU</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity, loadFactor, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写removeEldestEntry()方法设置何时移除旧元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eldest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当元素个数大于了缓存的容量, 就移除元素</span></span><br><span class="line">        <span class="keyword">return</span> size() &gt; <span class="keyword">this</span>.capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h2 id="WeakHashMap使用的数据结构？"><a href="#WeakHashMap使用的数据结构？" class="headerlink" title="WeakHashMap使用的数据结构？"></a>WeakHashMap使用的数据结构？</h2><p>WeakHashMap因为gc的时候会把没有强引用的key回收掉，所以注定了它里面的元素不会太多，因此也就不需要像HashMap那样元素多的时候转化为红黑树来处理了。</p>
<p>因此，WeakHashMap的存储结构只有（数组 + 链表）。</p>
<h2 id="WeakHashMap具有什么特性？"><a href="#WeakHashMap具有什么特性？" class="headerlink" title="WeakHashMap具有什么特性？"></a>WeakHashMap具有什么特性？</h2><p>WeakHashMap是一种弱引用map，内部的key会存储为弱引用，当jvm gc的时候，如果这些key没有强引用存在的话，会被gc回收掉，下一次当我们操作map的时候会把对应的Entry整个删除掉，基于这种特性，WeakHashMap特别适用于缓存处理。</p>
<h2 id="WeakHashMap通常用来做什么？"><a href="#WeakHashMap通常用来做什么？" class="headerlink" title="WeakHashMap通常用来做什么？"></a>WeakHashMap通常用来做什么？</h2><p>任何事物都有他存在的道理，WeakHashmap业务场景就是缓存，可以有效的节省内存，缓存丢失也不会出太大问题，可以再次获取。许多开源框架，例如tomcat等都使用了weakHashmap做为缓存处理。</p>
<h2 id="WeakHashMap使用String作为key是需要注意些什么？为什么？"><a href="#WeakHashMap使用String作为key是需要注意些什么？为什么？" class="headerlink" title="WeakHashMap使用String作为key是需要注意些什么？为什么？"></a>WeakHashMap使用String作为key是需要注意些什么？为什么？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.WeakHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: LvXueYang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@creat</span>:2021-08-17 09:29</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakHashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>), <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> String(<span class="string">&quot;2&quot;</span>), <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> String(<span class="string">&quot;3&quot;</span>), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 放入不用new String()声明的字符串</span></span><br><span class="line">        map.put(<span class="string">&quot;6&quot;</span>, <span class="number">6</span>);</span><br><span class="line">        String key = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (String s : map.keySet()) &#123;</span><br><span class="line">            <span class="comment">// 这个&quot;3&quot;和new String(&quot;3&quot;)不是一个引用</span></span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">&quot;3&quot;</span>)) &#123;</span><br><span class="line">                key = s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">// gc一下</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 放一个new String()声明的字符串</span></span><br><span class="line">        map.put(<span class="keyword">new</span> String(<span class="string">&quot;4&quot;</span>), <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出&#123;4=4, 6=6, 3=3&#125;，gc后放入的值和强引用的key可以打印出来</span></span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key与&quot;3&quot;的引用断裂</span></span><br><span class="line">        key = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// gc一下</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出&#123;6=6&#125;，gc后强引用的key可以打印出来</span></span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="什么是强引用、软引用、弱引用、虚引用？"><a href="#什么是强引用、软引用、弱引用、虚引用？" class="headerlink" title="什么是强引用、软引用、弱引用、虚引用？"></a>什么是强引用、软引用、弱引用、虚引用？</h2><p>（1）强引用</p>
<p>使用最普遍的引用。如果一个对象具有强引用，它绝对不会被gc回收。如果内存空间不足了，gc宁愿抛出OutOfMemoryError，也不是会回收具有强引用的对象。</p>
<p>（2）软引用</p>
<p>如果一个对象只具有软引用，则内存空间足够时不会回收它，但内存空间不够时就会回收这部分对象。只要这个具有软引用对象没有被回收，程序就可以正常使用。</p>
<p>（3）弱引用</p>
<p>如果一个对象只具有弱引用，则不管内存空间够不够，当gc扫描到它时就会回收它。</p>
<p>（4）虚引用</p>
<p>如果一个对象只具有虚引用，那么它就和没有任何引用一样，任何时候都可能被gc回收。</p>
<p>软（弱、虚）引用必须和一个引用队列（ReferenceQueue）一起使用，当gc回收这个软（弱、虚）引用引用的对象时，会把这个软（弱、虚）引用放到这个引用队列中。</p>
<h2 id="红黑树具有哪些特性？"><a href="#红黑树具有哪些特性？" class="headerlink" title="红黑树具有哪些特性？"></a>红黑树具有哪些特性？</h2><p>红黑树具有以下5种性质：</p>
<p>（1）节点是红色或黑色。</p>
<p>（2）根节点是黑色。</p>
<p>（3）每个叶节点（NIL节点，空节点）是黑色的。</p>
<p>（4）每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</p>
<p>（5）从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p>
<p>红黑树的时间复杂度为O(log n)，与树的高度成正比。</p>
<p>红黑树每次的插入、删除操作都需要做平衡，平衡时有可能会改变根节点的位置，颜色转换，左旋，右旋等</p>
<h2 id="TreeMap就有序的吗？怎么个有序法？"><a href="#TreeMap就有序的吗？怎么个有序法？" class="headerlink" title="TreeMap就有序的吗？怎么个有序法？"></a>TreeMap就有序的吗？怎么个有序法？</h2><p>TreeMap中的元素是有序的，按key的顺序排列；</p>
<h2 id="TreeMap是否需要扩容？"><a href="#TreeMap是否需要扩容？" class="headerlink" title="TreeMap是否需要扩容？"></a>TreeMap是否需要扩容？</h2><p>TreeMap 因为采用树结构，所以无需初始考虑像 HashMap 考虑<strong>容量</strong>问题，也不存在扩容问题。</p>
<p>,TreeMap的存储结构只有一颗红黑树</p>
<h2 id="什么是左旋？什么是右旋？"><a href="#什么是左旋？什么是右旋？" class="headerlink" title="什么是左旋？什么是右旋？"></a>什么是左旋？什么是右旋？</h2><p>左旋，就是以某个节点为支点向左旋转。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210817173626.png" alt="202105091520433963.png"></p>
<p>整个左旋过程如下：</p>
<p>（1）将 y的左节点 设为 x的右节点，即将 β 设为 x的右节点；</p>
<p>（2）将 x 设为 y的左节点的父节点，即将 β的父节点 设为 x；</p>
<p>（3）将 x的父节点 设为 y的父节点；</p>
<p>（4）如果 x的父节点 为空节点，则将y设置为根节点；如果x是它父节点的左（右）节点，则将y设置为x父节点的左（右）节点；</p>
<p>（5）将 x 设为 y的左节点；</p>
<p>（6）将 x的父节点 设为 y；</p>
<p>让我们来看看TreeMap中的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 以p为支点进行左旋</span></span><br><span class="line"><span class="comment">   * 假设p为图中的x</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// p的右节点，即y</span></span><br><span class="line">          Entry&lt;K,V&gt; r = p.right;</span><br><span class="line">  </span><br><span class="line">          <span class="comment">// （1）将 y的左节点 设为 x的右节点</span></span><br><span class="line">          p.right = r.left;</span><br><span class="line">  </span><br><span class="line">          <span class="comment">// （2）将 x 设为 y的左节点的父节点（如果y的左节点存在的话）</span></span><br><span class="line">          <span class="keyword">if</span> (r.left != <span class="keyword">null</span>)</span><br><span class="line">              r.left.parent = p;</span><br><span class="line">  </span><br><span class="line">          <span class="comment">// （3）将 x的父节点 设为 y的父节点</span></span><br><span class="line">          r.parent = p.parent;</span><br><span class="line">  </span><br><span class="line">          <span class="comment">// （4）...</span></span><br><span class="line">          <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">              <span class="comment">// 如果 x的父节点 为空，则将y设置为根节点</span></span><br><span class="line">              root = r;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.left == p)</span><br><span class="line">              <span class="comment">// 如果x是它父节点的左节点，则将y设置为x父节点的左节点</span></span><br><span class="line">              p.parent.left = r;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              <span class="comment">// 如果x是它父节点的右节点，则将y设置为x父节点的右节点</span></span><br><span class="line">              p.parent.right = r;</span><br><span class="line">  </span><br><span class="line">          <span class="comment">// （5）将 x 设为 y的左节点</span></span><br><span class="line">          r.left = p;</span><br><span class="line">  </span><br><span class="line">          <span class="comment">// （6）将 x的父节点 设为 y</span></span><br><span class="line">          p.parent = r;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>右旋，就是以某个节点为支点向右旋转。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210817173656.png" alt="202105091520436904.png"></p>
<p>整个右旋过程如下：</p>
<p>（1）将 x的右节点 设为 y的左节点，即 将 β 设为 y的左节点；</p>
<p>（2）将 y 设为 x的右节点的父节点，即 将 β的父节点 设为 y；</p>
<p>（3）将 y的父节点 设为 x的父节点；</p>
<p>（4）如果 y的父节点 是 空节点，则将x设为根节点；如果y是它父节点的左（右）节点，则将x设为y的父节点的左（右）节点；</p>
<p>（5）将 y 设为 x的右节点；</p>
<p>（6）将 y的父节点 设为 x；</p>
<p>让我们来看看TreeMap中的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 以p为支点进行右旋</span></span><br><span class="line"><span class="comment">    * 假设p为图中的y</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// p的左节点，即x</span></span><br><span class="line">           Entry&lt;K,V&gt; l = p.left;</span><br><span class="line">   </span><br><span class="line">           <span class="comment">// （1）将 x的右节点 设为 y的左节点</span></span><br><span class="line">           p.left = l.right;</span><br><span class="line">   </span><br><span class="line">           <span class="comment">// （2）将 y 设为 x的右节点的父节点（如果x有右节点的话）</span></span><br><span class="line">           <span class="keyword">if</span> (l.right != <span class="keyword">null</span>) l.right.parent = p;</span><br><span class="line">   </span><br><span class="line">           <span class="comment">// （3）将 y的父节点 设为 x的父节点</span></span><br><span class="line">           l.parent = p.parent;</span><br><span class="line">   </span><br><span class="line">           <span class="comment">// （4）...</span></span><br><span class="line">           <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">               <span class="comment">// 如果 y的父节点 是 空节点，则将x设为根节点</span></span><br><span class="line">               root = l;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.right == p)</span><br><span class="line">               <span class="comment">// 如果y是它父节点的右节点，则将x设为y的父节点的右节点</span></span><br><span class="line">               p.parent.right = l;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               <span class="comment">// 如果y是它父节点的左节点，则将x设为y的父节点的左节点</span></span><br><span class="line">               p.parent.left = l;</span><br><span class="line">   </span><br><span class="line">           <span class="comment">// （5）将 y 设为 x的右节点</span></span><br><span class="line">           l.right = p;</span><br><span class="line">   </span><br><span class="line">           <span class="comment">// （6）将 y的父节点 设为 x</span></span><br><span class="line">           p.parent = l;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<h2 id="红黑树怎么插入元素？"><a href="#红黑树怎么插入元素？" class="headerlink" title="红黑树怎么插入元素？"></a>红黑树怎么插入元素？</h2><p>插入元素，如果元素在树中存在，则替换value；如果元素不存在，则插入到对应的位置，再平衡树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">     Entry&lt;K,V&gt; t = root;</span><br><span class="line">     <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 如果没有根节点，直接插入到根节点</span></span><br><span class="line">         compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line">         root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">         size = <span class="number">1</span>;</span><br><span class="line">         modCount++;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// key比较的结果</span></span><br><span class="line">     <span class="keyword">int</span> cmp;</span><br><span class="line">     <span class="comment">// 用来寻找待插入节点的父节点</span></span><br><span class="line">     Entry&lt;K,V&gt; parent;</span><br><span class="line">     <span class="comment">// 根据是否有comparator使用不同的分支</span></span><br><span class="line">     Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">     <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 如果使用的是comparator方式，key值可以为null，只要在comparator.compare()中允许即可</span></span><br><span class="line">         <span class="comment">// 从根节点开始遍历寻找</span></span><br><span class="line">         <span class="keyword">do</span> &#123;</span><br><span class="line">             parent = t;</span><br><span class="line">             cmp = cpr.compare(key, t.key);</span><br><span class="line">             <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                 <span class="comment">// 如果小于0从左子树寻找</span></span><br><span class="line">                 t = t.left;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                 <span class="comment">// 如果大于0从右子树寻找</span></span><br><span class="line">                 t = t.right;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">                 <span class="comment">// 如果等于0，说明插入的节点已经存在了，直接更换其value值并返回旧值</span></span><br><span class="line">                 <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">         &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 如果使用的是Comparable方式，key不能为null</span></span><br><span class="line">         <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">         <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">         Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">         <span class="comment">// 从根节点开始遍历寻找</span></span><br><span class="line">         <span class="keyword">do</span> &#123;</span><br><span class="line">             parent = t;</span><br><span class="line">             cmp = k.compareTo(t.key);</span><br><span class="line">             <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                 <span class="comment">// 如果小于0从左子树寻找</span></span><br><span class="line">                 t = t.left;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                 <span class="comment">// 如果大于0从右子树寻找</span></span><br><span class="line">                 t = t.right;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">                 <span class="comment">// 如果等于0，说明插入的节点已经存在了，直接更换其value值并返回旧值</span></span><br><span class="line">                 <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">         &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 如果没找到，那么新建一个节点，并插入到树中</span></span><br><span class="line">     Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</span><br><span class="line">     <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="comment">// 如果小于0插入到左子节点</span></span><br><span class="line">         parent.left = e;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         <span class="comment">// 如果大于0插入到右子节点</span></span><br><span class="line">         parent.right = e;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 插入之后的平衡</span></span><br><span class="line">     fixAfterInsertion(e);</span><br><span class="line">     <span class="comment">// 元素个数加1（不需要扩容）</span></span><br><span class="line">     size++;</span><br><span class="line">     <span class="comment">// 修改次数加1</span></span><br><span class="line">     modCount++;</span><br><span class="line">     <span class="comment">// 如果插入了新节点返回空</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="插入再平衡"><a href="#插入再平衡" class="headerlink" title="插入再平衡"></a>插入再平衡</h3><p>插入的元素默认都是红色，因为插入红色元素只违背了第4条特性，那么我们只要根据这个特性来平衡就容易多了。</p>
<p>根据不同的情况有以下几种处理方式：</p>
<ol>
<li>插入的元素如果是根节点，则直接涂成黑色即可，不用平衡；</li>
<li>插入的元素的父节点如果为黑色，不需要平衡；</li>
<li>插入的元素的父节点如果为红色，则违背了特性4，需要平衡，平衡时又分成下面三种情况：</li>
</ol>
<p><strong>（如果父节点是祖父节点的左节点）</strong></p>
<table>
<thead>
<tr>
<th>情况</th>
<th>策略</th>
</tr>
</thead>
<tbody><tr>
<td>1）父节点为红色，叔叔节点也为红色</td>
<td>（1）将父节点设为黑色；（2）将叔叔节点设为黑色；（3）将祖父节点设为红色；（4）将祖父节点设为新的当前节点，进入下一次循环判断；</td>
</tr>
<tr>
<td>2）父节点为红色，叔叔节点为黑色，且当前节点是其父节点的右节点</td>
<td>（1）将父节点作为新的当前节点；（2）以新当节点为支点进行左旋，进入情况3）；</td>
</tr>
<tr>
<td>3）父节点为红色，叔叔节点为黑色，且当前节点是其父节点的左节点</td>
<td>（1）将父节点设为黑色；（2）将祖父节点设为红色；（3）以祖父节点为支点进行右旋，进入下一次循环判断；</td>
</tr>
</tbody></table>
<p><strong>（如果父节点是祖父节点的右节点，则正好与上面反过来）</strong></p>
<table>
<thead>
<tr>
<th>情况</th>
<th>策略</th>
</tr>
</thead>
<tbody><tr>
<td>1）父节点为红色，叔叔节点也为红色</td>
<td>（1）将父节点设为黑色；（2）将叔叔节点设为黑色；（3）将祖父节点设为红色；（4）将祖父节点设为新的当前节点，进入下一次循环判断；</td>
</tr>
<tr>
<td>2）父节点为红色，叔叔节点为黑色，且当前节点是其父节点的左节点</td>
<td>（1）将父节点作为新的当前节点；（2）以新当节点为支点进行右旋；</td>
</tr>
<tr>
<td>3）父节点为红色，叔叔节点为黑色，且当前节点是其父节点的右节点</td>
<td>（1）将父节点设为黑色；（2）将祖父节点设为红色；（3）以祖父节点为支点进行左旋，进入下一次循环判断；</td>
</tr>
</tbody></table>
<p>让我们来看看TreeMap中的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 插入再平衡</span></span><br><span class="line"><span class="comment">    *（1）每个节点或者是黑色，或者是红色。</span></span><br><span class="line"><span class="comment">    *（2）根节点是黑色。</span></span><br><span class="line"><span class="comment">    *（3）每个叶子节点（NIL）是黑色。（注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！）</span></span><br><span class="line"><span class="comment">    *（4）如果一个节点是红色的，则它的子节点必须是黑色的。</span></span><br><span class="line"><span class="comment">    *（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 插入的节点为红节点，x为当前节点</span></span><br><span class="line">       x.color = RED;</span><br><span class="line">   </span><br><span class="line">       <span class="comment">// 只有当插入节点不是根节点且其父节点为红色时才需要平衡（违背了特性4）</span></span><br><span class="line">       <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">           <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">               <span class="comment">// a）如果父节点是祖父节点的左节点</span></span><br><span class="line">               <span class="comment">// y为叔叔节点</span></span><br><span class="line">               Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">               <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                   <span class="comment">// 情况1）如果叔叔节点为红色</span></span><br><span class="line">                   <span class="comment">// （1）将父节点设为黑色</span></span><br><span class="line">                   setColor(parentOf(x), BLACK);</span><br><span class="line">                   <span class="comment">// （2）将叔叔节点设为黑色</span></span><br><span class="line">                   setColor(y, BLACK);</span><br><span class="line">                   <span class="comment">// （3）将祖父节点设为红色</span></span><br><span class="line">                   setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                   <span class="comment">// （4）将祖父节点设为新的当前节点</span></span><br><span class="line">                   x = parentOf(parentOf(x));</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 如果叔叔节点为黑色</span></span><br><span class="line">                   <span class="comment">// 情况2）如果当前节点为其父节点的右节点</span></span><br><span class="line">                   <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                       <span class="comment">// （1）将父节点设为当前节点</span></span><br><span class="line">                       x = parentOf(x);</span><br><span class="line">                       <span class="comment">// （2）以新当前节点左旋</span></span><br><span class="line">                       rotateLeft(x);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// 情况3）如果当前节点为其父节点的左节点（如果是情况2）则左旋之后新当前节点正好为其父节点的左节点了）</span></span><br><span class="line">                   <span class="comment">// （1）将父节点设为黑色</span></span><br><span class="line">                   setColor(parentOf(x), BLACK);</span><br><span class="line">                   <span class="comment">// （2）将祖父节点设为红色</span></span><br><span class="line">                   setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                   <span class="comment">// （3）以祖父节点为支点进行右旋</span></span><br><span class="line">                   rotateRight(parentOf(parentOf(x)));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// b）如果父节点是祖父节点的右节点</span></span><br><span class="line">               <span class="comment">// y是叔叔节点</span></span><br><span class="line">               Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">               <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                   <span class="comment">// 情况1）如果叔叔节点为红色</span></span><br><span class="line">                   <span class="comment">// （1）将父节点设为黑色</span></span><br><span class="line">                   setColor(parentOf(x), BLACK);</span><br><span class="line">                   <span class="comment">// （2）将叔叔节点设为黑色</span></span><br><span class="line">                   setColor(y, BLACK);</span><br><span class="line">                   <span class="comment">// （3）将祖父节点设为红色</span></span><br><span class="line">                   setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                   <span class="comment">// （4）将祖父节点设为新的当前节点</span></span><br><span class="line">                   x = parentOf(parentOf(x));</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 如果叔叔节点为黑色</span></span><br><span class="line">                   <span class="comment">// 情况2）如果当前节点为其父节点的左节点</span></span><br><span class="line">                   <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                       <span class="comment">// （1）将父节点设为当前节点</span></span><br><span class="line">                       x = parentOf(x);</span><br><span class="line">                       <span class="comment">// （2）以新当前节点右旋</span></span><br><span class="line">                       rotateRight(x);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// 情况3）如果当前节点为其父节点的右节点（如果是情况2）则右旋之后新当前节点正好为其父节点的右节点了）</span></span><br><span class="line">                   <span class="comment">// （1）将父节点设为黑色</span></span><br><span class="line">                   setColor(parentOf(x), BLACK);</span><br><span class="line">                   <span class="comment">// （2）将祖父节点设为红色</span></span><br><span class="line">                   setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                   <span class="comment">// （3）以祖父节点为支点进行左旋</span></span><br><span class="line">                   rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 平衡完成后将根节点设为黑色</span></span><br><span class="line">       root.color = BLACK;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<h2 id="红黑树怎么删除元素？"><a href="#红黑树怎么删除元素？" class="headerlink" title="红黑树怎么删除元素？"></a>红黑树怎么删除元素？</h2><p>删除元素本身比较简单，就是采用二叉树的删除规则。</p>
<p>（1）如果删除的位置有两个叶子节点，则从其右子树中取最小的元素放到删除的位置，然后把删除位置移到替代元素的位置，进入下一步。</p>
<p>（2）如果删除的位置只有一个叶子节点（有可能是经过第一步转换后的删除位置），则把那个叶子节点作为替代元素，放到删除的位置，然后把这个叶子节点删除。</p>
<p>（3）如果删除的位置没有叶子节点，则直接把这个删除位置的元素删除即可。</p>
<p>（4）针对红黑树，如果删除位置是黑色节点，还需要做再平衡。</p>
<p>（5）如果有替代元素，则以替代元素作为当前节点进入再平衡。</p>
<p>（6）如果没有替代元素，则以删除的位置的元素作为当前节点进入再平衡，平衡之后再删除这个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 获取节点</span></span><br><span class="line">       Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">       <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   </span><br><span class="line">       V oldValue = p.value;</span><br><span class="line">       <span class="comment">// 删除节点</span></span><br><span class="line">       deleteEntry(p);</span><br><span class="line">       <span class="comment">// 返回删除的value</span></span><br><span class="line">       <span class="keyword">return</span> oldValue;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 修改次数加1</span></span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="comment">// 元素个数减1</span></span><br><span class="line">       size--;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果当前节点既有左子节点，又有右子节点</span></span><br><span class="line">           <span class="comment">// 取其右子树中最小的节点</span></span><br><span class="line">           Entry&lt;K,V&gt; s = successor(p);</span><br><span class="line">           <span class="comment">// 用右子树中最小节点的值替换当前节点的值</span></span><br><span class="line">           p.key = s.key;</span><br><span class="line">           p.value = s.value;</span><br><span class="line">           <span class="comment">// 把右子树中最小节点设为当前节点</span></span><br><span class="line">           p = s;</span><br><span class="line">           <span class="comment">// 这种情况实际上并没有删除p节点，而是把p节点的值改了，实际删除的是p的后继节点</span></span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="comment">// 如果原来的当前节点（p）有2个子节点，则当前节点已经变成原来p的右子树中的最小节点了，也就是说其没有左子节点了</span></span><br><span class="line">       <span class="comment">// 到这一步，p肯定只有一个子节点了</span></span><br><span class="line">       <span class="comment">// 如果当前节点有子节点，则用子节点替换当前节点</span></span><br><span class="line">       Entry&lt;K,V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right);</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 把替换节点直接放到当前节点的位置上（相当于删除了p，并把替换节点移动过来了）</span></span><br><span class="line">           replacement.parent = p.parent;</span><br><span class="line">           <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">               root = replacement;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">               p.parent.left  = replacement;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               p.parent.right = replacement;</span><br><span class="line">   </span><br><span class="line">           <span class="comment">// 将p的各项属性都设为空</span></span><br><span class="line">           p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">   </span><br><span class="line">           <span class="comment">// 如果p是黑节点，则需要再平衡</span></span><br><span class="line">           <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">               fixAfterDeletion(replacement);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果当前节点就是根节点，则直接将根节点设为空即可</span></span><br><span class="line">           root = <span class="keyword">null</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 如果当前节点没有子节点且其为黑节点，则把自己当作虚拟的替换节点进行再平衡</span></span><br><span class="line">           <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">               fixAfterDeletion(p);</span><br><span class="line">   </span><br><span class="line">           <span class="comment">// 平衡完成后删除当前节点（与父节点断绝关系）</span></span><br><span class="line">           <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">                   p.parent.left = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</span><br><span class="line">                   p.parent.right = <span class="keyword">null</span>;</span><br><span class="line">               p.parent = <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p>经过上面的处理，真正删除的肯定是黑色节点才会进入到再平衡阶段。</p>
<p>因为删除的是黑色节点，导致整颗树不平衡了，所以这里我们假设把删除的黑色赋予当前节点，这样当前节点除了它自已的颜色还多了一个黑色，那么：</p>
<p>（1）如果当前节点是根节点，则直接涂黑即可，不需要再平衡；</p>
<p>（2）如果当前节点是红+黑节点，则直接涂黑即可，不需要平衡；</p>
<p>（3）如果当前节点是黑+黑节点，则我们只要通过旋转把这个多出来的黑色不断的向上传递到一个红色节点即可，这又可能会出现以下四种情况：</p>
<p><strong>（假设当前节点为父节点的左子节点）</strong></p>
<table>
<thead>
<tr>
<th>情况</th>
<th>策略</th>
</tr>
</thead>
<tbody><tr>
<td>1）x是黑+黑节点，x的兄弟是红节点</td>
<td>（1）将兄弟节点设为黑色；（2）将父节点设为红色；（3）以父节点为支点进行左旋；（4）重新设置x的兄弟节点，进入下一步；</td>
</tr>
<tr>
<td>2）x是黑+黑节点，x的兄弟是黑节点，且兄弟节点的两个子节点都是黑色</td>
<td>（1）将兄弟节点设置为红色；（2）将x的父节点作为新的当前节点，进入下一次循环；</td>
</tr>
<tr>
<td>3）x是黑+黑节点，x的兄弟是黑节点，且兄弟节点的右子节点为黑色，左子节点为红色</td>
<td>（1）将兄弟节点的左子节点设为黑色；（2）将兄弟节点设为红色；（3）以兄弟节点为支点进行右旋；（4）重新设置x的兄弟节点，进入下一步；</td>
</tr>
<tr>
<td>3）x是黑+黑节点，x的兄弟是黑节点，且兄弟节点的右子节点为红色，左子节点任意颜色</td>
<td>（1）将兄弟节点的颜色设为父节点的颜色；（2）将父节点设为黑色；（3）将兄弟节点的右子节点设为黑色；（4）以父节点为支点进行左旋；（5）将root作为新的当前节点（退出循环）；</td>
</tr>
</tbody></table>
<p><strong>（假设当前节点为父节点的右子节点，正好反过来）</strong></p>
<table>
<thead>
<tr>
<th>情况</th>
<th>策略</th>
</tr>
</thead>
<tbody><tr>
<td>1）x是黑+黑节点，x的兄弟是红节点</td>
<td>（1）将兄弟节点设为黑色；（2）将父节点设为红色；（3）以父节点为支点进行右旋；（4）重新设置x的兄弟节点，进入下一步；</td>
</tr>
<tr>
<td>2）x是黑+黑节点，x的兄弟是黑节点，且兄弟节点的两个子节点都是黑色</td>
<td>（1）将兄弟节点设置为红色；（2）将x的父节点作为新的当前节点，进入下一次循环；</td>
</tr>
<tr>
<td>3）x是黑+黑节点，x的兄弟是黑节点，且兄弟节点的左子节点为黑色，右子节点为红色</td>
<td>（1）将兄弟节点的右子节点设为黑色；（2）将兄弟节点设为红色；（3）以兄弟节点为支点进行左旋；（4）重新设置x的兄弟节点，进入下一步；</td>
</tr>
<tr>
<td>3）x是黑+黑节点，x的兄弟是黑节点，且兄弟节点的左子节点为红色，右子节点任意颜色</td>
<td>（1）将兄弟节点的颜色设为父节点的颜色；（2）将父节点设为黑色；（3）将兄弟节点的左子节点设为黑色；（4）以父节点为支点进行右旋；（5）将root作为新的当前节点（退出循环）；</td>
</tr>
</tbody></table>
<p>让我们来看看TreeMap中的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除再平衡</span></span><br><span class="line"><span class="comment">     *（1）每个节点或者是黑色，或者是红色。</span></span><br><span class="line"><span class="comment">     *（2）根节点是黑色。</span></span><br><span class="line"><span class="comment">     *（3）每个叶子节点（NIL）是黑色。（注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！）</span></span><br><span class="line"><span class="comment">     *（4）如果一个节点是红色的，则它的子节点必须是黑色的。</span></span><br><span class="line"><span class="comment">     *（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只有当前节点不是根节点且当前节点是黑色时才进入循环</span></span><br><span class="line">        <span class="keyword">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                <span class="comment">// 如果当前节点是其父节点的左子节点</span></span><br><span class="line">                <span class="comment">// sib是当前节点的兄弟节点</span></span><br><span class="line">                Entry&lt;K,V&gt; sib = rightOf(parentOf(x));</span><br><span class="line">    </span><br><span class="line">                <span class="comment">// 情况1）如果兄弟节点是红色</span></span><br><span class="line">                <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                    <span class="comment">// （1）将兄弟节点设为黑色</span></span><br><span class="line">                    setColor(sib, BLACK);</span><br><span class="line">                    <span class="comment">// （2）将父节点设为红色</span></span><br><span class="line">                    setColor(parentOf(x), RED);</span><br><span class="line">                    <span class="comment">// （3）以父节点为支点进行左旋</span></span><br><span class="line">                    rotateLeft(parentOf(x));</span><br><span class="line">                    <span class="comment">// （4）重新设置x的兄弟节点，进入下一步</span></span><br><span class="line">                    sib = rightOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                <span class="keyword">if</span> (colorOf(leftOf(sib))  == BLACK &amp;&amp;</span><br><span class="line">                        colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                    <span class="comment">// 情况2）如果兄弟节点的两个子节点都是黑色</span></span><br><span class="line">                    <span class="comment">// （1）将兄弟节点设置为红色</span></span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    <span class="comment">// （2）将x的父节点作为新的当前节点，进入下一次循环</span></span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                        <span class="comment">// 情况3）如果兄弟节点的右子节点为黑色</span></span><br><span class="line">                        <span class="comment">// （1）将兄弟节点的左子节点设为黑色</span></span><br><span class="line">                        setColor(leftOf(sib), BLACK);</span><br><span class="line">                        <span class="comment">// （2）将兄弟节点设为红色</span></span><br><span class="line">                        setColor(sib, RED);</span><br><span class="line">                        <span class="comment">// （3）以兄弟节点为支点进行右旋</span></span><br><span class="line">                        rotateRight(sib);</span><br><span class="line">                        <span class="comment">// （4）重新设置x的兄弟节点</span></span><br><span class="line">                        sib = rightOf(parentOf(x));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 情况4）</span></span><br><span class="line">                    <span class="comment">// （1）将兄弟节点的颜色设为父节点的颜色</span></span><br><span class="line">                    setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                    <span class="comment">// （2）将父节点设为黑色</span></span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    <span class="comment">// （3）将兄弟节点的右子节点设为黑色</span></span><br><span class="line">                    setColor(rightOf(sib), BLACK);</span><br><span class="line">                    <span class="comment">// （4）以父节点为支点进行左旋</span></span><br><span class="line">                    rotateLeft(parentOf(x));</span><br><span class="line">                    <span class="comment">// （5）将root作为新的当前节点（退出循环）</span></span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">                <span class="comment">// 如果当前节点是其父节点的右子节点</span></span><br><span class="line">                <span class="comment">// sib是当前节点的兄弟节点</span></span><br><span class="line">                Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</span><br><span class="line">    </span><br><span class="line">                <span class="comment">// 情况1）如果兄弟节点是红色</span></span><br><span class="line">                <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                    <span class="comment">// （1）将兄弟节点设为黑色</span></span><br><span class="line">                    setColor(sib, BLACK);</span><br><span class="line">                    <span class="comment">// （2）将父节点设为红色</span></span><br><span class="line">                    setColor(parentOf(x), RED);</span><br><span class="line">                    <span class="comment">// （3）以父节点为支点进行右旋</span></span><br><span class="line">                    rotateRight(parentOf(x));</span><br><span class="line">                    <span class="comment">// （4）重新设置x的兄弟节点</span></span><br><span class="line">                    sib = leftOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK &amp;&amp;</span><br><span class="line">                        colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                    <span class="comment">// 情况2）如果兄弟节点的两个子节点都是黑色</span></span><br><span class="line">                    <span class="comment">// （1）将兄弟节点设置为红色</span></span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    <span class="comment">// （2）将x的父节点作为新的当前节点，进入下一次循环</span></span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                        <span class="comment">// 情况3）如果兄弟节点的左子节点为黑色</span></span><br><span class="line">                        <span class="comment">// （1）将兄弟节点的右子节点设为黑色</span></span><br><span class="line">                        setColor(rightOf(sib), BLACK);</span><br><span class="line">                        <span class="comment">// （2）将兄弟节点设为红色</span></span><br><span class="line">                        setColor(sib, RED);</span><br><span class="line">                        <span class="comment">// （3）以兄弟节点为支点进行左旋</span></span><br><span class="line">                        rotateLeft(sib);</span><br><span class="line">                        <span class="comment">// （4）重新设置x的兄弟节点</span></span><br><span class="line">                        sib = leftOf(parentOf(x));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 情况4）</span></span><br><span class="line">                    <span class="comment">// （1）将兄弟节点的颜色设为父节点的颜色</span></span><br><span class="line">                    setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                    <span class="comment">// （2）将父节点设为黑色</span></span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    <span class="comment">// （3）将兄弟节点的左子节点设为黑色</span></span><br><span class="line">                    setColor(leftOf(sib), BLACK);</span><br><span class="line">                    <span class="comment">// （4）以父节点为支点进行右旋</span></span><br><span class="line">                    rotateRight(parentOf(x));</span><br><span class="line">                    <span class="comment">// （5）将root作为新的当前节点（退出循环）</span></span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 退出条件为多出来的黑色向上传递到了根节点或者红节点</span></span><br><span class="line">        <span class="comment">// 则将x设为黑色即可满足红黑树规则</span></span><br><span class="line">        setColor(x, BLACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么要进行平衡？"><a href="#为什么要进行平衡？" class="headerlink" title="为什么要进行平衡？"></a>为什么要进行平衡？</h2><p>因为违背了红黑树的性质,必须保证红黑树的五大性质。</p>
<p>（1）节点是红色或黑色。</p>
<p>（2）根节点是黑色。</p>
<p>（3）每个叶节点（NIL节点，空节点）是黑色的。</p>
<p>（4）每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</p>
<p>（5）从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p>
<h2 id="如何实现红黑树的遍历？"><a href="#如何实现红黑树的遍历？" class="headerlink" title="如何实现红黑树的遍历？"></a>如何实现红黑树的遍历？</h2><p>（1）从root遍历整个树；</p>
<p>（2）如果待查找的key比当前遍历的key小，则在其左子树中查找；</p>
<p>（3）如果待查找的key比当前遍历的key大，则在其右子树中查找；</p>
<p>（4）如果待查找的key与当前遍历的key相等，则找到了该元素，直接返回；</p>
<p>（5）从这里可以看出是否有comparator分化成了两个方法，但是内部逻辑一模一样，因此可见笔者<code>comparator = (k1, k2) -&gt; ((Comparable&lt;? super K&gt;)k1).compareTo(k2);</code>这种改造的必要性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据key查找元素</span></span><br><span class="line">        Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">        <span class="comment">// 找到了返回value值，没找到返回null</span></span><br><span class="line">        <span class="keyword">return</span> (p==<span class="keyword">null</span> ? <span class="keyword">null</span> : p.value);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果comparator不为空，使用comparator的版本获取元素</span></span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">        <span class="comment">// 如果key为空返回空指针异常</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// 将key强转为Comparable</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">        <span class="comment">// 从根元素开始遍历</span></span><br><span class="line">        Entry&lt;K,V&gt; p = root;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 如果小于0从左子树查找</span></span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 如果大于0从右子树查找</span></span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 如果相等说明找到了直接返回</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没找到返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntryUsingComparator</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        K k = (K) key;</span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">        <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 从根元素开始遍历</span></span><br><span class="line">            Entry&lt;K,V&gt; p = root;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> cmp = cpr.compare(k, p.key);</span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 如果小于0从左子树查找</span></span><br><span class="line">                    p = p.left;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 如果大于0从右子树查找</span></span><br><span class="line">                    p = p.right;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 如果相等说明找到了直接返回</span></span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没找到返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TreeMap为什么不允许key为null"><a href="#TreeMap为什么不允许key为null" class="headerlink" title="TreeMap为什么不允许key为null?"></a>TreeMap为什么不允许key为null?</h2><p>TreeMap 的 <strong>key</strong> 不允许为空( <code>null</code> )，可能是因为红黑树是一颗二叉查找树，需要对 key 进行排序。</p>
<h2 id="TreeMap中是怎么遍历的？"><a href="#TreeMap中是怎么遍历的？" class="headerlink" title="TreeMap中是怎么遍历的？"></a>TreeMap中是怎么遍历的？</h2><h2 id="TreeMap插入、删除、查询元素的时间复杂度各是多少？"><a href="#TreeMap插入、删除、查询元素的时间复杂度各是多少？" class="headerlink" title="TreeMap插入、删除、查询元素的时间复杂度各是多少？"></a>TreeMap插入、删除、查询元素的时间复杂度各是多少？</h2><p>TreeMap 的查找、添加、删除 key-value 键值对的<strong>平均</strong>时间复杂度为 <code>O(logN)</code> 。原因是，TreeMap 采用红黑树，操作都需要经过二分查找，而二分查找的时间复杂度是 <code>O(logN)</code> 。</p>
<h2 id="HashMap在多线程环境中什么时候会出现问题？"><a href="#HashMap在多线程环境中什么时候会出现问题？" class="headerlink" title="HashMap在多线程环境中什么时候会出现问题？"></a>HashMap在多线程环境中什么时候会出现问题？</h2><p>在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapInfiniteLoop</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,String&gt;(<span class="number">2</span>，<span class="number">0.75f</span>);  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        map.put(<span class="number">5</span>， <span class="string">&quot;C&quot;</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">&quot;Thread1&quot;</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                map.put(<span class="number">7</span>, <span class="string">&quot;B&quot;</span>);  </span><br><span class="line">                System.out.println(map);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">&quot;Thread2&quot;</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                map.put(<span class="number">3</span>, <span class="string">&quot;A);  </span></span><br><span class="line"><span class="string">                System.out.println(map);  </span></span><br><span class="line"><span class="string">            &#125;;  </span></span><br><span class="line"><span class="string">        &#125;.start();        </span></span><br><span class="line"><span class="string">    &#125;  </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。</p>
<p>通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210817173358.png" alt="img"></p>
<p>注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。</p>
<p>线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210817173416.png" alt="img"></p>
<p>于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。</p>
<h2 id="ConcurrentHashMap的存储结构？"><a href="#ConcurrentHashMap的存储结构？" class="headerlink" title="ConcurrentHashMap的存储结构？"></a>ConcurrentHashMap的存储结构？</h2><p>ConcurrentHashMap采用（数组 + 链表 + 红黑树）的结构存储元素；</p>
<h2 id="ConcurrentHashMap是怎么保证并发安全的？"><a href="#ConcurrentHashMap是怎么保证并发安全的？" class="headerlink" title="ConcurrentHashMap是怎么保证并发安全的？"></a>ConcurrentHashMap是怎么保证并发安全的？</h2><p>ConcurrentHashMap采用的锁有 synchronized，CAS，自旋锁，分段锁，volatile等</p>
<h2 id="ConcurrentHashMap是怎么扩容的？"><a href="#ConcurrentHashMap是怎么扩容的？" class="headerlink" title="ConcurrentHashMap是怎么扩容的？"></a>ConcurrentHashMap是怎么扩容的？</h2><p>1.每次添加元素后，元素数量加1，并判断是否达到扩容门槛，达到了则进行扩容或协助扩容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">        CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">        <span class="comment">// 这里使用的思想跟LongAdder类是一模一样的（后面会讲）</span></span><br><span class="line">        <span class="comment">// 把数组的大小存储根据不同的线程存储到不同的段上（也是分段锁的思想）</span></span><br><span class="line">        <span class="comment">// 并且有一个baseCount，优先更新baseCount，如果失败了再更新不同线程对应的段</span></span><br><span class="line">        <span class="comment">// 这样可以保证尽量小的减少冲突</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 先尝试把数量加到baseCount上，如果失败再加到分段的CounterCell上</span></span><br><span class="line">        <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">                !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">            CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">            <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 如果as为空</span></span><br><span class="line">            <span class="comment">// 或者长度为0</span></span><br><span class="line">            <span class="comment">// 或者当前线程所在的段为null</span></span><br><span class="line">            <span class="comment">// 或者在当前线程的段上加数量失败</span></span><br><span class="line">            <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">                    (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">                    !(uncontended =</span><br><span class="line">                            U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">                <span class="comment">// 强制增加数量（无论如何数量是一定要加上的，并不是简单地自旋）</span></span><br><span class="line">                <span class="comment">// 不同线程对应不同的段都更新失败了</span></span><br><span class="line">                <span class="comment">// 说明已经发生冲突了，那么就对counterCells进行扩容</span></span><br><span class="line">                <span class="comment">// 以减少多个线程hash到同一个段的概率</span></span><br><span class="line">                fullAddCount(x, uncontended);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 计算元素个数</span></span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">            <span class="comment">// 如果元素个数达到了扩容门槛，则进行扩容</span></span><br><span class="line">            <span class="comment">// 注意，正常情况下sizeCtl存储的是扩容门槛，即容量的0.75倍</span></span><br><span class="line">            <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="comment">// rs是扩容时的一个邮戳标识</span></span><br><span class="line">                <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">                <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// sc&lt;0说明正在扩容中</span></span><br><span class="line">                    <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                            sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                            transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="comment">// 扩容已经完成了，退出循环</span></span><br><span class="line">                        <span class="comment">// 正常应该只会触发nextTable==null这个条件，其它条件没看出来何时触发</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">                    <span class="comment">// 扩容未完成，则当前线程加入迁移元素中</span></span><br><span class="line">                    <span class="comment">// 并把扩容线程数加1</span></span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                        transfer(tab, nt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                        (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                    <span class="comment">// 这里是触发扩容的那个线程进入的地方</span></span><br><span class="line">                    <span class="comment">// sizeCtl的高16位存储着rs这个扩容邮戳</span></span><br><span class="line">                    <span class="comment">// sizeCtl的低16位存储着扩容线程数加1，即(1+nThreads)</span></span><br><span class="line">                    <span class="comment">// 所以官方说的扩容时sizeCtl的值为 -(1+nThreads)是错误的</span></span><br><span class="line">    </span><br><span class="line">                    <span class="comment">// 进入迁移元素</span></span><br><span class="line">                    transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">// 重新计算元素个数</span></span><br><span class="line">                s = sumCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）元素个数的存储方式类似于LongAdder类，存储在不同的段上，减少不同线程同时更新size时的冲突；</p>
<p>（2）计算元素个数时把这些段的值及baseCount相加算出总的元素个数；</p>
<p>（3）正常情况下sizeCtl存储着扩容门槛，扩容门槛为容量的0.75倍；</p>
<p>（4）扩容时sizeCtl高位存储扩容邮戳(resizeStamp)，低位存储扩容线程数加1（1+nThreads）；</p>
<p>（5）其它线程添加元素后如果发现存在扩容，也会加入的扩容行列中来；</p>
<p>2.线程添加元素时发现正在扩容且当前元素所在的桶元素已经迁移完成了，则协助迁移其它桶的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">        <span class="comment">// 如果桶数组不为空，并且当前桶第一个元素为ForwardingNode类型，并且nextTab不为空</span></span><br><span class="line">        <span class="comment">// 说明当前桶已经迁移完毕了，才去帮忙迁移其它桶的元素</span></span><br><span class="line">        <span class="comment">// 扩容时会把旧桶的第一个元素置为ForwardingNode，并让其nextTab指向新桶数组</span></span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">                (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">            <span class="comment">// sizeCtl&lt;0，说明正在扩容</span></span><br><span class="line">            <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">                    (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                        sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 扩容线程数加1</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 当前线程帮忙迁移元素</span></span><br><span class="line">                    transfer(tab, nextTab);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> nextTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前桶元素迁移完成了才去协助迁移其它桶元素；</p>
<p>3.扩容时容量变为两倍，并把部分元素迁移到其它桶中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">        <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">            stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">        <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">            <span class="comment">// 如果nextTab为空，说明还没开始迁移</span></span><br><span class="line">            <span class="comment">// 就新建一个新桶数组</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 新桶数组是原桶的两倍</span></span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                nextTab = nt;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">                sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nextTable = nextTab;</span><br><span class="line">            transferIndex = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新桶数组大小</span></span><br><span class="line">        <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">        <span class="comment">// 新建一个ForwardingNode类型的节点，并把新桶数组存储在里面</span></span><br><span class="line">        ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">        <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">            <span class="comment">// 整个while循环就是在算i的值，过程太复杂，不用太关心</span></span><br><span class="line">            <span class="comment">// i的值会从n-1依次递减，感兴趣的可以打下断点就知道了</span></span><br><span class="line">            <span class="comment">// 其中n是旧桶数组的大小，也就是说i从15开始一直减到1这样去迁移元素</span></span><br><span class="line">            <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">                <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    i = -<span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                        (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                                nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                        nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                    bound = nextBound;</span><br><span class="line">                    i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">                <span class="comment">// 如果一次遍历完成了</span></span><br><span class="line">                <span class="comment">// 也就是整个map所有桶中的元素都迁移完成了</span></span><br><span class="line">                <span class="keyword">int</span> sc;</span><br><span class="line">                <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                    <span class="comment">// 如果全部迁移完成了，则替换旧桶数组</span></span><br><span class="line">                    <span class="comment">// 并设置下一次扩容门槛为新桶数组容量的0.75倍</span></span><br><span class="line">                    nextTable = <span class="keyword">null</span>;</span><br><span class="line">                    table = nextTab;</span><br><span class="line">                    sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 当前线程扩容完成，把扩容线程数-1</span></span><br><span class="line">                    <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                        <span class="comment">// 扩容完成两边肯定相等</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    <span class="comment">// 把finishing设置为true</span></span><br><span class="line">                    <span class="comment">// finishing为true才会走到上面的if条件</span></span><br><span class="line">                    finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">// i重新赋值为n</span></span><br><span class="line">                    <span class="comment">// 这样会再重新遍历一次桶数组，看看是不是都迁移完成了</span></span><br><span class="line">                    <span class="comment">// 也就是第二次遍历都会走到下面的(fh = f.hash) == MOVED这个条件</span></span><br><span class="line">                    i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 如果桶中无数据，直接放入ForwardingNode标记该桶已迁移</span></span><br><span class="line">                advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                <span class="comment">// 如果桶中第一个元素的hash值为MOVED</span></span><br><span class="line">                <span class="comment">// 说明它是ForwardingNode节点</span></span><br><span class="line">                <span class="comment">// 也就是该桶已迁移</span></span><br><span class="line">                advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 锁定该桶并迁移元素</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="comment">// 再次判断当前桶第一个元素是否有修改</span></span><br><span class="line">                    <span class="comment">// 也就是可能其它线程先一步迁移了元素</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="comment">// 把一个链表分化成两个链表</span></span><br><span class="line">                        <span class="comment">// 规则是桶中各元素的hash与桶大小n进行与操作</span></span><br><span class="line">                        <span class="comment">// 等于0的放到低位链表(low)中，不等于0的放到高位链表(high)中</span></span><br><span class="line">                        <span class="comment">// 其中低位链表迁移到新桶中的位置相对旧桶不变</span></span><br><span class="line">                        <span class="comment">// 高位链表迁移到新桶中位置正好是其在旧桶的位置加n</span></span><br><span class="line">                        <span class="comment">// 这也正是为什么扩容时容量在变成两倍的原因</span></span><br><span class="line">                        Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 第一个元素的hash值大于等于0</span></span><br><span class="line">                            <span class="comment">// 说明该桶中元素是以链表形式存储的</span></span><br><span class="line">                            <span class="comment">// 这里与HashMap迁移算法基本类似</span></span><br><span class="line">                            <span class="comment">// 唯一不同的是多了一步寻找lastRun</span></span><br><span class="line">                            <span class="comment">// 这里的lastRun是提取出链表后面不用处理再特殊处理的子链表</span></span><br><span class="line">                            <span class="comment">// 比如所有元素的hash值与桶大小n与操作后的值分别为 0 0 4 4 0 0 0</span></span><br><span class="line">                            <span class="comment">// 则最后后面三个0对应的元素肯定还是在同一个桶中</span></span><br><span class="line">                            <span class="comment">// 这时lastRun对应的就是倒数第三个节点</span></span><br><span class="line">                            <span class="comment">// 至于为啥要这样处理，我也没太搞明白</span></span><br><span class="line">                            <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                            Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                                <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                    runBit = b;</span><br><span class="line">                                    lastRun = p;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 看看最后这几个元素归属于低位链表还是高位链表</span></span><br><span class="line">                            <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                                ln = lastRun;</span><br><span class="line">                                hn = <span class="keyword">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                hn = lastRun;</span><br><span class="line">                                ln = <span class="keyword">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 遍历链表，把hash&amp;n为0的放在低位链表中</span></span><br><span class="line">                            <span class="comment">// 不为0的放在高位链表中</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                                <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                    ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 低位链表的位置不变</span></span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            <span class="comment">// 高位链表的位置是原位置加n</span></span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            <span class="comment">// 标记当前桶已迁移</span></span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            <span class="comment">// advance为true，返回上面进行--i操作</span></span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            <span class="comment">// 如果第一个元素是树节点</span></span><br><span class="line">                            <span class="comment">// 也是一样，分化成两颗树</span></span><br><span class="line">                            <span class="comment">// 也是根据hash&amp;n为0放在低位树中</span></span><br><span class="line">                            <span class="comment">// 不为0放在高位树中</span></span><br><span class="line">                            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                            TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                            <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                            <span class="comment">// 遍历整颗树，根据hash&amp;n是否为0分化成两颗树</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                                TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                        (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                        lo = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        loTail.next = p;</span><br><span class="line">                                    loTail = p;</span><br><span class="line">                                    ++lc;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                        hi = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        hiTail.next = p;</span><br><span class="line">                                    hiTail = p;</span><br><span class="line">                                    ++hc;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 如果分化的树中元素个数小于等于6，则退化成链表</span></span><br><span class="line">                            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                                    (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                                    (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                            <span class="comment">// 低位树的位置不变</span></span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            <span class="comment">// 高位树的位置是原位置加n</span></span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            <span class="comment">// 标记该桶已迁移</span></span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            <span class="comment">// advance为true，返回上面进行--i操作</span></span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>（1）新桶数组大小是旧桶数组的两倍；</p>
<p>（2）迁移元素先从靠后的桶开始；</p>
<p>（3）迁移完成的桶在里面放置一ForwardingNode类型的元素，标记该桶迁移完成；</p>
<p>（4）迁移时根据hash&amp;n是否等于0把桶中元素分化成两个链表或树；</p>
<p>（5）低位链表（树）存储在原来的位置；</p>
<p>（6）高们链表（树）存储在原来的位置加n的位置；</p>
<p>（7）迁移元素时会锁住当前桶，也是分段锁的思想；</p>
<h2 id="ConcurrentHashMap的size-方法的实现知道多少？"><a href="#ConcurrentHashMap的size-方法的实现知道多少？" class="headerlink" title="ConcurrentHashMap的size()方法的实现知道多少？"></a>ConcurrentHashMap的size()方法的实现知道多少？</h2><p>元素个数的存储也是采用分段的思想，获取元素个数时需要把所有段加起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用sumCount()计算元素个数</span></span><br><span class="line">        <span class="keyword">long</span> n = sumCount();</span><br><span class="line">        <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">                (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">                        (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 计算CounterCell所有段及baseCount的数量之和</span></span><br><span class="line">        CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">        <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">        <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                    sum += a.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）元素的个数依据不同的线程存在在不同的段里；（见addCounter()分析）</p>
<p>（2）计算CounterCell所有段及baseCount的数量之和；</p>
<p>（3）获取元素个数没有加锁；</p>
<h2 id="ConcurrentHashMap是强一致性的吗？"><a href="#ConcurrentHashMap是强一致性的吗？" class="headerlink" title="ConcurrentHashMap是强一致性的吗？"></a>ConcurrentHashMap是强一致性的吗？</h2><p>查询操作是不会加锁的，所以ConcurrentHashMap不是强一致性的；</p>
<h2 id="ConcurrentHashMap不能解决什么问题？"><a href="#ConcurrentHashMap不能解决什么问题？" class="headerlink" title="ConcurrentHashMap不能解决什么问题？"></a>ConcurrentHashMap不能解决什么问题？</h2><p>ConcurrentHashMap中不能存储key或value为null的元素；</p>
<p>例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsafeUpdate</span><span class="params">(Integer key, Integer value)</span> </span>&#123;</span><br><span class="line">        Integer oldValue = map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (oldValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里如果有多个线程同时调用unsafeUpdate()这个方法，ConcurrentHashMap还能保证线程安全吗？</p>
<p>答案是不能。因为get()之后if之前可能有其它线程已经put()了这个元素，这时候再put()就把那个线程put()的元素覆盖了。</p>
<p>那怎么修改呢？</p>
<p>答案也很简单，使用putIfAbsent()方法，它会保证元素不存在时才插入元素，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">safeUpdate</span><span class="params">(Integer key, Integer value)</span> </span>&#123;</span><br><span class="line">        map.putIfAbsent(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，如果上面oldValue不是跟null比较，而是跟一个特定的值比如1进行比较怎么办？也就是下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsafeUpdate</span><span class="params">(Integer key, Integer value)</span> </span>&#123;</span><br><span class="line">        Integer oldValue = map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (oldValue == <span class="number">1</span>) &#123;</span><br><span class="line">            map.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话就没办法使用putIfAbsent()方法了。</p>
<p>其实，ConcurrentHashMap还提供了另一个方法叫replace(K key, V oldValue, V newValue)可以解决这个问题。</p>
<p>replace(K key, V oldValue, V newValue)这个方法可不能乱用，如果传入的newValue是null，则会删除元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">safeUpdate</span><span class="params">(Integer key, Integer value)</span> </span>&#123;</span><br><span class="line">        map.replace(key, <span class="number">1</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，如果if之后不是简单的put()操作，而是还有其它业务操作，之后才是put()，比如下面这样，这该怎么办呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsafeUpdate</span><span class="params">(Integer key, Integer value)</span> </span>&#123;</span><br><span class="line">        Integer oldValue = map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (oldValue == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis());</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 其它业务操作</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            System.out.println(System.currentTimeMillis());</span><br><span class="line">    </span><br><span class="line">            map.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候就没办法使用ConcurrentHashMap提供的方法了，只能业务自己来保证线程安全了，比如下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">safeUpdate</span><span class="params">(Integer key, Integer value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (map) &#123;</span><br><span class="line">            Integer oldValue = map.get(key);</span><br><span class="line">            <span class="keyword">if</span> (oldValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis());</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 其它业务操作</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                System.out.println(System.currentTimeMillis());</span><br><span class="line">    </span><br><span class="line">                map.put(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样虽然不太友好，但是最起码能保证业务逻辑是正确的。</p>
<p>当然，这里使用ConcurrentHashMap的意义也就不大了，可以换成普通的HashMap了。</p>
<p>上面只是举一个简单的例子，我们不能听说ConcurrentHashMap是线程安全的，就认为它无论什么情况下都是线程安全的，还是那句话尽信书不如无书。</p>
<h2 id="ConcurrentHashMap的sizeCtl知道吗"><a href="#ConcurrentHashMap的sizeCtl知道吗" class="headerlink" title="ConcurrentHashMap的sizeCtl知道吗?"></a>ConcurrentHashMap的sizeCtl知道吗?</h2><p>ConcurrentHashMap中没有threshold和loadFactor这两个字段，而是采用sizeCtl来控制；</p>
<p>sizeCtl = -1，表示正在进行初始化；</p>
<p>sizeCtl = 0，默认值，表示后续在真正初始化的时候使用默认容量；</p>
<p>sizeCtl &gt; 0，在初始化之前存储的是传入的容量，在初始化或扩容后存储的是下一次的扩容门槛；</p>
<p>sizeCtl = (resizeStamp &lt;&lt; 16) + (1 + nThreads)，表示正在进行扩容，高位存储扩容邮戳，低位存储扩容线程数加1；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">                MAXIMUM_CAPACITY :</span><br><span class="line">                tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">        putAll(m);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">            initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">        <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">        <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">        <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="ConcurrentHashMap中哪些地方运用到分段锁的思想？"><a href="#ConcurrentHashMap中哪些地方运用到分段锁的思想？" class="headerlink" title="ConcurrentHashMap中哪些地方运用到分段锁的思想？"></a>ConcurrentHashMap中哪些地方运用到分段锁的思想？</h2><p>分段锁，是一种锁的设计思路，它细化了锁的粒度，主要运用在ConcurrentHashMap中，实现高效的并发操作，当操作不需要更新整个数组时，就只锁数组中的一项就可以了。</p>
<h2 id="什么是伪共享？为何会出现伪共享-怎么避免伪共享？"><a href="#什么是伪共享？为何会出现伪共享-怎么避免伪共享？" class="headerlink" title="什么是伪共享？为何会出现伪共享?怎么避免伪共享？"></a>什么是伪共享？为何会出现伪共享?怎么避免伪共享？</h2><h3 id="什么是伪共享？"><a href="#什么是伪共享？" class="headerlink" title="什么是伪共享？"></a>什么是伪共享？</h3><p> 计算机系统中为了解决主内存与CPU运行速度的差距，在CPU与主内存之间添加了一级或者多级高速缓冲存储器（Cache），这个Cache一般是集成到CPU内部的，所以也叫 CPU Cache，如下图是两级cache结构：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210817175342.jpg" alt="img"></p>
<p>Cache内部是按行存储的，其中每一行称为一个cache行，cache行是Cache与主内存进行数据交换的单位，cache行的大小一般为2的幂次数字节。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210817175402.png" alt="img"></p>
<p>当CPU访问某一个变量时候，首先会去看CPU Cache内是否有该变量，如果有则直接从中获取，否者就去主内存里面获取该变量，然后把该变量所在内存区域的一个Cache行大小的内存拷贝到Cache（cache行是Cache与主内存进行数据交换的单位）。由于存放到Cache行的的是内存块而不是单个变量，所以可能会把多个变量存放到了一个cache行。当多个线程同时修改一个缓存行里面的多个变量时候，由于同时只能有一个线程操作缓存行，所以相比每个变量放到一个缓存行性能会有所下降，这就是伪共享。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210817175419.png" alt="img"></p>
<p> 如上图变量x,y同时被放到了CPU的一级和二级缓存，当线程1使用CPU1对变量x进行更新时候，首先会修改cpu1的一级缓存变量x所在缓存行，这时候缓存一致性协议会导致cpu2中变量x对应的缓存行失效，那么线程2写入变量x的时候就只能去二级缓存去查找，这就破坏了一级缓存，而一级缓存比二级缓存更快。更坏的情况下如果cpu只有一级缓存，那么会导致频繁的直接访问主内存。</p>
<h3 id="为何会出现伪共享"><a href="#为何会出现伪共享" class="headerlink" title="为何会出现伪共享"></a>为何会出现伪共享</h3><p> 伪共享的产生是因为多个变量被放入了一个缓存行，并且多个线程同时去写入缓存行中不同变量。那么为何多个变量会被放入一个缓存行那。其实是因为Cache与内存交换数据的单位就是Cache，当CPU要访问的变量没有在Cache命中时候，根据程序运行的局部性原理会把该变量在内存中大小为Cache行的内存放如缓存行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> a;</span><br><span class="line"><span class="keyword">long</span> b;</span><br><span class="line"><span class="keyword">long</span> c;</span><br><span class="line"><span class="keyword">long</span> d;</span><br></pre></td></tr></table></figure>

<p> 如上代码，声明了四个long变量，假设cache行的大小为32个字节，那么当cpu访问变量a时候发现该变量没有在cache命中，那么就会去主内存把变量a以及内存地址附近的b,c,d放入缓存行。也就是地址连续的多个变量才有可能会被放到一个缓存行中，当创建数组时候，数组里面的多个元素就会被放入到同一个缓存行。那么单线程下多个变量放入缓存行对性能有影响？其实正常情况下单线程访问时候由于数组元素被放入到了一个或者多个cache行对代码执行是有利的，因为数据都在缓存中，代码执行会更快。</p>
<h4 id="如何解决伪共享"><a href="#如何解决伪共享" class="headerlink" title="如何解决伪共享"></a>如何解决伪共享</h4><p>@Contended注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Contended &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Contended注解可以用于类型上和属性上，加上这个注解之后虚拟机会自动进行填充，从而避免伪共享。这个注解在Java8 ConcurrentHashMap、ForkJoinPool和Thread等类中都有应用。我们来看一下Java8中ConcurrentHashMap中如何运用Contended这个注解来解决伪共享问题。以下说的ConcurrentHashMap都是Java8版本。</p>
<p><strong>注意</strong>：在Java8中提供了**@sun.misc.Contended<strong>来避免伪共享时，在运行时需要设置JVM启动参数</strong>-XX:-RestrictContended**否则可能不生效。</p>
<p>缓存行填充的威力</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存行测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheLineTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否启用缓存行填充</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isDataPadding = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正常定义的变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> z = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过缓存行填充的变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> VolatileData volatileDataX = <span class="keyword">new</span> VolatileData(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> VolatileData volatileDataY = <span class="keyword">new</span> VolatileData(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> VolatileData volatileDataZ = <span class="keyword">new</span> VolatileData(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 循环次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> size = <span class="number">100000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行累加操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accumulationX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//计算耗时</span></span><br><span class="line">        <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//循环累加</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">//使用缓存行填充的方式</span></span><br><span class="line">            <span class="keyword">if</span> (isDataPadding) &#123;</span><br><span class="line">                value = volatileDataX.accumulationAdd();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//不使用缓存行填充的方式 因为时单线程操作不需要加锁</span></span><br><span class="line">                value = (++x);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印</span></span><br><span class="line">        System.out.println(value);</span><br><span class="line">        <span class="comment">//打印耗时</span></span><br><span class="line">        System.out.println(<span class="string">&quot;耗时：&quot;</span> + (System.currentTimeMillis() - currentTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行累加操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accumulationY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isDataPadding) &#123;</span><br><span class="line">                value = volatileDataY.accumulationAdd();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value = ++y;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时：&quot;</span> + (System.currentTimeMillis() - currentTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行累加操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accumulationZ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isDataPadding) &#123;</span><br><span class="line">                value = volatileDataZ.accumulationAdd();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value = ++z;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时：&quot;</span> + (System.currentTimeMillis() - currentTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        CacheLineTest cacheRowTest = <span class="keyword">new</span> CacheLineTest();</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//启动三个线程个调用他们各自的方法</span></span><br><span class="line">        executorService.execute(() -&gt; cacheRowTest.accumulationX());</span><br><span class="line">        executorService.execute(() -&gt; cacheRowTest.accumulationY());</span><br><span class="line">        executorService.execute(() -&gt; cacheRowTest.accumulationZ());</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 当多个线程同时对共享的缓存行进行写操作的时候，因为缓存系统自身的缓存一致性原则，会引发伪共享问题，解决的常用办法是将共享变量根据缓存行大小进行补充对齐，使其加载到缓存时能够独享缓存行，避免与其他共享变量存储在同一个缓存行。</p>
<h2 id="什么是跳表？"><a href="#什么是跳表？" class="headerlink" title="什么是跳表？"></a>什么是跳表？</h2><p>跳表是一个随机化的数据结构，实质就是一种可以进行<strong>二分</strong>查找的<strong>有序链表</strong>。</p>
<p>跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。</p>
<p>跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210817181502" alt="图片"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据节点，典型的单链表结构</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       <span class="comment">// 注意：这里value的类型是Object，而不是V</span></span><br><span class="line">       <span class="comment">// 在删除元素的时候value会指向当前元素本身</span></span><br><span class="line">       <span class="keyword">volatile</span> Object value;</span><br><span class="line">       <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">   </span><br><span class="line">       Node(K key, Object value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       Node(Node&lt;K,V&gt; next) &#123;</span><br><span class="line">           <span class="keyword">this</span>.key = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">this</span>.value = <span class="keyword">this</span>; <span class="comment">// 当前元素本身(marker)</span></span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 索引节点，存储着对应的node值，及向下和向右的索引指针</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;K,V&gt; node;</span><br><span class="line">       <span class="keyword">final</span> Index&lt;K,V&gt; down;</span><br><span class="line">       <span class="keyword">volatile</span> Index&lt;K,V&gt; right;</span><br><span class="line">   </span><br><span class="line">       Index(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right) &#123;</span><br><span class="line">           <span class="keyword">this</span>.node = node;</span><br><span class="line">           <span class="keyword">this</span>.down = down;</span><br><span class="line">           <span class="keyword">this</span>.right = right;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 头索引节点，继承自Index，并扩展一个level字段，用于记录索引的层级</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadIndex</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Index</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> level;</span><br><span class="line">   </span><br><span class="line">       HeadIndex(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right, <span class="keyword">int</span> level) &#123;</span><br><span class="line">           <span class="keyword">super</span>(node, down, right);</span><br><span class="line">           <span class="keyword">this</span>.level = level;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>（1）Node，数据节点，存储数据的节点，典型的单链表结构；</p>
<p>（2）Index，索引节点，存储着对应的node值，及向下和向右的索引指针；</p>
<p>（3）HeadIndex，头索引节点，继承自Index，并扩展一个level字段，用于记录索引的层级；</p>
<h2 id="ConcurrentSkipList是有序的吗？"><a href="#ConcurrentSkipList是有序的吗？" class="headerlink" title="ConcurrentSkipList是有序的吗？"></a>ConcurrentSkipList是有序的吗？</h2><p>ConcurrentSkipListMap 的key是有序的。</p>
<h2 id="ConcurrentSkipList是如何保证线程安全的？"><a href="#ConcurrentSkipList是如何保证线程安全的？" class="headerlink" title="ConcurrentSkipList是如何保证线程安全的？"></a>ConcurrentSkipList是如何保证线程安全的？</h2><h2 id="ConcurrentSkipList插入、删除、查询元素的时间复杂度各是多少？"><a href="#ConcurrentSkipList插入、删除、查询元素的时间复杂度各是多少？" class="headerlink" title="ConcurrentSkipList插入、删除、查询元素的时间复杂度各是多少？"></a>ConcurrentSkipList插入、删除、查询元素的时间复杂度各是多少？</h2><p>跳表查询、插入、删除的时间复杂度为O(log n)，与平衡二叉树接近；</p>
<h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不能存储value为null的元素</span></span><br><span class="line">        <span class="comment">// 因为value为null标记该元素被删除（后面会看到）</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 调用doPut()方法添加元素</span></span><br><span class="line">        <span class="keyword">return</span> doPut(key, value, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">doPut</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 添加元素后存储在z中</span></span><br><span class="line">        Node&lt;K,V&gt; z;             <span class="comment">// added node</span></span><br><span class="line">        <span class="comment">// key也不能为null</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Part I：找到目标节点的位置并插入</span></span><br><span class="line">        <span class="comment">// 这里的目标节点是数据节点，也就是最底层的那条链</span></span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 寻找目标节点之前最近的一个索引对应的数据节点，存储在b中，b=before</span></span><br><span class="line">            <span class="comment">// 并把b的下一个数据节点存储在n中，n=next</span></span><br><span class="line">            <span class="comment">// 为了便于描述，我这里把b叫做当前节点，n叫做下一个节点</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">                <span class="comment">// 如果下一个节点不为空</span></span><br><span class="line">                <span class="comment">// 就拿其key与目标节点的key比较，找到目标节点应该插入的位置</span></span><br><span class="line">                <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// v=value，存储节点value值</span></span><br><span class="line">                    <span class="comment">// c=compare，存储两个节点比较的大小</span></span><br><span class="line">                    Object v; <span class="keyword">int</span> c;</span><br><span class="line">                    <span class="comment">// n的下一个数据节点，也就是b的下一个节点的下一个节点（孙子节点）</span></span><br><span class="line">                    Node&lt;K,V&gt; f = n.next;</span><br><span class="line">                    <span class="comment">// 如果n不为b的下一个节点</span></span><br><span class="line">                    <span class="comment">// 说明有其它线程修改了数据，则跳出内层循环</span></span><br><span class="line">                    <span class="comment">// 也就是回到了外层循环自旋的位置，从头来过</span></span><br><span class="line">                    <span class="keyword">if</span> (n != b.next)               <span class="comment">// inconsistent read</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 如果n的value值为空，说明该节点已删除，协助删除节点</span></span><br><span class="line">                    <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;   <span class="comment">// n is deleted</span></span><br><span class="line">                        <span class="comment">// todo 这里为啥会协助删除？后面讲</span></span><br><span class="line">                        n.helpDelete(b, f);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果b的值为空或者v等于n，说明b已被删除</span></span><br><span class="line">                    <span class="comment">// 这时候n就是marker节点，那b就是被删除的那个</span></span><br><span class="line">                    <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n) <span class="comment">// b is deleted</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 如果目标key与下一个节点的key大</span></span><br><span class="line">                    <span class="comment">// 说明目标元素所在的位置还在下一个节点的后面</span></span><br><span class="line">                    <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 就把当前节点往后移一位</span></span><br><span class="line">                        <span class="comment">// 同样的下一个节点也往后移一位</span></span><br><span class="line">                        <span class="comment">// 再重新检查新n是否为空，它与目标key的关系</span></span><br><span class="line">                        b = n;</span><br><span class="line">                        n = f;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果比较时发现下一个节点的key与目标key相同</span></span><br><span class="line">                    <span class="comment">// 说明链表中本身就存在目标节点</span></span><br><span class="line">                    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 则用新值替换旧值，并返回旧值（onlyIfAbsent=false）</span></span><br><span class="line">                        <span class="keyword">if</span> (onlyIfAbsent || n.casValue(v, value)) &#123;</span><br><span class="line">                            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> V vv = (V)v;</span><br><span class="line">                            <span class="keyword">return</span> vv;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果替换旧值时失败，说明其它线程先一步修改了值，从头来过</span></span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// restart if lost race to replace value</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果c&lt;0，就往下走，也就是找到了目标节点的位置</span></span><br><span class="line">                    <span class="comment">// else c &lt; 0; fall through</span></span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                <span class="comment">// 有两种情况会到这里</span></span><br><span class="line">                <span class="comment">// 一是到链表尾部了，也就是n为null了</span></span><br><span class="line">                <span class="comment">// 二是找到了目标节点的位置，也就是上面的c&lt;0</span></span><br><span class="line">    </span><br><span class="line">                <span class="comment">// 新建目标节点，并赋值给z</span></span><br><span class="line">                <span class="comment">// 这里把n作为新节点的next</span></span><br><span class="line">                <span class="comment">// 如果到链表尾部了，n为null，这毫无疑问</span></span><br><span class="line">                <span class="comment">// 如果c&lt;0，则n的key比目标key大，相妆于在b和n之间插入目标节点z</span></span><br><span class="line">                z = <span class="keyword">new</span> Node&lt;K,V&gt;(key, value, n);</span><br><span class="line">                <span class="comment">// 原子更新b的下一个节点为目标节点z</span></span><br><span class="line">                <span class="keyword">if</span> (!b.casNext(n, z))</span><br><span class="line">                    <span class="comment">// 如果更新失败，说明其它线程先一步修改了值，从头来过</span></span><br><span class="line">                    <span class="keyword">break</span>;         <span class="comment">// restart if lost race to append to b</span></span><br><span class="line">                <span class="comment">// 如果更新成功，跳出自旋状态</span></span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 经过Part I，目标节点已经插入到有序链表中了</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Part II：随机决定是否需要建立索引及其层次，如果需要则建立自上而下的索引</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 取个随机数</span></span><br><span class="line">        <span class="keyword">int</span> rnd = ThreadLocalRandom.nextSecondarySeed();</span><br><span class="line">        <span class="comment">// 0x80000001展开为二进制为10000000000000000000000000000001</span></span><br><span class="line">        <span class="comment">// 只有两头是1</span></span><br><span class="line">        <span class="comment">// 这里(rnd &amp; 0x80000001) == 0</span></span><br><span class="line">        <span class="comment">// 相当于排除了负数（负数最高位是1），排除了奇数（奇数最低位是1）</span></span><br><span class="line">        <span class="comment">// 只有最高位最低位都不为1的数跟0x80000001做&amp;操作才会为0</span></span><br><span class="line">        <span class="comment">// 也就是正偶数</span></span><br><span class="line">        <span class="keyword">if</span> ((rnd &amp; <span class="number">0x80000001</span>) == <span class="number">0</span>) &#123; <span class="comment">// test highest and lowest bits</span></span><br><span class="line">            <span class="comment">// 默认level为1，也就是只要到这里了就会至少建立一层索引</span></span><br><span class="line">            <span class="keyword">int</span> level = <span class="number">1</span>, max;</span><br><span class="line">            <span class="comment">// 随机数从最低位的第二位开始，有几个连续的1则level就加几</span></span><br><span class="line">            <span class="comment">// 因为最低位肯定是0，正偶数嘛</span></span><br><span class="line">            <span class="comment">// 比如，1100110，level就加2</span></span><br><span class="line">            <span class="keyword">while</span> (((rnd &gt;&gt;&gt;= <span class="number">1</span>) &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">                ++level;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 用于记录目标节点建立的最高的那层索引节点</span></span><br><span class="line">            Index&lt;K,V&gt; idx = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 取头索引节点（这是最高层的头索引节点）</span></span><br><span class="line">            HeadIndex&lt;K,V&gt; h = head;</span><br><span class="line">            <span class="comment">// 如果生成的层数小于等于当前最高层的层级</span></span><br><span class="line">            <span class="comment">// 也就是跳表的高度不会超过现有高度</span></span><br><span class="line">            <span class="keyword">if</span> (level &lt;= (max = h.level)) &#123;</span><br><span class="line">                <span class="comment">// 从第一层开始建立一条竖直的索引链表</span></span><br><span class="line">                <span class="comment">// 这条链表使用down指针连接起来</span></span><br><span class="line">                <span class="comment">// 每个索引节点里面都存储着目标节点这个数据节点</span></span><br><span class="line">                <span class="comment">// 最后idx存储的是这条索引链表的最高层节点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">                    idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// try to grow by one level</span></span><br><span class="line">                <span class="comment">// 如果新的层数超过了现有跳表的高度</span></span><br><span class="line">                <span class="comment">// 则最多只增加一层</span></span><br><span class="line">                <span class="comment">// 比如现在只有一层索引，那下一次最多增加到两层索引，增加多了也没有意义</span></span><br><span class="line">                level = max + <span class="number">1</span>; <span class="comment">// hold in array and later pick the one to use</span></span><br><span class="line">                <span class="comment">// idxs用于存储目标节点建立的竖起索引的所有索引节点</span></span><br><span class="line">                <span class="comment">// 其实这里直接使用idx这个最高节点也是可以完成的</span></span><br><span class="line">                <span class="comment">// 只是用一个数组存储所有节点要方便一些</span></span><br><span class="line">                <span class="comment">// 注意，这里数组0号位是没有使用的</span></span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span>Index&lt;K,V&gt;[] idxs =</span><br><span class="line">                        (Index&lt;K,V&gt;[])<span class="keyword">new</span> Index&lt;?,?&gt;[level+<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 从第一层开始建立一条竖的索引链表（跟上面一样，只是这里顺便把索引节点放到数组里面了）</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">                    idxs[i] = idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>);</span><br><span class="line">    </span><br><span class="line">                <span class="comment">// 自旋</span></span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    <span class="comment">// 旧的最高层头索引节点</span></span><br><span class="line">                    h = head;</span><br><span class="line">                    <span class="comment">// 旧的最高层级</span></span><br><span class="line">                    <span class="keyword">int</span> oldLevel = h.level;</span><br><span class="line">                    <span class="comment">// 再次检查，如果旧的最高层级已经不比新层级矮了</span></span><br><span class="line">                    <span class="comment">// 说明有其它线程先一步修改了值，从头来过</span></span><br><span class="line">                    <span class="keyword">if</span> (level &lt;= oldLevel) <span class="comment">// lost race to add level</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 新的最高层头索引节点</span></span><br><span class="line">                    HeadIndex&lt;K,V&gt; newh = h;</span><br><span class="line">                    <span class="comment">// 头节点指向的数据节点</span></span><br><span class="line">                    Node&lt;K,V&gt; oldbase = h.node;</span><br><span class="line">                    <span class="comment">// 超出的部分建立新的头索引节点</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = oldLevel+<span class="number">1</span>; j &lt;= level; ++j)</span><br><span class="line">                        newh = <span class="keyword">new</span> HeadIndex&lt;K,V&gt;(oldbase, newh, idxs[j], j);</span><br><span class="line">                    <span class="comment">// 原子更新头索引节点</span></span><br><span class="line">                    <span class="keyword">if</span> (casHead(h, newh)) &#123;</span><br><span class="line">                        <span class="comment">// h指向新的最高层头索引节点</span></span><br><span class="line">                        h = newh;</span><br><span class="line">                        <span class="comment">// 把level赋值为旧的最高层级的</span></span><br><span class="line">                        <span class="comment">// idx指向的不是最高的索引节点了</span></span><br><span class="line">                        <span class="comment">// 而是与旧最高层平齐的索引节点</span></span><br><span class="line">                        idx = idxs[level = oldLevel];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 经过上面的步骤，有两种情况</span></span><br><span class="line">            <span class="comment">// 一是没有超出高度，新建一条目标节点的索引节点链</span></span><br><span class="line">            <span class="comment">// 二是超出了高度，新建一条目标节点的索引节点链，同时最高层头索引节点同样往上长</span></span><br><span class="line">    </span><br><span class="line">            <span class="comment">// Part III：将新建的索引节点（包含头索引节点）与其它索引节点通过右指针连接在一起</span></span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 这时level是等于旧的最高层级的，自旋</span></span><br><span class="line">            splice: <span class="keyword">for</span> (<span class="keyword">int</span> insertionLevel = level;;) &#123;</span><br><span class="line">                <span class="comment">// h为最高头索引节点</span></span><br><span class="line">                <span class="keyword">int</span> j = h.level;</span><br><span class="line">    </span><br><span class="line">                <span class="comment">// 从头索引节点开始遍历</span></span><br><span class="line">                <span class="comment">// 为了方便，这里叫q为当前节点，r为右节点，d为下节点，t为目标节点相应层级的索引</span></span><br><span class="line">                <span class="keyword">for</span> (Index&lt;K,V&gt; q = h, r = q.right, t = idx;;) &#123;</span><br><span class="line">                    <span class="comment">// 如果遍历到了最右边，或者最下边，</span></span><br><span class="line">                    <span class="comment">// 也就是遍历到头了，则退出外层循环</span></span><br><span class="line">                    <span class="keyword">if</span> (q == <span class="keyword">null</span> || t == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">break</span> splice;</span><br><span class="line">                    <span class="comment">// 如果右节点不为空</span></span><br><span class="line">                    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// n是右节点的数据节点，为了方便，这里直接叫右节点的值</span></span><br><span class="line">                        Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                        <span class="comment">// 比较目标key与右节点的值</span></span><br><span class="line">                        <span class="keyword">int</span> c = cpr(cmp, key, n.key);</span><br><span class="line">                        <span class="comment">// 如果右节点的值为空了，则表示此节点已删除</span></span><br><span class="line">                        <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 则把右节点删除</span></span><br><span class="line">                            <span class="keyword">if</span> (!q.unlink(r))</span><br><span class="line">                                <span class="comment">// 如果删除失败，说明有其它线程先一步修改了，从头来过</span></span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="comment">// 删除成功后重新取右节点</span></span><br><span class="line">                            r = q.right;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果比较c&gt;0，表示目标节点还要往右</span></span><br><span class="line">                        <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 则把当前节点和右节点分别右移</span></span><br><span class="line">                            q = r;</span><br><span class="line">                            r = r.right;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">    </span><br><span class="line">                    <span class="comment">// 到这里说明已经到当前层级的最右边了</span></span><br><span class="line">                    <span class="comment">// 这里实际是会先走第二个if</span></span><br><span class="line">    </span><br><span class="line">                    <span class="comment">// 第一个if</span></span><br><span class="line">                    <span class="comment">// j与insertionLevel相等了</span></span><br><span class="line">                    <span class="comment">// 实际是先走的第二个if，j自减后应该与insertionLevel相等</span></span><br><span class="line">                    <span class="keyword">if</span> (j == insertionLevel) &#123;</span><br><span class="line">                        <span class="comment">// 这里是真正连右指针的地方</span></span><br><span class="line">                        <span class="keyword">if</span> (!q.link(r, t))</span><br><span class="line">                            <span class="comment">// 连接失败，从头来过</span></span><br><span class="line">                            <span class="keyword">break</span>; <span class="comment">// restart</span></span><br><span class="line">                        <span class="comment">// t节点的值为空，可能是其它线程删除了这个元素</span></span><br><span class="line">                        <span class="keyword">if</span> (t.node.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 这里会去协助删除元素</span></span><br><span class="line">                            findNode(key);</span><br><span class="line">                            <span class="keyword">break</span> splice;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 当前层级右指针连接完毕，向下移一层继续连接</span></span><br><span class="line">                        <span class="comment">// 如果移到了最下面一层，则说明都连接完成了，退出外层循环</span></span><br><span class="line">                        <span class="keyword">if</span> (--insertionLevel == <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">break</span> splice;</span><br><span class="line">                    &#125;</span><br><span class="line">    </span><br><span class="line">                    <span class="comment">// 第二个if</span></span><br><span class="line">                    <span class="comment">// j先自减1，再与两个level比较</span></span><br><span class="line">                    <span class="comment">// j、insertionLevel和t(idx)三者是对应的，都是还未把右指针连好的那个层级</span></span><br><span class="line">                    <span class="keyword">if</span> (--j &gt;= insertionLevel &amp;&amp; j &lt; level)</span><br><span class="line">                        <span class="comment">// t往下移</span></span><br><span class="line">                        t = t.down;</span><br><span class="line">    </span><br><span class="line">                    <span class="comment">// 当前层级到最右边了</span></span><br><span class="line">                    <span class="comment">// 那只能往下一层级去走了</span></span><br><span class="line">                    <span class="comment">// 当前节点下移</span></span><br><span class="line">                    <span class="comment">// 再取相应的右节点</span></span><br><span class="line">                    q = q.down;</span><br><span class="line">                    r = q.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找目标节点之前最近的一个索引对应的数据节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node&lt;K,V&gt; <span class="title">findPredecessor</span><span class="params">(Object key, Comparator&lt;? <span class="keyword">super</span> K&gt; cmp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// key不能为空</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// don&#x27;t postpone errors</span></span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 从最高层头索引节点开始查找，先向右，再向下</span></span><br><span class="line">            <span class="comment">// 直到找到目标位置之前的那个索引</span></span><br><span class="line">            <span class="keyword">for</span> (Index&lt;K,V&gt; q = head, r = q.right, d;;) &#123;</span><br><span class="line">                <span class="comment">// 如果右节点不为空</span></span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 右节点对应的数据节点，为了方便，我们叫右节点的值</span></span><br><span class="line">                    Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                    K k = n.key;</span><br><span class="line">                    <span class="comment">// 如果右节点的value为空</span></span><br><span class="line">                    <span class="comment">// 说明其它线程把这个节点标记为删除了</span></span><br><span class="line">                    <span class="comment">// 则协助删除</span></span><br><span class="line">                    <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!q.unlink(r))</span><br><span class="line">                            <span class="comment">// 如果删除失败</span></span><br><span class="line">                            <span class="comment">// 说明其它线程先删除了，从头来过</span></span><br><span class="line">                            <span class="keyword">break</span>;           <span class="comment">// restart</span></span><br><span class="line">                        <span class="comment">// 删除之后重新读取右节点</span></span><br><span class="line">                        r = q.right;         <span class="comment">// reread r</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果目标key比右节点还大，继续向右寻找</span></span><br><span class="line">                    <span class="keyword">if</span> (cpr(cmp, key, k) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 往右移</span></span><br><span class="line">                        q = r;</span><br><span class="line">                        <span class="comment">// 重新取右节点</span></span><br><span class="line">                        r = r.right;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果c&lt;0，说明不能再往右了</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 到这里说明当前层级已经到最右了</span></span><br><span class="line">                <span class="comment">// 两种情况：一是r==null，二是c&lt;0</span></span><br><span class="line">                <span class="comment">// 再从下一级开始找</span></span><br><span class="line">    </span><br><span class="line">                <span class="comment">// 如果没有下一级了，就返回这个索引对应的数据节点</span></span><br><span class="line">                <span class="keyword">if</span> ((d = q.down) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> q.node;</span><br><span class="line">    </span><br><span class="line">                <span class="comment">// 往下移</span></span><br><span class="line">                q = d;</span><br><span class="line">                <span class="comment">// 重新取右节点</span></span><br><span class="line">                r = d.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Node.class中的方法，协助删除元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helpDelete</span><span class="params">(Node&lt;K,V&gt; b, Node&lt;K,V&gt; f)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Rechecking links and then doing only one of the</span></span><br><span class="line"><span class="comment">         * help-out stages per call tends to minimize CAS</span></span><br><span class="line"><span class="comment">         * interference among helping threads.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 这里的调用者this==n，三者关系是b-&gt;n-&gt;f</span></span><br><span class="line">        <span class="keyword">if</span> (f == next &amp;&amp; <span class="keyword">this</span> == b.next) &#123;</span><br><span class="line">            <span class="comment">// 将n的值设置为null后，会先把n的下个节点设置为marker节点</span></span><br><span class="line">            <span class="comment">// 这个marker节点的值是它自己</span></span><br><span class="line">            <span class="comment">// 这里如果不是它自己说明marker失败了，重新marker</span></span><br><span class="line">            <span class="keyword">if</span> (f == <span class="keyword">null</span> || f.value != f) <span class="comment">// not already marked</span></span><br><span class="line">                casNext(f, <span class="keyword">new</span> Node&lt;K,V&gt;(f));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// marker过了，就把b的下个节点指向marker的下个节点</span></span><br><span class="line">                b.casNext(<span class="keyword">this</span>, f.next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Index.class中的方法，删除succ节点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">unlink</span><span class="params">(Index&lt;K,V&gt; succ)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 原子更新当前节点指向下一个节点的下一个节点</span></span><br><span class="line">        <span class="comment">// 也就是删除下一个节点</span></span><br><span class="line">        <span class="keyword">return</span> node.value != <span class="keyword">null</span> &amp;&amp; casRight(succ, succ.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Index.class中的方法，在当前节点与succ之间插入newSucc节点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">link</span><span class="params">(Index&lt;K,V&gt; succ, Index&lt;K,V&gt; newSucc)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在当前节点与下一个节点中间插入一个节点</span></span><br><span class="line">        Node&lt;K,V&gt; n = node;</span><br><span class="line">        <span class="comment">// 新节点指向当前节点的下一个节点</span></span><br><span class="line">        newSucc.right = succ;</span><br><span class="line">        <span class="comment">// 原子更新当前节点的下一个节点指向新节点</span></span><br><span class="line">        <span class="keyword">return</span> n.value != <span class="keyword">null</span> &amp;&amp; casRight(succ, newSucc);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们这里把整个插入过程分成三个部分：</p>
<p>Part I：找到目标节点的位置并插入</p>
<p>（1）这里的目标节点是数据节点，也就是最底层的那条链；</p>
<p>（2）寻找目标节点之前最近的一个索引对应的数据节点（数据节点都是在最底层的链表上）；</p>
<p>（3）从这个数据节点开始往后遍历，直到找到目标节点应该插入的位置；</p>
<p>（4）如果这个位置有元素，就更新其值（onlyIfAbsent=false）；</p>
<p>（5）如果这个位置没有元素，就把目标节点插入；</p>
<p>（6）至此，目标节点已经插入到最底层的数据节点链表中了；</p>
<p>Part II：随机决定是否需要建立索引及其层次，如果需要则建立自上而下的索引</p>
<p>（1）取个随机数rnd，计算(rnd &amp; 0x80000001)；</p>
<p>（2）如果不等于0，结束插入过程，也就是不需要创建索引，返回；</p>
<p>（3）如果等于0，才进入创建索引的过程（只要正偶数才会等于0）；</p>
<p>（4）计算<code>while (((rnd &gt;&gt;&gt;= 1) &amp; 1) != 0)</code>，决定层级数，level从1开始；</p>
<p>（5）如果算出来的层级不高于现有最高层级，则直接建立一条竖直的索引链表（只有down有值），并结束Part II；</p>
<p>（6）如果算出来的层级高于现有最高层级，则新的层级只能比现有最高层级多1；</p>
<p>（7）同样建立一条竖直的索引链表（只有down有值）；</p>
<p>（8）将头索引也向上增加到相应的高度，结束Part II；</p>
<p>（9）也就是说，如果层级不超过现有高度，只建立一条索引链，否则还要额外增加头索引链的高度（脑补一下，后面举例说明）；</p>
<p>Part III：将新建的索引节点（包含头索引节点）与其它索引节点通过右指针连接在一起（补上right指针）</p>
<p>（1）从最高层级的头索引节点开始，向右遍历，找到目标索引节点的位置；</p>
<p>（2）如果当前层有目标索引，则把目标索引插入到这个位置，并把目标索引前一个索引向下移一个层级；</p>
<p>（3）如果当前层没有目标索引，则把目标索引位置前一个索引向下移一个层级；</p>
<p>（4）同样地，再向右遍历，寻找新的层级中目标索引的位置，回到第（2）步；</p>
<p>（5）依次循环找到所有层级目标索引的位置并把它们插入到横向的索引链表中；</p>
<p>总结起来，一共就是三大步：</p>
<p>（1）插入目标节点到数据节点链表中；</p>
<p>（2）建立竖直的down链表；</p>
<p>（3）建立横向的right链表；</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> doRemove(key, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">doRemove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// key不为空</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 寻找目标节点之前的最近的索引节点对应的数据节点</span></span><br><span class="line">            <span class="comment">// 为了方便，这里叫b为当前节点，n为下一个节点，f为下下个节点</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">                Object v; <span class="keyword">int</span> c;</span><br><span class="line">                <span class="comment">// 整个链表都遍历完了也没找到目标节点，退出外层循环</span></span><br><span class="line">                <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span> outer;</span><br><span class="line">                <span class="comment">// 下下个节点</span></span><br><span class="line">                Node&lt;K,V&gt; f = n.next;</span><br><span class="line">                <span class="comment">// 再次检查</span></span><br><span class="line">                <span class="comment">// 如果n不是b的下一个节点了</span></span><br><span class="line">                <span class="comment">// 说明有其它线程先一步修改了，从头来过</span></span><br><span class="line">                <span class="keyword">if</span> (n != b.next)                    <span class="comment">// inconsistent read</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 如果下个节点的值奕为null了</span></span><br><span class="line">                <span class="comment">// 说明有其它线程标记该元素为删除状态了</span></span><br><span class="line">                <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;        <span class="comment">// n is deleted</span></span><br><span class="line">                    <span class="comment">// 协助删除</span></span><br><span class="line">                    n.helpDelete(b, f);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果b的值为空或者v等于n，说明b已被删除</span></span><br><span class="line">                <span class="comment">// 这时候n就是marker节点，那b就是被删除的那个</span></span><br><span class="line">                <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)      <span class="comment">// b is deleted</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 如果c&lt;0，说明没找到元素，退出外层循环</span></span><br><span class="line">                <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span> outer;</span><br><span class="line">                <span class="comment">// 如果c&gt;0，说明还没找到，继续向右找</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 当前节点往后移</span></span><br><span class="line">                    b = n;</span><br><span class="line">                    <span class="comment">// 下一个节点往后移</span></span><br><span class="line">                    n = f;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// c=0，说明n就是要找的元素</span></span><br><span class="line">                <span class="comment">// 如果value不为空且不等于找到元素的value，不需要删除，退出外层循环</span></span><br><span class="line">                <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; !value.equals(v))</span><br><span class="line">                    <span class="keyword">break</span> outer;</span><br><span class="line">                <span class="comment">// 如果value为空，或者相等</span></span><br><span class="line">                <span class="comment">// 原子标记n的value值为空</span></span><br><span class="line">                <span class="keyword">if</span> (!n.casValue(v, <span class="keyword">null</span>))</span><br><span class="line">                    <span class="comment">// 如果删除失败，说明其它线程先一步修改了，从头来过</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">                <span class="comment">// P.S.到了这里n的值肯定是设置成null了</span></span><br><span class="line">    </span><br><span class="line">                <span class="comment">// 关键！！！！</span></span><br><span class="line">                <span class="comment">// 让n的下一个节点指向一个market节点</span></span><br><span class="line">                <span class="comment">// 这个market节点的key为null，value为marker自己，next为n的下个节点f</span></span><br><span class="line">                <span class="comment">// 或者让b的下一个节点指向下下个节点</span></span><br><span class="line">                <span class="comment">// 注意：这里是或者||，因为两个CAS不能保证都成功，只能一个一个去尝试</span></span><br><span class="line">                <span class="comment">// 这里有两层意思：</span></span><br><span class="line">                <span class="comment">// 一是如果标记market成功，再尝试将b的下个节点指向下下个节点，如果第二步失败了，进入条件，如果成功了就不用进入条件了</span></span><br><span class="line">                <span class="comment">// 二是如果标记market失败了，直接进入条件</span></span><br><span class="line">                <span class="keyword">if</span> (!n.appendMarker(f) || !b.casNext(n, f))</span><br><span class="line">                    <span class="comment">// 通过findNode()重试删除（里面有个helpDelete()方法）</span></span><br><span class="line">                    findNode(key);                  <span class="comment">// retry via findNode</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 上面两步操作都成功了，才会进入这里，不太好理解，上面两个条件都有非&quot;!&quot;操作</span></span><br><span class="line">                    <span class="comment">// 说明节点已经删除了，通过findPredecessor()方法删除索引节点</span></span><br><span class="line">                    <span class="comment">// findPredecessor()里面有unlink()操作</span></span><br><span class="line">                    findPredecessor(key, cmp);      <span class="comment">// clean index</span></span><br><span class="line">                    <span class="comment">// 如果最高层头索引节点没有右节点，则跳表的高度降级</span></span><br><span class="line">                    <span class="keyword">if</span> (head.right == <span class="keyword">null</span>)</span><br><span class="line">                        tryReduceLevel();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 返回删除的元素值</span></span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> V vv = (V)v;</span><br><span class="line">                <span class="keyword">return</span> vv;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>（1）寻找目标节点之前最近的一个索引对应的数据节点（数据节点都是在最底层的链表上）；</p>
<p>（2）从这个数据节点开始往后遍历，直到找到目标节点的位置；</p>
<p>（3）如果这个位置没有元素，直接返回null，表示没有要删除的元素；</p>
<p>（4）如果这个位置有元素，先通过<code>n.casValue(v, null)</code>原子更新把其value设置为null；</p>
<p>（5）通过<code>n.appendMarker(f)</code>在当前元素后面添加一个marker元素标记当前元素是要删除的元素；</p>
<p>（6）通过<code>b.casNext(n, f)</code>尝试删除元素；</p>
<p>（7）如果上面两步中的任意一步失败了都通过<code>findNode(key)</code>中的<code>n.helpDelete(b, f)</code>再去不断尝试删除；</p>
<p>（8）如果上面两步都成功了，再通过<code>findPredecessor(key, cmp)</code>中的<code>q.unlink(r)</code>删除索引节点；</p>
<p>（9）如果head的right指针指向了null，则跳表高度降级；</p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> doGet(key);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> V <span class="title">doGet</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// key不为空</span></span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">       <span class="comment">// 自旋</span></span><br><span class="line">       outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="comment">// 寻找目标节点之前最近的索引对应的数据节点</span></span><br><span class="line">           <span class="comment">// 为了方便，这里叫b为当前节点，n为下个节点，f为下下个节点</span></span><br><span class="line">           <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">               Object v; <span class="keyword">int</span> c;</span><br><span class="line">               <span class="comment">// 如果链表到头还没找到元素，则跳出外层循环</span></span><br><span class="line">               <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                   <span class="keyword">break</span> outer;</span><br><span class="line">               <span class="comment">// 下下个节点</span></span><br><span class="line">               Node&lt;K,V&gt; f = n.next;</span><br><span class="line">               <span class="comment">// 如果不一致读，从头来过</span></span><br><span class="line">               <span class="keyword">if</span> (n != b.next)                <span class="comment">// inconsistent read</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="comment">// 如果n的值为空，说明节点已被其它线程标记为删除</span></span><br><span class="line">               <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;    <span class="comment">// n is deleted</span></span><br><span class="line">                   <span class="comment">// 协助删除，再重试</span></span><br><span class="line">                   n.helpDelete(b, f);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 如果b的值为空或者v等于n，说明b已被删除</span></span><br><span class="line">               <span class="comment">// 这时候n就是marker节点，那b就是被删除的那个</span></span><br><span class="line">               <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)  <span class="comment">// b is deleted</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="comment">// 如果c==0，说明找到了元素，就返回元素值</span></span><br><span class="line">               <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> V vv = (V)v;</span><br><span class="line">                   <span class="keyword">return</span> vv;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 如果c&lt;0，说明没找到元素</span></span><br><span class="line">               <span class="keyword">if</span> (c &lt; <span class="number">0</span>)</span><br><span class="line">                   <span class="keyword">break</span> outer;</span><br><span class="line">               <span class="comment">// 如果c&gt;0，说明还没找到，继续寻找</span></span><br><span class="line">               <span class="comment">// 当前节点往后移</span></span><br><span class="line">               b = n;</span><br><span class="line">               <span class="comment">// 下一个节点往后移</span></span><br><span class="line">               n = f;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>（1）寻找目标节点之前最近的一个索引对应的数据节点（数据节点都是在最底层的链表上）；</p>
<p>（2）从这个数据节点开始往后遍历，直到找到目标节点的位置；</p>
<p>（3）如果这个位置没有元素，直接返回null，表示没有找到元素；</p>
<p>（4）如果这个位置有元素，返回元素的value值；</p>
<h2 id="ConcurrentSkipList的索引具有什么特性？"><a href="#ConcurrentSkipList的索引具有什么特性？" class="headerlink" title="ConcurrentSkipList的索引具有什么特性？"></a>ConcurrentSkipList的索引具有什么特性？</h2><p>ConcurrentSkipListMap提供了三个内部类来构建这样的链表结构：Node、Index、HeadIndex。其中Node表示最底层的单链表有序节点、Index表示为基于Node的索引层，HeadIndex用来维护索引层次。到这里我们可以这样说ConcurrentSkipListMap是通过HeadIndex维护索引层次，通过Index从最上层开始往下层查找，一步一步缩小查询范围，最后到达最底层Node时，就只需要比较很小一部分数据了。<br>Index提供了一个基于Node节点的索引Node，一个指向下一个Index的right，一个指向下层的down节点。</p>
<h2 id="为什么Redis选择使用跳表而不是红黑树来实现有序集合？"><a href="#为什么Redis选择使用跳表而不是红黑树来实现有序集合？" class="headerlink" title="为什么Redis选择使用跳表而不是红黑树来实现有序集合？"></a>为什么Redis选择使用跳表而不是红黑树来实现有序集合？</h2><p>首先，我们来分析下Redis的有序集合支持的操作：</p>
<p>1）插入元素</p>
<p>2）删除元素</p>
<p>3）查找元素</p>
<p>4）有序输出所有元素</p>
<p>5）查找区间内所有元素</p>
<p>其中，前4项红黑树都可以完成，且时间复杂度与跳表一致。</p>
<p>但是，最后一项，红黑树的效率就没有跳表高了。</p>
<p>在跳表中，要查找区间的元素，我们只要定位到两个区间端点在最低层级的位置，然后按顺序遍历元素就可以了，非常高效。</p>
<p>而红黑树只能定位到端点后，再从首位置开始每次都要查找后继节点，相对来说是比较耗时的。</p>
<p>此外，跳表实现起来很容易且易读，红黑树实现起来相对困难，所以Redis选择使用跳表来实现有序集合。</p>
<h2 id="HashSet怎么保证添加元素不重复？"><a href="#HashSet怎么保证添加元素不重复？" class="headerlink" title="HashSet怎么保证添加元素不重复？"></a>HashSet怎么保证添加元素不重复？</h2><p>HashSet内部使用HashMap的key存储元素，以此来保证元素不重复；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部使用HashMap</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 虚拟对象，用来作为value放到map中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<h2 id="HashSet是有序的吗？"><a href="#HashSet是有序的吗？" class="headerlink" title="HashSet是有序的吗？"></a>HashSet是有序的吗？</h2><p>HashSet是无序的，因为HashMap的key是无序的；</p>
<h2 id="HashSet是否允许null元素？"><a href="#HashSet是否允许null元素？" class="headerlink" title="HashSet是否允许null元素？"></a>HashSet是否允许null元素？</h2><p>HashSet中允许有一个null元素，因为HashMap允许key为null；</p>
<h2 id="Set是否有get-方法？"><a href="#Set是否有get-方法？" class="headerlink" title="Set是否有get()方法？"></a>Set是否有get()方法？</h2><p>HashSet是没有get()方法的，，因为get似乎没有意义，不像List那样可以按index获取元素。</p>
<p>这里只要一个检查元素是否存在的方法contains()，直接调用map的containsKey()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashSet源码？"><a href="#HashSet源码？" class="headerlink" title="HashSet源码？"></a>HashSet源码？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">package</span> java.util;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">import</span> java.io.InvalidObjectException;</span><br><span class="line"><span class="keyword">import</span> sun.misc.SharedSecrets;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5024744406713321676L</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 内部元素存储在HashMap中</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 虚拟元素，用来存到map元素的value中的，没有实际意义</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 空构造方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 把另一个集合的元素全都添加到当前Set中</span></span><br><span class="line">        <span class="comment">// 注意，这里初始化map的时候是计算了它的初始容量的</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">            map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/<span class="number">.75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">            addAll(c);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 指定初始容量和装载因子</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">            map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 只指定初始容量</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">            map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// LinkedHashSet专用的方法</span></span><br><span class="line">        <span class="comment">// dummy是没有实际意义的, 只是为了跟上上面那个操持方法签名不同而已</span></span><br><span class="line">        HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">            map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 迭代器</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 元素个数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> map.size();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 检查是否为空</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> map.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 检查是否包含某个元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 删除元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 清空所有元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            map.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 克隆方法</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">                newSet.map = (HashMap&lt;E, Object&gt;) map.clone();</span><br><span class="line">                <span class="keyword">return</span> newSet;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 序列化写出方法</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">            <span class="comment">// 写出非static非transient属性</span></span><br><span class="line">            s.defaultWriteObject();</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 写出map的容量和装载因子</span></span><br><span class="line">            s.writeInt(map.capacity());</span><br><span class="line">            s.writeFloat(map.loadFactor());</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 写出元素个数</span></span><br><span class="line">            s.writeInt(map.size());</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 遍历写出所有元素</span></span><br><span class="line">            <span class="keyword">for</span> (E e : map.keySet())</span><br><span class="line">                s.writeObject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 序列化读入方法</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">            <span class="comment">// 读入非static非transient属性</span></span><br><span class="line">            s.defaultReadObject();</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 读入容量, 并检查不能小于0</span></span><br><span class="line">            <span class="keyword">int</span> capacity = s.readInt();</span><br><span class="line">            <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">&quot;Illegal capacity: &quot;</span> +</span><br><span class="line">                                                 capacity);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 读入装载因子, 并检查不能小于等于0或者是NaN(Not a Number)</span></span><br><span class="line">            <span class="comment">// java.lang.Float.NaN = 0.0f / 0.0f;</span></span><br><span class="line">            <span class="keyword">float</span> loadFactor = s.readFloat();</span><br><span class="line">            <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                                 loadFactor);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 读入元素个数并检查不能小于0</span></span><br><span class="line">            <span class="keyword">int</span> size = s.readInt();</span><br><span class="line">            <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">&quot;Illegal size: &quot;</span> +</span><br><span class="line">                                                 size);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据元素个数重新设置容量</span></span><br><span class="line">            <span class="comment">// 这是为了保证map有足够的容量容纳所有元素, 防止无意义的扩容</span></span><br><span class="line">            capacity = (<span class="keyword">int</span>) Math.min(size * Math.min(<span class="number">1</span> / loadFactor, <span class="number">4.0f</span>),</span><br><span class="line">                    HashMap.MAXIMUM_CAPACITY);</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 再次检查某些东西, 不重要的代码忽视掉</span></span><br><span class="line">            SharedSecrets.getJavaOISAccess()</span><br><span class="line">                         .checkArray(s, Map.Entry[].class, HashMap.tableSizeFor(capacity));</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 创建map, 检查是不是LinkedHashSet类型</span></span><br><span class="line">            map = (((HashSet&lt;?&gt;)<span class="keyword">this</span>) <span class="keyword">instanceof</span> LinkedHashSet ?</span><br><span class="line">                   <span class="keyword">new</span> LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) :</span><br><span class="line">                   <span class="keyword">new</span> HashMap&lt;E,Object&gt;(capacity, loadFactor));</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 读入所有元素, 并放入map中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    E e = (E) s.readObject();</span><br><span class="line">                map.put(e, PRESENT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 可分割的迭代器, 主要用于多线程并行迭代处理时使用</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HashMap.KeySpliterator&lt;E,Object&gt;(map, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LinkedHashSet的底层使用什么存储元素？"><a href="#LinkedHashSet的底层使用什么存储元素？" class="headerlink" title="LinkedHashSet的底层使用什么存储元素？"></a>LinkedHashSet的底层使用什么存储元素？</h2><p>LinkedHashSet的底层使用LinkedHashMap存储元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">package</span> java.util;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// LinkedHashSet继承自HashSet</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2851667679971038690L</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 传入容量和装载因子</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(initialCapacity, loadFactor, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 只传入容量, 装载因子默认为0.75</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(initialCapacity, <span class="number">.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 使用默认容量16, 默认装载因子0.75</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(<span class="number">16</span>, <span class="number">.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 将集合c中的所有元素添加到LinkedHashSet中</span></span><br><span class="line">        <span class="comment">// 好奇怪, 这里计算容量的方式又变了</span></span><br><span class="line">        <span class="comment">// HashSet中使用的是Math.max((int) (c.size()/.75f) + 1, 16)</span></span><br><span class="line">        <span class="comment">// 这一点有点不得其解, 是作者偷懒？</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(Math.max(<span class="number">2</span>*c.size(), <span class="number">11</span>), <span class="number">.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">            addAll(c);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 可分割的迭代器, 主要用于多线程并行迭代处理时使用</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, Spliterator.DISTINCT | Spliterator.ORDERED);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LinkedHashSet是有序的吗？怎么个有序法？"><a href="#LinkedHashSet是有序的吗？怎么个有序法？" class="headerlink" title="LinkedHashSet是有序的吗？怎么个有序法？"></a>LinkedHashSet是有序的吗？怎么个有序法？</h2><p>LinkedHashSet是有序的，它是按照插入的顺序排序的。</p>
<h2 id="LinkedHashSet支持按元素访问顺序排序吗？"><a href="#LinkedHashSet支持按元素访问顺序排序吗？" class="headerlink" title="LinkedHashSet支持按元素访问顺序排序吗？"></a>LinkedHashSet支持按元素访问顺序排序吗？</h2><p>不支持</p>
<p>首先，LinkedHashSet所有的构造方法都是调用HashSet的同一个构造方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashSet的构造方法</span></span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">            map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，通过调用LinkedHashMap的构造方法初始化map，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里把accessOrder写死为false了。</p>
<p>所以，LinkedHashSet是不支持按访问顺序对元素排序的，只能按插入顺序排序。</p>
<h2 id="TreeSet真的是使用TreeMap来存储元素的吗？"><a href="#TreeSet真的是使用TreeMap来存储元素的吗？" class="headerlink" title="TreeSet真的是使用TreeMap来存储元素的吗？"></a>TreeSet真的是使用TreeMap来存储元素的吗？</h2><p>通过源码分析我们知道TreeSet里面实际上是使用的NavigableMap来存储元素，虽然大部分时候这个map确实是TreeMap，但不是所有时候都是TreeMap。</p>
<p>因为有一个构造方法是<code>TreeSet(NavigableMap&lt;E,Object&gt; m)</code>，而且这是一个非public方法，通过调用关系我们可以发现这个构造方法都是在自己类中使用的，比如下面这个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> inclusive)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;&gt;(m.tailMap(fromElement, inclusive));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这个m我们姑且认为它是TreeMap，也就是调用TreeMap的tailMap()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> NavigableMap&lt;K,V&gt; <span class="title">tailMap</span><span class="params">(K fromKey, <span class="keyword">boolean</span> inclusive)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AscendingSubMap&lt;&gt;(<span class="keyword">this</span>,</span><br><span class="line">                                         <span class="keyword">false</span>, fromKey, inclusive,</span><br><span class="line">                                         <span class="keyword">true</span>,  <span class="keyword">null</span>,    <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，返回的是AscendingSubMap对象，这个类的继承链是怎么样的呢？</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210817183810.png" alt="202105091520593461.png"></p>
<p>可以看到，这个类并没有继承TreeMap，不过通过源码分析也可以看出来这个类是组合了TreeMap，也算和TreeMap有点关系，只是不是继承关系。</p>
<p>所以，TreeSet的底层不完全是使用TreeMap来实现的，更准确地说，应该是NavigableMap。</p>
<h2 id="TreeSet是有序的吗？怎么个有序法？"><a href="#TreeSet是有序的吗？怎么个有序法？" class="headerlink" title="TreeSet是有序的吗？怎么个有序法？"></a>TreeSet是有序的吗？怎么个有序法？</h2><p>有序的,TreeSet实现了SortedSet接口，它的有序性主要依赖于NavigableMap的有序性，而NavigableMap又继承自SortedMap，这个接口的有序性是指按照key的自然排序保证的有序性，而key的自然排序又有两种实现方式，一种是key实现Comparable接口，一种是构造方法传入Comparator比较器。</p>
<h2 id="TreeSet和LinkedHashSet有何不同？"><a href="#TreeSet和LinkedHashSet有何不同？" class="headerlink" title="TreeSet和LinkedHashSet有何不同？"></a>TreeSet和LinkedHashSet有何不同？</h2><p>LinkedHashSet并没有实现SortedSet接口，它的有序性主要依赖于LinkedHashMap的有序性，所以它的有序性是指按照插入顺序保证的有序性；</p>
<p>而TreeSet实现了SortedSet接口，它的有序性主要依赖于NavigableMap的有序性，而NavigableMap又继承自SortedMap，这个接口的有序性是指按照key的自然排序保证的有序性，而key的自然排序又有两种实现方式，一种是key实现Comparable接口，一种是构造方法传入Comparator比较器。</p>
<h2 id="TreeSet和SortedSet有什么区别和联系？"><a href="#TreeSet和SortedSet有什么区别和联系？" class="headerlink" title="TreeSet和SortedSet有什么区别和联系？"></a>TreeSet和SortedSet有什么区别和联系？</h2><p>TreeSet实现了NavigableSet接口，而NavigableSet继承自SortedSet接口；TreeSet实现了SortedSet接口；</p>
<h2 id="CopyOnWriteArraySet是用Map实现的吗？"><a href="#CopyOnWriteArraySet是用Map实现的吗？" class="headerlink" title="CopyOnWriteArraySet是用Map实现的吗？"></a>CopyOnWriteArraySet是用Map实现的吗？</h2><p>CopyOnWriteArraySet底层是使用CopyOnWriteArrayList存储元素的，所以它并不是使用Map来存储元素的。</p>
<h2 id="CopyOnWriteArraySet是有序的吗？怎么个有序法？"><a href="#CopyOnWriteArraySet是有序的吗？怎么个有序法？" class="headerlink" title="CopyOnWriteArraySet是有序的吗？怎么个有序法？"></a>CopyOnWriteArraySet是有序的吗？怎么个有序法？</h2><p>有序,因为底层是CopyOnWriteArrayList存储元素的,所以是个数组。</p>
<h2 id="CopyOnWriteArraySet怎么保证并发安全？"><a href="#CopyOnWriteArraySet怎么保证并发安全？" class="headerlink" title="CopyOnWriteArraySet怎么保证并发安全？"></a>CopyOnWriteArraySet怎么保证并发安全？</h2><p>CopyOnWriteArraySet是并发安全的，而且实现了读写分离；因为底层是CopyOnWriteArrayList存储元素的,所以见CopyOnWriteArrayList是如何实现并发安全的。</p>
<h2 id="CopyOnWriteArraySet以何种方式保证元素不重复？"><a href="#CopyOnWriteArraySet以何种方式保证元素不重复？" class="headerlink" title="CopyOnWriteArraySet以何种方式保证元素不重复？"></a>CopyOnWriteArraySet以何种方式保证元素不重复？</h2><p>在添加元素时调用了CopyOnWriteArrayList的addIfAbsent()方法来保证元素不重复。</p>
<p>CopyOnWriteArraySet通过调用CopyOnWriteArrayList的addIfAbsent()方法来保证元素不重复</p>
<p>具体的见前文</p>
<h2 id="如何比较两个Set中的元素是否完全一致？"><a href="#如何比较两个Set中的元素是否完全一致？" class="headerlink" title="如何比较两个Set中的元素是否完全一致？"></a>如何比较两个Set中的元素是否完全一致？</h2><p>假设有两个Set，一个是A，一个是B。</p>
<p>最简单的方式就是判断是否A中的元素都在B中，B中的元素是否都在A中，也就是两次两层循环。</p>
<p>其实，并不需要。</p>
<p>因为Set中的元素并不重复，所以只要先比较两个Set的元素个数是否相等，再作一次两层循环就可以了，需要仔细体味。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArraySetTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            Set&lt;Integer&gt; set1 = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line">            set1.add(<span class="number">1</span>);</span><br><span class="line">            set1.add(<span class="number">5</span>);</span><br><span class="line">            set1.add(<span class="number">2</span>);</span><br><span class="line">            set1.add(<span class="number">7</span>);</span><br><span class="line">    <span class="comment">//        set1.add(3);</span></span><br><span class="line">            set1.add(<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">            Set&lt;Integer&gt; set2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            set2.add(<span class="number">1</span>);</span><br><span class="line">            set2.add(<span class="number">5</span>);</span><br><span class="line">            set2.add(<span class="number">2</span>);</span><br><span class="line">            set2.add(<span class="number">7</span>);</span><br><span class="line">            set2.add(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">            System.out.println(eq(set1, set2));</span><br><span class="line">    </span><br><span class="line">            System.out.println(eq(set2, set1));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">eq</span><span class="params">(Set&lt;T&gt; set1, Set&lt;T&gt; set2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (set1.size() != set2.size()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">for</span> (T t : set1) &#123;</span><br><span class="line">                <span class="comment">// contains相当于一层for循环</span></span><br><span class="line">                <span class="keyword">if</span> (!set2.contains(t)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何比较两个List中的元素是否完全相等呢？"><a href="#如何比较两个List中的元素是否完全相等呢？" class="headerlink" title="如何比较两个List中的元素是否完全相等呢？"></a>如何比较两个List中的元素是否完全相等呢？</h2><p>我们知道，List中元素是可以重复的，那是不是要做两次两层循环呢？</p>
<p>其实，也不需要做两次两层遍历，一次也可以搞定，设定一个标记数组，标记某个位置的元素是否找到过，请仔细体味。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListEqTest</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            list1.add(<span class="number">1</span>);</span><br><span class="line">            list1.add(<span class="number">3</span>);</span><br><span class="line">            list1.add(<span class="number">6</span>);</span><br><span class="line">            list1.add(<span class="number">3</span>);</span><br><span class="line">            list1.add(<span class="number">8</span>);</span><br><span class="line">            list1.add(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">            List&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            list2.add(<span class="number">3</span>);</span><br><span class="line">            list2.add(<span class="number">1</span>);</span><br><span class="line">            list2.add(<span class="number">3</span>);</span><br><span class="line">            list2.add(<span class="number">8</span>);</span><br><span class="line">            list2.add(<span class="number">5</span>);</span><br><span class="line">            list2.add(<span class="number">6</span>);</span><br><span class="line">    </span><br><span class="line">            System.out.println(eq(list1, list2));</span><br><span class="line">            System.out.println(eq(list2, list1));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">eq</span><span class="params">(List&lt;T&gt; list1, List&lt;T&gt; list2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.size() != list2.size()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 标记某个元素是否找到过，防止重复</span></span><br><span class="line">            <span class="keyword">boolean</span> matched[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[list2.size()];</span><br><span class="line">    </span><br><span class="line">            outer: <span class="keyword">for</span> (T t : list1) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list2.size(); i++) &#123;</span><br><span class="line">                    <span class="comment">// i这个位置没找到过才比较大小</span></span><br><span class="line">                    <span class="keyword">if</span> (!matched[i] &amp;&amp; list2.get(i).equals(t)) &#123;</span><br><span class="line">                        matched[i] = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">continue</span> outer;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ConcurrentSkipListSet的底层是ConcurrentSkipListMap吗？"><a href="#ConcurrentSkipListSet的底层是ConcurrentSkipListMap吗？" class="headerlink" title="ConcurrentSkipListSet的底层是ConcurrentSkipListMap吗？"></a>ConcurrentSkipListSet的底层是ConcurrentSkipListMap吗？</h2><p>ConcurrentSkipListSet底层是通过ConcurrentNavigableMap来实现的，它是一个有序的线程安全的集合。</p>
<h2 id="ConcurrentSkipListSet是有序的吗？怎么个有序法？"><a href="#ConcurrentSkipListSet是有序的吗？怎么个有序法？" class="headerlink" title="ConcurrentSkipListSet是有序的吗？怎么个有序法？"></a>ConcurrentSkipListSet是有序的吗？怎么个有序法？</h2><p>ConcurrentSkipListSet有序的，基于元素的自然排序或者通过比较器确定的顺序；</p>
<h2 id="ConcurrentSkipListSet源码？"><a href="#ConcurrentSkipListSet源码？" class="headerlink" title="ConcurrentSkipListSet源码？"></a>ConcurrentSkipListSet源码？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现了NavigableSet接口，并没有所谓的ConcurrentNavigableSet接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentSkipListSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2479143111061671589L</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 存储使用的map</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentNavigableMap&lt;E,Object&gt; m;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSkipListSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            m = <span class="keyword">new</span> ConcurrentSkipListMap&lt;E,Object&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 传入比较器</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSkipListSet</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">            m = <span class="keyword">new</span> ConcurrentSkipListMap&lt;E,Object&gt;(comparator);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 使用ConcurrentSkipListMap初始化map</span></span><br><span class="line">        <span class="comment">// 并将集合c中所有元素放入到map中</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSkipListSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">            m = <span class="keyword">new</span> ConcurrentSkipListMap&lt;E,Object&gt;();</span><br><span class="line">            addAll(c);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 使用ConcurrentSkipListMap初始化map</span></span><br><span class="line">        <span class="comment">// 并将有序Set中所有元素放入到map中</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSkipListSet</span><span class="params">(SortedSet&lt;E&gt; s)</span> </span>&#123;</span><br><span class="line">            m = <span class="keyword">new</span> ConcurrentSkipListMap&lt;E,Object&gt;(s.comparator());</span><br><span class="line">            addAll(s);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// ConcurrentSkipListSet类内部返回子set时使用的</span></span><br><span class="line">        ConcurrentSkipListSet(ConcurrentNavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">            <span class="keyword">this</span>.m = m;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 克隆方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ConcurrentSkipListSet&lt;E&gt; <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                ConcurrentSkipListSet&lt;E&gt; clone =</span><br><span class="line">                    (ConcurrentSkipListSet&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">                clone.setMap(<span class="keyword">new</span> ConcurrentSkipListMap&lt;E,Object&gt;(m));</span><br><span class="line">                <span class="keyword">return</span> clone;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/* ---------------- Set operations -------------- */</span></span><br><span class="line">        <span class="comment">// 返回元素个数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m.size();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 检查是否为空</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 检查是否包含某个元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m.containsKey(o);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 添加一个元素</span></span><br><span class="line">        <span class="comment">// 调用map的putIfAbsent()方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m.putIfAbsent(e, Boolean.TRUE) == <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 移除一个元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m.remove(o, Boolean.TRUE);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 清空所有元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            m.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 迭代器</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m.navigableKeySet().iterator();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 降序迭代器</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m.descendingKeySet().iterator();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        <span class="comment">/* ---------------- AbstractSet Overrides -------------- */</span></span><br><span class="line">        <span class="comment">// 比较相等方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Override AbstractSet version to avoid calling size()</span></span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Set))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Collection&lt;?&gt; c = (Collection&lt;?&gt;) o;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 这里是通过两次两层for循环来比较</span></span><br><span class="line">                <span class="comment">// 这里是有很大优化空间的，参考上篇文章CopyOnWriteArraySet中的彩蛋</span></span><br><span class="line">                <span class="keyword">return</span> containsAll(c) &amp;&amp; c.containsAll(<span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassCastException unused) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NullPointerException unused) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 移除集合c中所有元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Override AbstractSet version to avoid unnecessary call to size()</span></span><br><span class="line">            <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (Object e : c)</span><br><span class="line">                <span class="keyword">if</span> (remove(e))</span><br><span class="line">                    modified = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> modified;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/* ---------------- Relational operations -------------- */</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 小于e的最大元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">lower</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m.lowerKey(e);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 小于等于e的最大元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">floor</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m.floorKey(e);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 大于等于e的最小元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">ceiling</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m.ceilingKey(e);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 大于e的最小元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">higher</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m.higherKey(e);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 弹出最小的元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Map.Entry&lt;E,Object&gt; e = m.pollFirstEntry();</span><br><span class="line">            <span class="keyword">return</span> (e == <span class="keyword">null</span>) ? <span class="keyword">null</span> : e.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 弹出最大的元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Map.Entry&lt;E,Object&gt; e = m.pollLastEntry();</span><br><span class="line">            <span class="keyword">return</span> (e == <span class="keyword">null</span>) ? <span class="keyword">null</span> : e.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        <span class="comment">/* ---------------- SortedSet operations -------------- */</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 取比较器</span></span><br><span class="line">        <span class="keyword">public</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator() &#123;</span><br><span class="line">            <span class="keyword">return</span> m.comparator();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 最小的元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m.firstKey();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 最大的元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">last</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m.lastKey();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 取两个元素之间的子set</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">boolean</span> fromInclusive,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      E toElement,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">boolean</span> toInclusive)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcurrentSkipListSet&lt;E&gt;</span><br><span class="line">                (m.subMap(fromElement, fromInclusive,</span><br><span class="line">                          toElement,   toInclusive));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 取头子set</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement, <span class="keyword">boolean</span> inclusive)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcurrentSkipListSet&lt;E&gt;(m.headMap(toElement, inclusive));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 取尾子set</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> inclusive)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcurrentSkipListSet&lt;E&gt;(m.tailMap(fromElement, inclusive));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 取子set，包含from，不包含to</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, E toElement)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> subSet(fromElement, <span class="keyword">true</span>, toElement, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 取头子set，不包含to</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> headSet(toElement, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 取尾子set，包含from</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> tailSet(fromElement, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 降序set</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">descendingSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcurrentSkipListSet&lt;E&gt;(m.descendingMap());</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 可分割的迭代器</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (m <span class="keyword">instanceof</span> ConcurrentSkipListMap)</span><br><span class="line">                <span class="keyword">return</span> ((ConcurrentSkipListMap&lt;E,?&gt;)m).keySpliterator();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> (Spliterator&lt;E&gt;)((ConcurrentSkipListMap.SubMap&lt;E,?&gt;)m).keyIterator();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 原子更新map，给clone方法使用</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setMap</span><span class="params">(ConcurrentNavigableMap&lt;E,Object&gt; map)</span> </span>&#123;</span><br><span class="line">            UNSAFE.putObjectVolatile(<span class="keyword">this</span>, mapOffset, map);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 原子操作相关内容</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> mapOffset;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">                Class&lt;?&gt; k = ConcurrentSkipListSet.class;</span><br><span class="line">                mapOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(<span class="string">&quot;m&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="什么是堆？什么是堆化？"><a href="#什么是堆？什么是堆化？" class="headerlink" title="什么是堆？什么是堆化？"></a>什么是堆？什么是堆化？</h2><p>堆是一种特殊的树，只要满足下面两个条件，它就是一个堆：</p>
<p>（1）堆是一颗完全二叉树；</p>
<p>（2）堆中某个节点的值总是不大于（或不小于）其父节点的值。</p>
<p>其中，我们把根节点最大的堆叫做大顶堆，根节点最小的堆叫做小顶堆。</p>
<p>堆化（向下调整）、向上调整的前提都是：在二叉树中，只有一个位置不满足堆的性质，其它位置都满足堆的性质。<br>        向下调整 是让调整的结点与其孩子节点进行比较<br>        向上调整 是让调整的结点与其父亲结点进行比较</p>
<h2 id="什么是优先级队列？"><a href="#什么是优先级队列？" class="headerlink" title="什么是优先级队列？"></a>什么是优先级队列？</h2><h2 id="PriorityQueue是怎么实现的？"><a href="#PriorityQueue是怎么实现的？" class="headerlink" title="PriorityQueue是怎么实现的？"></a>PriorityQueue是怎么实现的？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 默认容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"><span class="comment">// 存储元素的地方</span></span><br><span class="line"><span class="keyword">transient</span> Object[] queue; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"><span class="comment">// 元素个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 比较器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"><span class="comment">// 修改次数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure>

<p>PriorityQueue是一个小顶堆；</p>
<h2 id="PriorityQueue是有序的吗？"><a href="#PriorityQueue是有序的吗？" class="headerlink" title="PriorityQueue是有序的吗？"></a>PriorityQueue是有序的吗？</h2><p>PriorityQueue不是有序的，只有堆顶存储着最小的元素；</p>
<h2 id="PriorityQueue入队、出队的时间复杂度各是多少？"><a href="#PriorityQueue入队、出队的时间复杂度各是多少？" class="headerlink" title="PriorityQueue入队、出队的时间复杂度各是多少？"></a>PriorityQueue入队、出队的时间复杂度各是多少？</h2><p>建堆的时间复杂度是O(n)；</p>
<p>堆的插入、删除元素的时间复杂度都是O(log n)；</p>
<p>入队有两个方法，add(E e)和offer(E e)，两者是一致的，add(E e)也是调用的offer(E e)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> offer(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不支持null元素</span></span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">// 取size</span></span><br><span class="line">        <span class="keyword">int</span> i = size;</span><br><span class="line">        <span class="comment">// 元素个数达到最大容量了，扩容</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">            grow(i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 元素个数加1</span></span><br><span class="line">        size = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果还没有元素</span></span><br><span class="line">        <span class="comment">// 直接插入到数组第一个位置</span></span><br><span class="line">        <span class="comment">// 这里跟我们之前讲堆不一样了</span></span><br><span class="line">        <span class="comment">// java里面是从0开始的</span></span><br><span class="line">        <span class="comment">// 我们说的堆是从1开始的</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            queue[<span class="number">0</span>] = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 否则，插入元素到数组size的位置，也就是最后一个元素的下一位</span></span><br><span class="line">            <span class="comment">// 注意这里的size不是数组大小，而是元素个数</span></span><br><span class="line">            <span class="comment">// 然后，再做自下而上的堆化</span></span><br><span class="line">            siftUp(i, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据是否有比较器，使用不同的方法</span></span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">            siftUpUsingComparator(k, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftUpComparable(k, x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;) x;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到父节点的位置</span></span><br><span class="line">            <span class="comment">// 因为元素是从0开始的，所以减1之后再除以2</span></span><br><span class="line">            <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 父节点的值</span></span><br><span class="line">            Object e = queue[parent];</span><br><span class="line">            <span class="comment">// 比较插入的元素与父节点的值</span></span><br><span class="line">            <span class="comment">// 如果比父节点大，则跳出循环</span></span><br><span class="line">            <span class="comment">// 否则交换位置</span></span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 与父节点交换位置</span></span><br><span class="line">            queue[k] = e;</span><br><span class="line">            <span class="comment">// 现在插入的元素位置移到了父节点的位置</span></span><br><span class="line">            <span class="comment">// 继续与父节点再比较</span></span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后找到应该插入的位置，放入元素</span></span><br><span class="line">        queue[k] = key;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>（1）入队不允许null元素；</p>
<p>（2）如果数组不够用了，先扩容；</p>
<p>（3）如果还没有元素，就插入下标0的位置；</p>
<p>（4）如果有元素了，就插入到最后一个元素往后的一个位置（实际并没有插入哈）；</p>
<p>（5）自下而上堆化，一直往上跟父节点比较；</p>
<p>（6）如果比父节点小，就与父节点交换位置，直到出现比父节点大为止；</p>
<p>（7）由此可见，PriorityQueue是一个小顶堆。</p>
<p>出队有两个方法，remove()和poll()，remove()也是调用的poll()，只是没有元素的时候抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用poll弹出队首元素</span></span><br><span class="line">        E x = poll();</span><br><span class="line">        <span class="keyword">if</span> (x != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 有元素就返回弹出的元素</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 没有元素就抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果size为0，说明没有元素</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 弹出元素，元素个数减1</span></span><br><span class="line">        <span class="keyword">int</span> s = --size;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">// 队列首元素</span></span><br><span class="line">        E result = (E) queue[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 队列末元素</span></span><br><span class="line">        E x = (E) queue[s];</span><br><span class="line">        <span class="comment">// 将队列末元素删除</span></span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果弹出元素后还有元素</span></span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 将队列末元素移到队列首</span></span><br><span class="line">            <span class="comment">// 再做自上而下的堆化</span></span><br><span class="line">            siftDown(<span class="number">0</span>, x);</span><br><span class="line">        <span class="comment">// 返回弹出的元素</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据是否有比较器，选择不同的方法</span></span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">            siftDownUsingComparator(k, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftDownComparable(k, x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;)x;</span><br><span class="line">        <span class="comment">// 只需要比较一半就行了，因为叶子节点占了一半的元素</span></span><br><span class="line">        <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;        <span class="comment">// loop while a non-leaf</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">            <span class="comment">// 寻找子节点的位置，这里加1是因为元素从0号位置开始</span></span><br><span class="line">            <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line">            <span class="comment">// 左子节点的值</span></span><br><span class="line">            Object c = queue[child];</span><br><span class="line">            <span class="comment">// 右子节点的位置</span></span><br><span class="line">            <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">                ((Comparable&lt;? <span class="keyword">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 左右节点取其小者</span></span><br><span class="line">                c = queue[child = right];</span><br><span class="line">            <span class="comment">// 如果比子节点都小，则结束</span></span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 如果比最小的子节点大，则交换位置</span></span><br><span class="line">            queue[k] = c;</span><br><span class="line">            <span class="comment">// 指针移到最小子节点的位置继续往下比较</span></span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到正确的位置，放入元素</span></span><br><span class="line">        queue[k] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）将队列首元素弹出；</p>
<p>（2）将队列末元素移到队列首；</p>
<p>（3）自上而下堆化，一直往下与最小的子节点比较；</p>
<p>（4）如果比最小的子节点大，就交换位置，再继续与最小的子节点比较；</p>
<p>（5）如果比最小的子节点小，就不用交换位置了，堆化结束；</p>
<p>（6）这就是堆中的删除堆顶元素；</p>
<h2 id="PriorityQueue是否需要扩容？扩容规则呢？"><a href="#PriorityQueue是否需要扩容？扩容规则呢？" class="headerlink" title="PriorityQueue是否需要扩容？扩容规则呢？"></a>PriorityQueue是否需要扩容？扩容规则呢？</h2><p>会因为PriorityQueue是无限增长的队列，元素不够用了会扩容，所以添加元素不会失败。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 旧容量</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = queue.length;</span><br><span class="line">        <span class="comment">// Double size if small; else grow by 50%</span></span><br><span class="line">        <span class="comment">// 旧容量小于64时，容量翻倍</span></span><br><span class="line">        <span class="comment">// 旧容量大于等于64，容量只增加旧容量的一半</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?</span><br><span class="line">                                         (oldCapacity + <span class="number">2</span>) :</span><br><span class="line">                                         (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="comment">// 检查是否溢出</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 创建出一个新容量大小的新数组并把旧数组元素拷贝过去</span></span><br><span class="line">        queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>（1）当数组比较小（小于64）的时候每次扩容容量翻倍；</p>
<p>（2）当数组比较大的时候每次扩容只增加一半的容量；</p>
<h2 id="ArrayBlockingQueue的实现方式？"><a href="#ArrayBlockingQueue的实现方式？" class="headerlink" title="ArrayBlockingQueue的实现方式？"></a>ArrayBlockingQueue的实现方式？</h2><p>ArrayBlockingQueue是java并发包下一个以数组实现的阻塞队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用数组存储元素</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取元素的指针</span></span><br><span class="line">    <span class="keyword">int</span> takeIndex;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 放元素的指针</span></span><br><span class="line">    <span class="keyword">int</span> putIndex;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 元素数量</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保证并发访问的锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非空条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非满条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure>

<h2 id="ArrayBlockingQueue是否需要扩容？"><a href="#ArrayBlockingQueue是否需要扩容？" class="headerlink" title="ArrayBlockingQueue是否需要扩容？"></a>ArrayBlockingQueue是否需要扩容？</h2><p>ArrayBlockingQueue不需要扩容，因为是初始化时指定容量，并循环利用数组；</p>
<p>ArrayBlockingQueue利用takeIndex和putIndex循环利用数组</p>
<h2 id="ArrayBlockingQueue怎么保证线程安全？"><a href="#ArrayBlockingQueue怎么保证线程安全？" class="headerlink" title="ArrayBlockingQueue怎么保证线程安全？"></a>ArrayBlockingQueue怎么保证线程安全？</h2><p>利用重入锁和两个条件保证并发安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">      <span class="comment">// 初始化数组</span></span><br><span class="line">      <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">      <span class="comment">// 创建重入锁及两个条件</span></span><br><span class="line">      lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">      notEmpty = lock.newCondition();</span><br><span class="line">      notFull =  lock.newCondition();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>入队有四个方法，它们分别是add(E e)、offer(E e)、put(E e)、offer(E e, long timeout, TimeUnit unit)，它们有什么区别呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类的add(e)方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// super.add(e)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用offer(e)如果成功返回true，如果失败抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (offer(e))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 元素不可为空</span></span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == items.length)</span><br><span class="line">                <span class="comment">// 如果数组满了就返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果数组没满就调用入队方法并返回true</span></span><br><span class="line">                enqueue(e);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        <span class="comment">// 加锁，如果线程中断了抛出异常</span></span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果数组满了，使用notFull等待</span></span><br><span class="line">            <span class="comment">// notFull等待的意思是说现在队列满了</span></span><br><span class="line">            <span class="comment">// 只有取走一个元素后，队列才不满</span></span><br><span class="line">            <span class="comment">// 然后唤醒notFull，然后继续现在的逻辑</span></span><br><span class="line">            <span class="comment">// 这里之所以使用while而不是if</span></span><br><span class="line">            <span class="comment">// 是因为有可能多个线程阻塞在lock上</span></span><br><span class="line">            <span class="comment">// 即使唤醒了可能其它线程先一步修改了队列又变成满的了</span></span><br><span class="line">            <span class="comment">// 这时候需要再次等待</span></span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            <span class="comment">// 入队</span></span><br><span class="line">            enqueue(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果数组满了，就阻塞nanos纳秒</span></span><br><span class="line">            <span class="comment">// 如果唤醒这个线程时依然没有空间且时间到了就返回false</span></span><br><span class="line">            <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                nanos = notFull.awaitNanos(nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 入队</span></span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">        <span class="comment">// 把元素直接放在放指针的位置上</span></span><br><span class="line">        items[putIndex] = x;</span><br><span class="line">        <span class="comment">// 如果放指针到数组尽头了，就返回头部</span></span><br><span class="line">        <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">            putIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 数量加1</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// 唤醒notEmpty，因为入队了一个元素，所以肯定不为空了</span></span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>（1）add(e)时如果队列满了则抛出异常；</p>
<p>（2）offer(e)时如果队列满了则返回false；</p>
<p>（3）put(e)时如果队列满了则使用notFull等待；</p>
<p>（4）offer(e, timeout, unit)时如果队列满了则等待一段时间后如果队列依然满就返回false；</p>
<p>（5）利用放指针循环使用数组来存储元素；</p>
<p>出队有四个方法，它们分别是remove()、poll()、take()、poll(long timeout, TimeUnit unit)，它们有什么区别呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用poll()方法出队</span></span><br><span class="line">        E x = poll();</span><br><span class="line">        <span class="keyword">if</span> (x != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 如果有元素出队就返回这个元素</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 如果没有元素出队就抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果队列没有元素则返回null，否则出队</span></span><br><span class="line">            <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果队列无元素，则阻塞等待在条件notEmpty上</span></span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            <span class="comment">// 有元素了再出队</span></span><br><span class="line">            <span class="keyword">return</span> dequeue();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果队列无元素，则阻塞等待nanos纳秒</span></span><br><span class="line">            <span class="comment">// 如果下一次这个线程获得了锁但队列依然无元素且已超时就返回null</span></span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dequeue();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="comment">// 取取指针位置的元素</span></span><br><span class="line">        E x = (E) items[takeIndex];</span><br><span class="line">        <span class="comment">// 把取指针位置设为null</span></span><br><span class="line">        items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 取指针前移，如果数组到头了就返回数组前端循环利用</span></span><br><span class="line">        <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">            takeIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 元素数量减1</span></span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">            itrs.elementDequeued();</span><br><span class="line">        <span class="comment">// 唤醒notFull条件</span></span><br><span class="line">        notFull.signal();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>（1）remove()时如果队列为空则抛出异常；</p>
<p>（2）poll()时如果队列为空则返回null；</p>
<p>（3）take()时如果队列为空则阻塞等待在条件notEmpty上；</p>
<p>（4）poll(timeout, unit)时如果队列为空则阻塞等待一段时间后如果还为空就返回null；</p>
<p>（5）利用取指针循环从数组中取元素；</p>
<h2 id="ArrayBlockingQueue有什么缺点？"><a href="#ArrayBlockingQueue有什么缺点？" class="headerlink" title="ArrayBlockingQueue有什么缺点？"></a>ArrayBlockingQueue有什么缺点？</h2><p>a）队列长度固定且必须在初始化时指定，所以使用之前一定要慎重考虑好容量；</p>
<p>b）如果消费速度跟不上入队速度，则会导致提供者线程一直阻塞，且越阻塞越多，非常危险；</p>
<p>c）只使用了一个锁来控制入队出队，效率较低。</p>
<h2 id="LinkedBlockingQueue的实现方式？"><a href="#LinkedBlockingQueue的实现方式？" class="headerlink" title="LinkedBlockingQueue的实现方式？"></a>LinkedBlockingQueue的实现方式？</h2><p>LinkedBlockingQueue采用单链表的形式实现；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line">    </span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">    </span><br><span class="line">        Node(E x) &#123; item = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LinkedBlockingQueue是有界的还是无界的队列？"><a href="#LinkedBlockingQueue是有界的还是无界的队列？" class="headerlink" title="LinkedBlockingQueue是有界的还是无界的队列？"></a>LinkedBlockingQueue是有界的还是无界的队列？</h2><p>LinkedBlockingQueue是有界队列，不传入容量时默认为最大int值；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果没传容量，就使用最大int值初始化其容量</span></span><br><span class="line">        <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="comment">// 初始化head和last指针为空值节点</span></span><br><span class="line">        last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="LinkedBlockingQueue怎么保证线程安全？"><a href="#LinkedBlockingQueue怎么保证线程安全？" class="headerlink" title="LinkedBlockingQueue怎么保证线程安全？"></a>LinkedBlockingQueue怎么保证线程安全？</h2><p>LinkedBlockingQueue采用两把锁的锁分离技术实现入队出队互不阻塞；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 元素数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 链表头</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 链表尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// take锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// notEmpty条件</span></span><br><span class="line">    <span class="comment">// 当队列无元素时，take锁会阻塞在notEmpty条件上，等待其它线程唤醒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 放锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// notFull条件</span></span><br><span class="line">    <span class="comment">// 当队列满了时，put锁会会阻塞在notFull上，等待其它线程唤醒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure>

<h2 id="LinkedBlockingQueue与ArrayBlockingQueue对比？"><a href="#LinkedBlockingQueue与ArrayBlockingQueue对比？" class="headerlink" title="LinkedBlockingQueue与ArrayBlockingQueue对比？"></a>LinkedBlockingQueue与ArrayBlockingQueue对比？</h2><p>a）后者入队出队采用一把锁，导致入队出队相互阻塞，效率低下；</p>
<p>b）前才入队出队采用两把锁，入队出队互不干扰，效率较高；</p>
<p>c）二者都是有界队列，如果长度相等且出队速度跟不上入队速度，都会导致大量线程阻塞；</p>
<p>d）前者如果初始化不传入初始容量，则使用最大int值，如果出队速度跟不上入队速度，会导致队列特别长，占用大量内存；</p>
<h2 id="SynchronousQueue的实现方式？"><a href="#SynchronousQueue的实现方式？" class="headerlink" title="SynchronousQueue的实现方式？"></a>SynchronousQueue的实现方式？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Transferer抽象类，主要定义了一个transfer方法用来传输元素</span></span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">abstract</span> E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 以栈方式实现的Transferer</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferStack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">       <span class="comment">// 栈中节点的几种类型：</span></span><br><span class="line">       <span class="comment">// 1. 消费者（请求数据的）</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST    = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// 2. 生产者（提供数据的）</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATA       = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">// 3. 二者正在撮合中</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FULFILLING = <span class="number">2</span>;</span><br><span class="line">   </span><br><span class="line">       <span class="comment">// 栈中的节点</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SNode</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 下一个节点</span></span><br><span class="line">           <span class="keyword">volatile</span> SNode next;        <span class="comment">// next node in stack</span></span><br><span class="line">           <span class="comment">// 匹配者</span></span><br><span class="line">           <span class="keyword">volatile</span> SNode match;       <span class="comment">// the node matched to this</span></span><br><span class="line">           <span class="comment">// 等待着的线程</span></span><br><span class="line">           <span class="keyword">volatile</span> Thread waiter;     <span class="comment">// to control park/unpark</span></span><br><span class="line">           <span class="comment">// 元素</span></span><br><span class="line">           Object item;                <span class="comment">// data; or null for REQUESTs</span></span><br><span class="line">           <span class="comment">// 模式，也就是节点的类型，是消费者，是生产者，还是正在撮合中</span></span><br><span class="line">           <span class="keyword">int</span> mode;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 栈的头节点</span></span><br><span class="line">       <span class="keyword">volatile</span> SNode head;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 以队列方式实现的Transferer</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">       <span class="comment">// 队列中的节点</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">QNode</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 下一个节点</span></span><br><span class="line">           <span class="keyword">volatile</span> QNode next;          <span class="comment">// next node in queue</span></span><br><span class="line">           <span class="comment">// 存储的元素</span></span><br><span class="line">           <span class="keyword">volatile</span> Object item;         <span class="comment">// CAS&#x27;ed to or from null</span></span><br><span class="line">           <span class="comment">// 等待着的线程</span></span><br><span class="line">           <span class="keyword">volatile</span> Thread waiter;       <span class="comment">// to control park/unpark</span></span><br><span class="line">           <span class="comment">// 是否是数据节点</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">boolean</span> isData;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="comment">// 队列的头节点</span></span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode head;</span><br><span class="line">       <span class="comment">// 队列的尾节点</span></span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode tail;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>（1）定义了一个抽象类Transferer，里面定义了一个传输元素的方法；</p>
<p>（2）有两种传输元素的方法，一种是栈，一种是队列；</p>
<p>（3）栈的特点是后进先出，队列的特点是先进行出；</p>
<p>（4）栈只需要保存一个头节点就可以了，因为存取元素都是操作头节点；</p>
<p>（5）队列需要保存一个头节点一个尾节点，因为存元素操作尾节点，取元素操作头节点；</p>
<p>（6）每个节点中保存着存储的元素、等待着的线程，以及下一个节点；</p>
<h2 id="SynchronousQueue真的是无缓冲的吗？"><a href="#SynchronousQueue真的是无缓冲的吗？" class="headerlink" title="SynchronousQueue真的是无缓冲的吗？"></a>SynchronousQueue真的是无缓冲的吗？</h2><p>通过源码分析，我们可以发现其实SynchronousQueue内部或者使用栈或者使用队列来存储包含线程和元素值的节点，如果同一个模式的节点过多的话，它们都会存储进来，且都会阻塞着，所以，严格上来说，SynchronousQueue并不能算是一个无缓冲队列。</p>
<h2 id="SynchronousQueue怎么保证线程安全？"><a href="#SynchronousQueue怎么保证线程安全？" class="headerlink" title="SynchronousQueue怎么保证线程安全？"></a>SynchronousQueue怎么保证线程安全？</h2><p>我们这里主要介绍以栈方式实现的传输模式，以put(E e)方法为例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 元素不可为空</span></span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// 直接调用传输器的transfer()方法</span></span><br><span class="line">        <span class="comment">// 三个参数分别是：传输的元素，是否需要超时，超时的时间</span></span><br><span class="line">        <span class="keyword">if</span> (transferer.transfer(e, <span class="keyword">false</span>, <span class="number">0</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果传输失败，直接让线程中断并抛出中断异常</span></span><br><span class="line">            Thread.interrupted();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>调用transferer的transfer()方法，传入元素e，说明是生产者</p>
<p>我们这里主要介绍以栈方式实现的传输模式，以take()方法为例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="comment">// 直接调用传输器的transfer()方法</span></span><br><span class="line">       <span class="comment">// 三个参数分别是：null，是否需要超时，超时的时间</span></span><br><span class="line">       <span class="comment">// 第一个参数为null表示是消费者，要取元素</span></span><br><span class="line">       E e = transferer.transfer(<span class="keyword">null</span>, <span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">       <span class="comment">// 如果取到了元素就返回</span></span><br><span class="line">       <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> e;</span><br><span class="line">       <span class="comment">// 否则让线程中断并抛出中断异常</span></span><br><span class="line">       Thread.interrupted();</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>调用transferer的transfer()方法，传入null，说明是消费者。</p>
<h3 id="transfer-方法"><a href="#transfer-方法" class="headerlink" title="transfer()方法"></a>transfer()方法</h3><p>transfer()方法同时实现了取元素和放元素的功能，下面我再来看看这个transfer()方法里究竟干了什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TransferStack.transfer()方法</span></span><br><span class="line">    <span class="function">E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">        SNode s = <span class="keyword">null</span>; <span class="comment">// constructed/reused as needed</span></span><br><span class="line">        <span class="comment">// 根据e是否为null决定是生产者还是消费者</span></span><br><span class="line">        <span class="keyword">int</span> mode = (e == <span class="keyword">null</span>) ? REQUEST : DATA;</span><br><span class="line">        <span class="comment">// 自旋+CAS，熟悉的套路，熟悉的味道</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 栈顶元素</span></span><br><span class="line">            SNode h = head;</span><br><span class="line">            <span class="comment">// 栈顶没有元素，或者栈顶元素跟当前元素是一个模式的</span></span><br><span class="line">            <span class="comment">// 也就是都是生产者节点或者都是消费者节点</span></span><br><span class="line">            <span class="keyword">if</span> (h == <span class="keyword">null</span> || h.mode == mode) &#123;  <span class="comment">// empty or same-mode</span></span><br><span class="line">                <span class="comment">// 如果有超时而且已到期</span></span><br><span class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>) &#123;      <span class="comment">// can&#x27;t wait</span></span><br><span class="line">                    <span class="comment">// 如果头节点不为空且是取消状态</span></span><br><span class="line">                    <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.isCancelled())</span><br><span class="line">                        <span class="comment">// 就把头节点弹出，并进入下一次循环</span></span><br><span class="line">                        casHead(h, h.next);     <span class="comment">// pop cancelled node</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">// 否则，直接返回null（超时返回null）</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s = snode(s, e, h, mode))) &#123;</span><br><span class="line">                    <span class="comment">// 入栈成功（因为是模式相同的，所以只能入栈）</span></span><br><span class="line">                    <span class="comment">// 调用awaitFulfill()方法自旋+阻塞当前入栈的线程并等待被匹配到</span></span><br><span class="line">                    SNode m = awaitFulfill(s, timed, nanos);</span><br><span class="line">                    <span class="comment">// 如果m等于s，说明取消了，那么就把它清除掉，并返回null</span></span><br><span class="line">                    <span class="keyword">if</span> (m == s) &#123;               <span class="comment">// wait was cancelled</span></span><br><span class="line">                        clean(s);</span><br><span class="line">                        <span class="comment">// 被取消了返回null</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">    </span><br><span class="line">                    <span class="comment">// 到这里说明匹配到元素了</span></span><br><span class="line">                    <span class="comment">// 因为从awaitFulfill()里面出来要不被取消了要不就匹配到了</span></span><br><span class="line">    </span><br><span class="line">                    <span class="comment">// 如果头节点不为空，并且头节点的下一个节点是s</span></span><br><span class="line">                    <span class="comment">// 就把头节点换成s的下一个节点</span></span><br><span class="line">                    <span class="comment">// 也就是把h和s都弹出了</span></span><br><span class="line">                    <span class="comment">// 也就是把栈顶两个元素都弹出了</span></span><br><span class="line">                    <span class="keyword">if</span> ((h = head) != <span class="keyword">null</span> &amp;&amp; h.next == s)</span><br><span class="line">                        casHead(h, s.next);     <span class="comment">// help s&#x27;s fulfiller</span></span><br><span class="line">                    <span class="comment">// 根据当前节点的模式判断返回m还是s中的值</span></span><br><span class="line">                    <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isFulfilling(h.mode)) &#123; <span class="comment">// try to fulfill</span></span><br><span class="line">                <span class="comment">// 到这里说明头节点和当前节点模式不一样</span></span><br><span class="line">                <span class="comment">// 如果头节点不是正在撮合中</span></span><br><span class="line">    </span><br><span class="line">                <span class="comment">// 如果头节点已经取消了，就把它弹出栈</span></span><br><span class="line">                <span class="keyword">if</span> (h.isCancelled())            <span class="comment">// already cancelled</span></span><br><span class="line">                    casHead(h, h.next);         <span class="comment">// pop and retry</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123;</span><br><span class="line">                    <span class="comment">// 头节点没有在撮合中，就让当前节点先入队，再让他们尝试匹配</span></span><br><span class="line">                    <span class="comment">// 且s成为了新的头节点，它的状态是正在撮合中</span></span><br><span class="line">                    <span class="keyword">for</span> (;;) &#123; <span class="comment">// loop until matched or waiters disappear</span></span><br><span class="line">                        SNode m = s.next;       <span class="comment">// m is s&#x27;s match</span></span><br><span class="line">                        <span class="comment">// 如果m为null，说明除了s节点外的节点都被其它线程先一步撮合掉了</span></span><br><span class="line">                        <span class="comment">// 就清空栈并跳出内部循环，到外部循环再重新入栈判断</span></span><br><span class="line">                        <span class="keyword">if</span> (m == <span class="keyword">null</span>) &#123;        <span class="comment">// all waiters are gone</span></span><br><span class="line">                            casHead(s, <span class="keyword">null</span>);   <span class="comment">// pop fulfill node</span></span><br><span class="line">                            s = <span class="keyword">null</span>;           <span class="comment">// use new node next time</span></span><br><span class="line">                            <span class="keyword">break</span>;              <span class="comment">// restart main loop</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        SNode mn = m.next;</span><br><span class="line">                        <span class="comment">// 如果m和s尝试撮合成功，就弹出栈顶的两个元素m和s</span></span><br><span class="line">                        <span class="keyword">if</span> (m.tryMatch(s)) &#123;</span><br><span class="line">                            casHead(s, mn);     <span class="comment">// pop both s and m</span></span><br><span class="line">                            <span class="comment">// 返回撮合结果</span></span><br><span class="line">                            <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">                        &#125; <span class="keyword">else</span>                  <span class="comment">// lost match</span></span><br><span class="line">                            <span class="comment">// 尝试撮合失败，说明m已经先一步被其它线程撮合了</span></span><br><span class="line">                            <span class="comment">// 就协助清除它</span></span><br><span class="line">                            s.casNext(m, mn);   <span class="comment">// help unlink</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// help a fulfiller</span></span><br><span class="line">                <span class="comment">// 到这里说明当前节点和头节点模式不一样</span></span><br><span class="line">                <span class="comment">// 且头节点是正在撮合中</span></span><br><span class="line">    </span><br><span class="line">                SNode m = h.next;               <span class="comment">// m is h&#x27;s match</span></span><br><span class="line">                <span class="keyword">if</span> (m == <span class="keyword">null</span>)                  <span class="comment">// waiter is gone</span></span><br><span class="line">                    <span class="comment">// 如果m为null，说明m已经被其它线程先一步撮合了</span></span><br><span class="line">                    casHead(h, <span class="keyword">null</span>);           <span class="comment">// pop fulfilling node</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    SNode mn = m.next;</span><br><span class="line">                    <span class="comment">// 协助匹配，如果m和s尝试撮合成功，就弹出栈顶的两个元素m和s</span></span><br><span class="line">                    <span class="keyword">if</span> (m.tryMatch(h))          <span class="comment">// help match</span></span><br><span class="line">                        <span class="comment">// 将栈顶的两个元素弹出后，再让s重新入栈</span></span><br><span class="line">                        casHead(h, mn);         <span class="comment">// pop both h and m</span></span><br><span class="line">                    <span class="keyword">else</span>                        <span class="comment">// lost match</span></span><br><span class="line">                        <span class="comment">// 尝试撮合失败，说明m已经先一步被其它线程撮合了</span></span><br><span class="line">                        <span class="comment">// 就协助清除它</span></span><br><span class="line">                        h.casNext(m, mn);       <span class="comment">// help unlink</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 三个参数：需要等待的节点，是否需要超时，超时时间</span></span><br><span class="line">    <span class="function">SNode <span class="title">awaitFulfill</span><span class="params">(SNode s, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 到期时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">        <span class="comment">// 当前线程</span></span><br><span class="line">        Thread w = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 自旋次数</span></span><br><span class="line">        <span class="keyword">int</span> spins = (shouldSpin(s) ?</span><br><span class="line">                     (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 当前线程中断了，尝试清除s</span></span><br><span class="line">            <span class="keyword">if</span> (w.isInterrupted())</span><br><span class="line">                s.tryCancel();</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 检查s是否匹配到了元素m（有可能是其它线程的m匹配到当前线程的s）</span></span><br><span class="line">            SNode m = s.match;</span><br><span class="line">            <span class="comment">// 如果匹配到了，直接返回m</span></span><br><span class="line">            <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 如果需要超时</span></span><br><span class="line">            <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                <span class="comment">// 检查超时时间如果小于0了，尝试清除s</span></span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    s.tryCancel();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 如果还有自旋次数，自旋次数减一，并进入下一次自旋</span></span><br><span class="line">                spins = shouldSpin(s) ? (spins-<span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 后面的elseif都是自旋次数没有了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 如果s的waiter为null，把当前线程注入进去，并进入下一次自旋</span></span><br><span class="line">                s.waiter = w; <span class="comment">// establish waiter so can park next iter</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">                <span class="comment">// 如果不允许超时，直接阻塞，并等待被其它线程唤醒，唤醒后继续自旋并查看是否匹配到了元素</span></span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">                <span class="comment">// 如果允许超时且还有剩余时间，就阻塞相应时间</span></span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// SNode里面的方向，调用者m是s的下一个节点</span></span><br><span class="line">        <span class="comment">// 这时候m节点的线程应该是阻塞状态的</span></span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">tryMatch</span><span class="params">(SNode s)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果m还没有匹配者，就把s作为它的匹配者</span></span><br><span class="line">            <span class="keyword">if</span> (match == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, matchOffset, <span class="keyword">null</span>, s)) &#123;</span><br><span class="line">                Thread w = waiter;</span><br><span class="line">                <span class="keyword">if</span> (w != <span class="keyword">null</span>) &#123;    <span class="comment">// waiters need at most one unpark</span></span><br><span class="line">                    waiter = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 唤醒m中的线程，两者匹配完毕</span></span><br><span class="line">                    LockSupport.unpark(w);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 匹配到了返回true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 可能其它线程先一步匹配了m，返回其是否是s</span></span><br><span class="line">            <span class="keyword">return</span> match == s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个逻辑比较复杂，这里为了简单起见，屏蔽掉多线程处理的细节，只描述正常业务场景下的逻辑：</p>
<p>（1）如果栈中没有元素，或者栈顶元素跟将要入栈的元素模式一样，就入栈；</p>
<p>（2）入栈后自旋等待一会看有没有其它线程匹配到它，自旋完了还没匹配到元素就阻塞等待；</p>
<p>（3）阻塞等待被唤醒了说明其它线程匹配到了当前的元素，就返回匹配到的元素；</p>
<p>（4）如果两者模式不一样，且头节点没有在匹配中，就拿当前节点跟它匹配，匹配成功了就返回匹配到的元素；</p>
<p>（5）如果两者模式不一样，且头节点正在匹配中，当前线程就协助去匹配，匹配完成了再让当前节点重新入栈重新匹配；</p>
<h2 id="SynchronousQueue的公平模式和非公平模式有什么区别？"><a href="#SynchronousQueue的公平模式和非公平模式有什么区别？" class="headerlink" title="SynchronousQueue的公平模式和非公平模式有什么区别？"></a>SynchronousQueue的公平模式和非公平模式有什么区别？</h2><p>SynchronousQueue有两种实现方式，一种是公平（队列）方式，一种是非公平（栈）方式；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 默认非公平模式</span></span><br><span class="line">       <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 如果是公平模式就使用队列，如果是非公平模式就使用栈</span></span><br><span class="line">       transferer = fair ? <span class="keyword">new</span> TransferQueue&lt;E&gt;() : <span class="keyword">new</span> TransferStack&lt;E&gt;();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="SynchronousQueue在高并发情景下会有什么问题？"><a href="#SynchronousQueue在高并发情景下会有什么问题？" class="headerlink" title="SynchronousQueue在高并发情景下会有什么问题？"></a>SynchronousQueue在高并发情景下会有什么问题？</h2><p>试想一下，如果有多个生产者，但只有一个消费者，如果消费者处理不过来，是不是生产者都会阻塞起来？反之亦然。</p>
<p>这是一件很危险的事，所以，SynchronousQueue一般用于生产、消费的速度大致相当的情况，这样才不会导致系统中过多的线程处于阻塞状态。</p>
<h2 id="PriorityBlockingQueue的实现方式？"><a href="#PriorityBlockingQueue的实现方式？" class="headerlink" title="PriorityBlockingQueue的实现方式？"></a>PriorityBlockingQueue的实现方式？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认容量为11</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"><span class="comment">// 最大数组大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 存储元素的地方</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] queue;</span><br><span class="line"><span class="comment">// 元素个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">// 比较器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"><span class="comment">// 重入锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="comment">// 非空条件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="comment">// 扩容的时候使用的控制变量，CAS更新这个值，谁更新成功了谁扩容，其它线程让出CPU</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> allocationSpinLock;</span><br><span class="line"><span class="comment">// 不阻塞的优先级队列，非存储元素的地方，仅用于序列化/反序列化时</span></span><br><span class="line"><span class="keyword">private</span> PriorityQueue&lt;E&gt; q;</span><br></pre></td></tr></table></figure>

<p>（1）依然是使用一个数组来使用元素；</p>
<p>（2）使用一个锁加一个notEmpty条件来保证并发安全；</p>
<p>（3）使用一个变量的CAS操作来控制扩容；</p>
<h2 id="PriorityBlockingQueue是否需要扩容？"><a href="#PriorityBlockingQueue是否需要扩容？" class="headerlink" title="PriorityBlockingQueue是否需要扩容？"></a>PriorityBlockingQueue是否需要扩容？</h2><p>PriorityBlockingQueue扩容时使用一个单独变量的CAS操作来控制只有一个线程进行扩容；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryGrow</span><span class="params">(Object[] array, <span class="keyword">int</span> oldCap)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 先释放锁，因为是从offer()方法的锁内部过来的</span></span><br><span class="line">       <span class="comment">// 这里先释放锁，使用allocationSpinLock变量控制扩容的过程</span></span><br><span class="line">       <span class="comment">// 防止阻塞的线程过多</span></span><br><span class="line">       lock.unlock(); <span class="comment">// must release and then re-acquire main lock</span></span><br><span class="line">       Object[] newArray = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// CAS更新allocationSpinLock变量为1的线程获得扩容资格</span></span><br><span class="line">       <span class="keyword">if</span> (allocationSpinLock == <span class="number">0</span> &amp;&amp;</span><br><span class="line">           UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, allocationSpinLockOffset,</span><br><span class="line">                                    <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 旧容量小于64则翻倍，旧容量大于64则增加一半</span></span><br><span class="line">               <span class="keyword">int</span> newCap = oldCap + ((oldCap &lt; <span class="number">64</span>) ?</span><br><span class="line">                                      (oldCap + <span class="number">2</span>) : <span class="comment">// grow faster if small</span></span><br><span class="line">                                      (oldCap &gt;&gt; <span class="number">1</span>));</span><br><span class="line">               <span class="comment">// 判断新容量是否溢出</span></span><br><span class="line">               <span class="keyword">if</span> (newCap - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;    <span class="comment">// possible overflow</span></span><br><span class="line">                   <span class="keyword">int</span> minCap = oldCap + <span class="number">1</span>;</span><br><span class="line">                   <span class="keyword">if</span> (minCap &lt; <span class="number">0</span> || minCap &gt; MAX_ARRAY_SIZE)</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">                   newCap = MAX_ARRAY_SIZE;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 创建新数组</span></span><br><span class="line">               <span class="keyword">if</span> (newCap &gt; oldCap &amp;&amp; queue == array)</span><br><span class="line">                   newArray = <span class="keyword">new</span> Object[newCap];</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="comment">// 相当于解锁</span></span><br><span class="line">               allocationSpinLock = <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 只有进入了上面条件的才会满足这个条件</span></span><br><span class="line">       <span class="comment">// 意思是让其它线程让出CPU</span></span><br><span class="line">       <span class="keyword">if</span> (newArray == <span class="keyword">null</span>) <span class="comment">// back off if another thread is allocating</span></span><br><span class="line">           Thread.yield();</span><br><span class="line">       <span class="comment">// 再次加锁</span></span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="comment">// 判断新数组创建成功并且旧数组没有被替换过</span></span><br><span class="line">       <span class="keyword">if</span> (newArray != <span class="keyword">null</span> &amp;&amp; queue == array) &#123;</span><br><span class="line">           <span class="comment">// 队列赋值为新数组</span></span><br><span class="line">           queue = newArray;</span><br><span class="line">           <span class="comment">// 并拷贝旧数组元素到新数组中</span></span><br><span class="line">           System.arraycopy(array, <span class="number">0</span>, newArray, <span class="number">0</span>, oldCap);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>（1）解锁，解除offer()方法中加的锁；</p>
<p>（2）使用allocationSpinLock变量的CAS操作来控制扩容的过程；</p>
<p>（3）旧容量小于64则翻倍，旧容量大于64则增加一半；</p>
<p>（4）创建新数组；</p>
<p>（5）修改allocationSpinLock为0，相当于解锁；</p>
<p>（6）其它线程在扩容的过程中要让出CPU；</p>
<p>（7）再次加锁；</p>
<p>（8）新数组创建成功，把旧数组元素拷贝过来，并返回到offer()方法中继续添加元素操作；</p>
<h2 id="PriorityBlockingQueue怎么保证线程安全？"><a href="#PriorityBlockingQueue怎么保证线程安全？" class="headerlink" title="PriorityBlockingQueue怎么保证线程安全？"></a>PriorityBlockingQueue怎么保证线程安全？</h2><p>PriorityBlockingQueue使用一个锁+一个notEmpty条件控制并发安全；</p>
<p>每个阻塞队列都有四个方法，我们这里只分析一个offer(E e)方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 元素不能为空</span></span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">int</span> n, cap;</span><br><span class="line">        Object[] array;</span><br><span class="line">        <span class="comment">// 判断是否需要扩容，即元素个数达到了数组容量</span></span><br><span class="line">        <span class="keyword">while</span> ((n = size) &gt;= (cap = (array = queue).length))</span><br><span class="line">            tryGrow(array, cap);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</span><br><span class="line">            <span class="comment">// 根据是否有比较器选择不同的方法</span></span><br><span class="line">            <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">                siftUpComparable(n, e, array);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                siftUpUsingComparator(n, e, array, cmp);</span><br><span class="line">            <span class="comment">// 插入元素完毕，元素个数加1            </span></span><br><span class="line">            size = n + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 唤醒notEmpty条件</span></span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array)</span> </span>&#123;</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;) x;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 取父节点</span></span><br><span class="line">            <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 父节点的元素值</span></span><br><span class="line">            Object e = array[parent];</span><br><span class="line">            <span class="comment">// 如果key大于父节点，堆化结束</span></span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((T) e) &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 否则，交换二者的位置，继续下一轮比较</span></span><br><span class="line">            array[k] = e;</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到了应该放的位置，放入元素</span></span><br><span class="line">        array[k] = key;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>入队的整个操作跟PriorityQueue几乎一致：</p>
<p>（1）加锁；</p>
<p>（2）判断是否需要扩容；</p>
<p>（3）添加元素并做自下而上的堆化；</p>
<p>（4）元素个数加1并唤醒notEmpty条件，唤醒取元素的线程；</p>
<p>（5）解锁；</p>
<p>阻塞队列的出队方法也有四个，我们这里只分析一个take()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        E result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 队列没有元素，就阻塞在notEmpty条件上</span></span><br><span class="line">            <span class="comment">// 出队成功，就跳出这个循环</span></span><br><span class="line">            <span class="keyword">while</span> ( (result = dequeue()) == <span class="keyword">null</span>)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回出队的元素</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 元素个数减1</span></span><br><span class="line">        <span class="keyword">int</span> n = size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 数组元素不足，返回null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object[] array = queue;</span><br><span class="line">            <span class="comment">// 弹出堆顶元素</span></span><br><span class="line">            E result = (E) array[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 把堆尾元素拿到堆顶</span></span><br><span class="line">            E x = (E) array[n];</span><br><span class="line">            array[n] = <span class="keyword">null</span>;</span><br><span class="line">            Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</span><br><span class="line">            <span class="comment">// 并做自上而下的堆化</span></span><br><span class="line">            <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">                siftDownComparable(<span class="number">0</span>, x, array, n);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                siftDownUsingComparator(<span class="number">0</span>, x, array, n, cmp);</span><br><span class="line">            <span class="comment">// 修改size</span></span><br><span class="line">            size = n;</span><br><span class="line">            <span class="comment">// 返回出队的元素</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;)x;</span><br><span class="line">            <span class="keyword">int</span> half = n &gt;&gt;&gt; <span class="number">1</span>;           <span class="comment">// loop while a non-leaf</span></span><br><span class="line">            <span class="comment">// 只需要遍历到叶子节点就够了</span></span><br><span class="line">            <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">                <span class="comment">// 左子节点</span></span><br><span class="line">                <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line">                <span class="comment">// 左子节点的值</span></span><br><span class="line">                Object c = array[child];</span><br><span class="line">                <span class="comment">// 右子节点</span></span><br><span class="line">                <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 取左右子节点中最小的值</span></span><br><span class="line">                <span class="keyword">if</span> (right &lt; n &amp;&amp;</span><br><span class="line">                    ((Comparable&lt;? <span class="keyword">super</span> T&gt;) c).compareTo((T) array[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                    c = array[child = right];</span><br><span class="line">                <span class="comment">// key如果比左右子节点都小，则堆化结束</span></span><br><span class="line">                <span class="keyword">if</span> (key.compareTo((T) c) &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 否则，交换key与左右子节点中最小的节点的位置</span></span><br><span class="line">                array[k] = c;</span><br><span class="line">                k = child;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到了放元素的位置，放置元素</span></span><br><span class="line">            array[k] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>出队的过程与PriorityQueue基本类似：</p>
<p>（1）加锁；</p>
<p>（2）判断是否出队成功，未成功就阻塞在notEmpty条件上；</p>
<p>（3）出队时弹出堆顶元素，并把堆尾元素拿到堆顶；</p>
<p>（4）再做自上而下的堆化；</p>
<p>（5）解锁；</p>
<h2 id="PriorityBlockingQueue为什么不需要notFull条件？"><a href="#PriorityBlockingQueue为什么不需要notFull条件？" class="headerlink" title="PriorityBlockingQueue为什么不需要notFull条件？"></a>PriorityBlockingQueue为什么不需要notFull条件？</h2><p>因为PriorityBlockingQueue在入队的时候如果没有空间了是会自动扩容的，也就不存在队列满了的状态，也就是不需要等待通知队列不满了可以放元素了，所以也就不需要notFull条件了</p>
<h2 id="什么是双重队列？"><a href="#什么是双重队列？" class="headerlink" title="什么是双重队列？"></a>什么是双重队列？</h2><p>放取元素使用同一个队列，队列中的节点具有两种模式，一种是数据节点，一种是非数据节点。</p>
<p>放元素时先跟队列头节点对比，如果头节点是非数据节点，就让他们匹配，如果头节点是数据节点，就生成一个数据节点放在队列尾端（入队）。</p>
<p>取元素时也是先跟队列头节点对比，如果头节点是数据节点，就让他们匹配，如果头节点是非数据节点，就生成一个非数据节点放在队列尾端（入队）。</p>
<p>用图形来表示就是下面这样：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210817204016.png" alt="202105091521058242.png"></p>
<h2 id="LinkedTransferQueue是怎么实现阻塞队列的？"><a href="#LinkedTransferQueue是怎么实现阻塞队列的？" class="headerlink" title="LinkedTransferQueue是怎么实现阻塞队列的？"></a>LinkedTransferQueue是怎么实现阻塞队列的？</h2><p>LinkedTransferQueue可以看作LinkedBlockingQueue、SynchronousQueue（公平模式）、ConcurrentLinkedQueue三者的集合体；</p>
<p>LinkedTransferQueue的实现方式是使用一种叫做<code>双重队列</code>的数据结构；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否是数据节点（也就标识了是生产者还是消费者）</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isData;   <span class="comment">// false if this is a request node</span></span><br><span class="line">        <span class="comment">// 元素的值</span></span><br><span class="line">        <span class="keyword">volatile</span> Object item;   <span class="comment">// initially non-null if isData; CASed to match</span></span><br><span class="line">        <span class="comment">// 下一个节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">        <span class="comment">// 持有元素的线程</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter; <span class="comment">// null until waiting</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="LinkedTransferQueue是怎么控制并发安全的？"><a href="#LinkedTransferQueue是怎么控制并发安全的？" class="headerlink" title="LinkedTransferQueue是怎么控制并发安全的？"></a>LinkedTransferQueue是怎么控制并发安全的？</h2><p>LinkedTransferQueue全程都没有使用synchronized、重入锁等比较重的锁，基本是通过 自旋+CAS 实现；</p>
<p>不管是取元素还是放元素都会入队；</p>
<p>先尝试跟头节点比较，如果二者模式不一样，就匹配它们，组成CP，然后返回对方的值；</p>
<p>如果二者模式一样，就入队，并自旋或阻塞等待被唤醒；</p>
<p>至于是否入队及阻塞有四种模式，NOW、ASYNC、SYNC、TIMED；</p>
<h3 id="xfer"><a href="#xfer" class="headerlink" title="xfer()"></a>xfer()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">xfer</span><span class="params">(E e, <span class="keyword">boolean</span> haveData, <span class="keyword">int</span> how, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不允许放入空元素</span></span><br><span class="line">        <span class="keyword">if</span> (haveData &amp;&amp; (e == <span class="keyword">null</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        Node s = <span class="keyword">null</span>;                        <span class="comment">// the node to append, if needed</span></span><br><span class="line">        <span class="comment">// 外层循环，自旋，失败就重试</span></span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;                            <span class="comment">// restart on append race</span></span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 下面这个for循环用于控制匹配的过程</span></span><br><span class="line">            <span class="comment">// 同一时刻队列中只会存储一种类型的节点</span></span><br><span class="line">            <span class="comment">// 从头节点开始尝试匹配，如果头节点被其它线程先一步匹配了</span></span><br><span class="line">            <span class="comment">// 就再尝试其下一个，直到匹配到为止，或者到队列中没有元素为止</span></span><br><span class="line">    </span><br><span class="line">            <span class="keyword">for</span> (Node h = head, p = h; p != <span class="keyword">null</span>;) &#123; <span class="comment">// find &amp; match first node</span></span><br><span class="line">                <span class="comment">// p节点的模式</span></span><br><span class="line">                <span class="keyword">boolean</span> isData = p.isData;</span><br><span class="line">                <span class="comment">// p节点的值</span></span><br><span class="line">                Object item = p.item;</span><br><span class="line">                <span class="comment">// p没有被匹配到</span></span><br><span class="line">                <span class="keyword">if</span> (item != p &amp;&amp; (item != <span class="keyword">null</span>) == isData) &#123; <span class="comment">// unmatched</span></span><br><span class="line">                    <span class="comment">// 如果两者模式一样，则不能匹配，跳出循环后尝试入队</span></span><br><span class="line">                    <span class="keyword">if</span> (isData == haveData)   <span class="comment">// can&#x27;t match</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 如果两者模式不一样，则尝试匹配</span></span><br><span class="line">                    <span class="comment">// 把p的值设置为e（如果是取元素则e是null，如果是放元素则e是元素值）</span></span><br><span class="line">                    <span class="keyword">if</span> (p.casItem(item, e)) &#123; <span class="comment">// match</span></span><br><span class="line">                        <span class="comment">// 匹配成功</span></span><br><span class="line">                        <span class="comment">// for里面的逻辑比较复杂，用于控制多线程同时放取元素时出现竞争的情况的</span></span><br><span class="line">                        <span class="comment">// 看不懂可以直接跳过</span></span><br><span class="line">                        <span class="keyword">for</span> (Node q = p; q != h;) &#123;</span><br><span class="line">                            <span class="comment">// 进入到这里可能是头节点已经被匹配，然后p会变成h的下一个节点</span></span><br><span class="line">                            Node n = q.next;  <span class="comment">// update by 2 unless singleton</span></span><br><span class="line">                            <span class="comment">// 如果head还没变，就把它更新成新的节点</span></span><br><span class="line">                            <span class="comment">// 并把它删除（forgetNext()会把它的next设为自己，也就是从单链表中删除了）</span></span><br><span class="line">                            <span class="comment">// 这时为什么要把head设为n呢？因为到这里了，肯定head本身已经被匹配掉了</span></span><br><span class="line">                            <span class="comment">// 而上面的p.casItem()又成功了，说明p也被当前这个元素给匹配掉了</span></span><br><span class="line">                            <span class="comment">// 所以需要把它们俩都出队列，让其它线程可以从真正的头开始，不用重复检查了</span></span><br><span class="line">                            <span class="keyword">if</span> (head == h &amp;&amp; casHead(h, n == <span class="keyword">null</span> ? q : n)) &#123;</span><br><span class="line">                                h.forgetNext();</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;                 <span class="comment">// advance and retry</span></span><br><span class="line">                            <span class="comment">// 如果新的头节点为空，或者其next为空，或者其next未匹配，就重试</span></span><br><span class="line">                            <span class="keyword">if</span> ((h = head)   == <span class="keyword">null</span> ||</span><br><span class="line">                                (q = h.next) == <span class="keyword">null</span> || !q.isMatched())</span><br><span class="line">                                <span class="keyword">break</span>;        <span class="comment">// unless slack &lt; 2</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 唤醒p中等待的线程</span></span><br><span class="line">                        LockSupport.unpark(p.waiter);</span><br><span class="line">                        <span class="comment">// 并返回匹配到的元素</span></span><br><span class="line">                        <span class="keyword">return</span> LinkedTransferQueue.&lt;E&gt;cast(item);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// p已经被匹配了或者尝试匹配的时候失败了</span></span><br><span class="line">                <span class="comment">// 也就是其它线程先一步匹配了p</span></span><br><span class="line">                <span class="comment">// 这时候又分两种情况，p的next还没来得及修改，p的next指向了自己</span></span><br><span class="line">                <span class="comment">// 如果p的next已经指向了自己，就重新取head重试，否则就取其next重试</span></span><br><span class="line">                Node n = p.next;</span><br><span class="line">                p = (p != n) ? n : (h = head); <span class="comment">// Use head if p offlist</span></span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 到这里肯定是队列中存储的节点类型和自己一样</span></span><br><span class="line">            <span class="comment">// 或者队列中没有元素了</span></span><br><span class="line">            <span class="comment">// 就入队（不管放元素还是取元素都得入队）</span></span><br><span class="line">            <span class="comment">// 入队又分成四种情况：</span></span><br><span class="line">            <span class="comment">// NOW，立即返回，没有匹配到立即返回，不做入队操作</span></span><br><span class="line">            <span class="comment">// ASYNC，异步，元素入队但当前线程不会阻塞（相当于无界LinkedBlockingQueue的元素入队）</span></span><br><span class="line">            <span class="comment">// SYNC，同步，元素入队后当前线程阻塞，等待被匹配到</span></span><br><span class="line">            <span class="comment">// TIMED，有超时，元素入队后等待一段时间被匹配，时间到了还没匹配到就返回元素本身</span></span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 如果不是立即返回</span></span><br><span class="line">            <span class="keyword">if</span> (how != NOW) &#123;                 <span class="comment">// No matches available</span></span><br><span class="line">                <span class="comment">// 新建s节点</span></span><br><span class="line">                <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">                    s = <span class="keyword">new</span> Node(e, haveData);</span><br><span class="line">                <span class="comment">// 尝试入队</span></span><br><span class="line">                Node pred = tryAppend(s, haveData);</span><br><span class="line">                <span class="comment">// 入队失败，重试</span></span><br><span class="line">                <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">continue</span> retry;           <span class="comment">// lost race vs opposite mode</span></span><br><span class="line">                <span class="comment">// 如果不是异步（同步或者有超时）</span></span><br><span class="line">                <span class="comment">// 就等待被匹配</span></span><br><span class="line">                <span class="keyword">if</span> (how != ASYNC)</span><br><span class="line">                    <span class="keyword">return</span> awaitMatch(s, pred, e, (how == TIMED), nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> e; <span class="comment">// not waiting</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">tryAppend</span><span class="params">(Node s, <span class="keyword">boolean</span> haveData)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从tail开始遍历，把s放到链表尾端</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail, p = t;;) &#123;        <span class="comment">// move p to last node and append</span></span><br><span class="line">            Node n, u;                        <span class="comment">// temps for reads of next &amp; tail</span></span><br><span class="line">            <span class="comment">// 如果首尾都是null，说明链表中还没有元素</span></span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; (p = head) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 就让首节点指向s</span></span><br><span class="line">                <span class="comment">// 注意，这里插入第一个元素的时候tail指针并没有指向s</span></span><br><span class="line">                <span class="keyword">if</span> (casHead(<span class="keyword">null</span>, s))</span><br><span class="line">                    <span class="keyword">return</span> s;                 <span class="comment">// initialize</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p.cannotPrecede(haveData))</span><br><span class="line">                <span class="comment">// 如果p无法处理，则返回null</span></span><br><span class="line">                <span class="comment">// 这里无法处理的意思是，p和s节点的类型不一样，不允许s入队</span></span><br><span class="line">                <span class="comment">// 比如，其它线程先入队了一个数据节点，这时候要入队一个非数据节点，就不允许，</span></span><br><span class="line">                <span class="comment">// 队列中所有的元素都要保证是同一种类型的节点</span></span><br><span class="line">                <span class="comment">// 返回null后外面的方法会重新尝试匹配重新入队等</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;                  <span class="comment">// lost race vs opposite mode</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((n = p.next) != <span class="keyword">null</span>)    <span class="comment">// not last; keep traversing</span></span><br><span class="line">                <span class="comment">// 如果p的next不为空，说明不是最后一个节点</span></span><br><span class="line">                <span class="comment">// 则让p重新指向最后一个节点</span></span><br><span class="line">                p = p != t &amp;&amp; t != (u = tail) ? (t = u) : <span class="comment">// stale tail</span></span><br><span class="line">                    (p != n) ? n : <span class="keyword">null</span>;      <span class="comment">// restart if off list</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!p.casNext(<span class="keyword">null</span>, s))</span><br><span class="line">                <span class="comment">// 如果CAS更新s为p的next失败</span></span><br><span class="line">                <span class="comment">// 则说明有其它线程先一步更新到p的next了</span></span><br><span class="line">                <span class="comment">// 就让p指向p的next，重新尝试让s入队</span></span><br><span class="line">                p = p.next;                   <span class="comment">// re-read on CAS failure</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 到这里说明s成功入队了</span></span><br><span class="line">                <span class="comment">// 如果p不等于t，就更新tail指针</span></span><br><span class="line">                <span class="comment">// 还记得上面插入第一个元素时tail指针并没有指向新元素吗？</span></span><br><span class="line">                <span class="comment">// 这里就是用来更新tail指针的</span></span><br><span class="line">                <span class="keyword">if</span> (p != t) &#123;                 <span class="comment">// update if slack now &gt;= 2</span></span><br><span class="line">                    <span class="keyword">while</span> ((tail != t || !casTail(t, s)) &amp;&amp;</span><br><span class="line">                           (t = tail)   != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                           (s = t.next) != <span class="keyword">null</span> &amp;&amp; <span class="comment">// advance and retry</span></span><br><span class="line">                           (s = s.next) != <span class="keyword">null</span> &amp;&amp; s != t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 返回p，即s的前一个元素</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">awaitMatch</span><span class="params">(Node s, Node pred, E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果是有超时的，计算其超时时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">        <span class="comment">// 当前线程</span></span><br><span class="line">        Thread w = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 自旋次数</span></span><br><span class="line">        <span class="keyword">int</span> spins = -<span class="number">1</span>; <span class="comment">// initialized after first item and cancel checks</span></span><br><span class="line">        <span class="comment">// 随机数，随机让一些自旋的线程让出CPU</span></span><br><span class="line">        ThreadLocalRandom randomYields = <span class="keyword">null</span>; <span class="comment">// bound if needed</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Object item = s.item;</span><br><span class="line">            <span class="comment">// 如果s元素的值不等于e，说明它被匹配到了</span></span><br><span class="line">            <span class="keyword">if</span> (item != e) &#123;                  <span class="comment">// matched</span></span><br><span class="line">                <span class="comment">// assert item != s;</span></span><br><span class="line">                <span class="comment">// 把s的item更新为s本身</span></span><br><span class="line">                <span class="comment">// 并把s中的waiter置为空</span></span><br><span class="line">                s.forgetContents();           <span class="comment">// avoid garbage</span></span><br><span class="line">                <span class="comment">// 返回匹配到的元素</span></span><br><span class="line">                <span class="keyword">return</span> LinkedTransferQueue.&lt;E&gt;cast(item);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前线程中断了，或者有超时的到期了</span></span><br><span class="line">            <span class="comment">// 就更新s的元素值指向s本身</span></span><br><span class="line">            <span class="keyword">if</span> ((w.isInterrupted() || (timed &amp;&amp; nanos &lt;= <span class="number">0</span>)) &amp;&amp;</span><br><span class="line">                    s.casItem(e, s)) &#123;        <span class="comment">// cancel</span></span><br><span class="line">                <span class="comment">// 尝试解除s与其前一个节点的关系</span></span><br><span class="line">                <span class="comment">// 也就是删除s节点</span></span><br><span class="line">                unsplice(pred, s);</span><br><span class="line">                <span class="comment">// 返回元素的值本身，说明没匹配到</span></span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 如果自旋次数小于0，就计算自旋次数</span></span><br><span class="line">            <span class="keyword">if</span> (spins &lt; <span class="number">0</span>) &#123;                  <span class="comment">// establish spins at/near front</span></span><br><span class="line">                <span class="comment">// spinsFor()计算自旋次数</span></span><br><span class="line">                <span class="comment">// 如果前面有节点未被匹配就返回0</span></span><br><span class="line">                <span class="comment">// 如果前面有节点且正在匹配中就返回一定的次数，等待</span></span><br><span class="line">                <span class="keyword">if</span> ((spins = spinsFor(pred, s.isData)) &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 初始化随机数</span></span><br><span class="line">                    randomYields = ThreadLocalRandom.current();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;             <span class="comment">// spin</span></span><br><span class="line">                <span class="comment">// 还有自旋次数就减1</span></span><br><span class="line">                --spins;</span><br><span class="line">                <span class="comment">// 并随机让出CPU</span></span><br><span class="line">                <span class="keyword">if</span> (randomYields.nextInt(CHAINED_SPINS) == <span class="number">0</span>)</span><br><span class="line">                    Thread.yield();           <span class="comment">// occasionally yield</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 更新s的waiter为当前线程</span></span><br><span class="line">                s.waiter = w;                 <span class="comment">// request unpark then recheck</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                <span class="comment">// 如果有超时，计算超时时间，并阻塞一定时间</span></span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不是超时的，直接阻塞，等待被唤醒</span></span><br><span class="line">                <span class="comment">// 唤醒后进入下一次循环，走第一个if的逻辑就返回匹配的元素了</span></span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这三个方法里的内容特别复杂，很大一部分代码都是在控制线程安全，各种CAS，我们这里简单描述一下大致的逻辑：</p>
<p>（1）来了一个元素，我们先查看队列头的节点，是否与这个元素的模式一样；</p>
<p>（2）如果模式不一样，就尝试让他们匹配，如果头节点被别的线程先匹配走了，就尝试与头节点的下一个节点匹配，如此一直往后，直到匹配到或到链表尾为止；</p>
<p>（3）如果模式一样，或者到链表尾了，就尝试入队；</p>
<p>（4）入队的时候有可能链表尾修改了，那就尾指针后移，再重新尝试入队，依此往复；</p>
<p>（5）入队成功了，就自旋或阻塞，阻塞了就等待被其它线程匹配到并唤醒；</p>
<p>（6）唤醒之后进入下一次循环就匹配到元素了，返回匹配到的元素；</p>
<p>（7）是否需要入队及阻塞有四种情况：</p>
<p>a）NOW，立即返回，没有匹配到立即返回，不做入队操作<br>    对应的方法有：poll()、tryTransfer(e)<br>       b）ASYNC，异步，元素入队但当前线程不会阻塞（相当于无界LinkedBlockingQueue的元素入队）<br>    对应的方法有：add(e)、offer(e)、put(e)、offer(e, timeout, unit)<br>       c）SYNC，同步，元素入队后当前线程阻塞，等待被匹配到<br>    对应的方法有：take()、transfer(e)<br>      d）TIMED，有超时，元素入队后等待一段时间被匹配，时间到了还没匹配到就返回元素本身<br>    对应的方法有：poll(timeout, unit)、tryTransfer(e, timeout, unit)</p>
<h2 id="LinkedTransferQueue与SynchronousQueue有什么异同？"><a href="#LinkedTransferQueue与SynchronousQueue有什么异同？" class="headerlink" title="LinkedTransferQueue与SynchronousQueue有什么异同？"></a>LinkedTransferQueue与SynchronousQueue有什么异同？</h2><p>（1）在java8中两者的实现方式基本一致，都是使用的双重队列；</p>
<p>（2）前者完全实现了后者，但比后者更灵活；</p>
<p>（3）后者不管放元素还是取元素，如果没有可匹配的元素，所在的线程都会阻塞；</p>
<p>（4）前者可以自己控制放元素是否需要阻塞线程，比如使用四个添加元素的方法就不会阻塞线程，只入队元素，使用transfer()会阻塞线程；</p>
<p>（5）取元素两者基本一样，都会阻塞等待有新的元素进入被匹配到；</p>
<h2 id="ConcurrentLinkedQueue是阻塞队列吗？"><a href="#ConcurrentLinkedQueue是阻塞队列吗？" class="headerlink" title="ConcurrentLinkedQueue是阻塞队列吗？"></a>ConcurrentLinkedQueue是阻塞队列吗？</h2><p>ConcurrentLinkedQueue不是阻塞队列；ConcurrentLinkedQueue只实现了Queue接口，并没有实现BlockingQueue接口，所以它不是阻塞队列，也不能用于线程池中，但是它是线程安全的，可用于多线程环境中。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210817205205.png" alt="image-20210817205204809"></p>
<h2 id="ConcurrentLinkedQueue如何保证并发安全？"><a href="#ConcurrentLinkedQueue如何保证并发安全？" class="headerlink" title="ConcurrentLinkedQueue如何保证并发安全？"></a>ConcurrentLinkedQueue如何保证并发安全？</h2><p>能</p>
<p>因为它不是阻塞队列，所以只有两个入队的方法，add(e)和offer(e)。</p>
<p>因为是无界队列，所以add(e)方法也不用抛出异常了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> offer(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不能添加空元素</span></span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        <span class="comment">// 新节点</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 入队到链表尾</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">            Node&lt;E&gt; q = p.next;</span><br><span class="line">            <span class="comment">// 如果没有next，说明到链表尾部了，就入队</span></span><br><span class="line">            <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// CAS更新p的next为新节点</span></span><br><span class="line">                <span class="comment">// 如果成功了，就返回true</span></span><br><span class="line">                <span class="comment">// 如果不成功就重新取next重新尝试</span></span><br><span class="line">                <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123;</span><br><span class="line">                    <span class="comment">// 如果p不等于t，说明有其它线程先一步更新tail</span></span><br><span class="line">                    <span class="comment">// 也就不会走到q==null这个分支了</span></span><br><span class="line">                    <span class="comment">// p取到的可能是t后面的值</span></span><br><span class="line">                    <span class="comment">// 把tail原子更新为新节点</span></span><br><span class="line">                    <span class="keyword">if</span> (p != t) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                        casTail(t, newNode);  <span class="comment">// Failure is OK.</span></span><br><span class="line">                    <span class="comment">// 返回入队成功</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                <span class="comment">// 如果p的next等于p，说明p已经被删除了（已经出队了）</span></span><br><span class="line">                <span class="comment">// 重新设置p的值</span></span><br><span class="line">                p = (t != (t = tail)) ? t : head;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// t后面还有值，重新设置p的值</span></span><br><span class="line">                p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>入队整个流程还是比较清晰的，这里有个前提是出队时会把出队的那个节点的next设置为节点本身。</p>
<p>（1）定位到链表尾部，尝试把新节点到后面；</p>
<p>（2）如果尾部变化了，则重新获取尾部，再重试；</p>
<p>因为它不是阻塞队列，所以只有两个出队的方法，remove()和poll()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E x = poll();</span><br><span class="line">        <span class="keyword">if</span> (x != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        restartFromHead:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 尝试弹出链表的头节点</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">                E item = p.item;</span><br><span class="line">                <span class="comment">// 如果节点的值不为空，并且将其更新为null成功了</span></span><br><span class="line">                <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 如果头节点变了，则不会走到这个分支</span></span><br><span class="line">                    <span class="comment">// 会先走下面的分支拿到新的头节点</span></span><br><span class="line">                    <span class="comment">// 这时候p就不等于h了，就更新头节点</span></span><br><span class="line">                    <span class="comment">// 在updateHead()中会把head更新为新节点</span></span><br><span class="line">                    <span class="comment">// 并让head的next指向其自己</span></span><br><span class="line">                    <span class="keyword">if</span> (p != h) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                        updateHead(h, ((q = p.next) != <span class="keyword">null</span>) ? q : p);</span><br><span class="line">                    <span class="comment">// 上面的casItem()成功，就可以返回出队的元素了</span></span><br><span class="line">                    <span class="keyword">return</span> item;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 下面三个分支说明头节点变了</span></span><br><span class="line">                <span class="comment">// 且p的item肯定为null</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果p的next为空，说明队列中没有元素了</span></span><br><span class="line">                    <span class="comment">// 更新h为p，也就是空元素的节点</span></span><br><span class="line">                    updateHead(h, p);</span><br><span class="line">                    <span class="comment">// 返回null</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                    <span class="comment">// 如果p等于p的next，说明p已经出队了，重试</span></span><br><span class="line">                    <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 将p设置为p的next</span></span><br><span class="line">                    p = q;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新头节点的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateHead</span><span class="params">(Node&lt;E&gt; h, Node&lt;E&gt; p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 原子更新h为p成功后，延迟更新h的next为它自己</span></span><br><span class="line">        <span class="comment">// 这里用延迟更新是安全的，因为head节点已经变了</span></span><br><span class="line">        <span class="comment">// 只要入队出队的时候检查head有没有变化就行了，跟它的next关系不大</span></span><br><span class="line">        <span class="keyword">if</span> (h != p &amp;&amp; casHead(h, p))</span><br><span class="line">            h.lazySetNext(h);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>出队的整个逻辑也是比较清晰的：</p>
<p>（1）定位到头节点，尝试更新其值为null；</p>
<p>（2）如果成功了，就成功出队；</p>
<p>（3）如果失败或者头节点变化了，就重新寻找头节点，并重试；</p>
<p>（4）整个出队过程没有一点阻塞相关的代码，所以出队的时候不会阻塞线程，没找到元素就返回null；</p>
<h2 id="ConcurrentLinkedQueue能用于线程池吗？"><a href="#ConcurrentLinkedQueue能用于线程池吗？" class="headerlink" title="ConcurrentLinkedQueue能用于线程池吗？"></a>ConcurrentLinkedQueue能用于线程池吗？</h2><p>ConcurrentLinkedQueue不能用在线程池中；因为不是阻塞队列。</p>
<h2 id="ConcurrentLinkedQueue与LinkedBlockingQueue对比？"><a href="#ConcurrentLinkedQueue与LinkedBlockingQueue对比？" class="headerlink" title="ConcurrentLinkedQueue与LinkedBlockingQueue对比？"></a>ConcurrentLinkedQueue与LinkedBlockingQueue对比？</h2><p>（1）两者都是线程安全的队列；</p>
<p>（2）两者都可以实现取元素时队列为空直接返回null，后者的poll()方法可以实现此功能；</p>
<p>（3）前者全程无锁，后者全部都是使用重入锁控制的；</p>
<p>（4）前者效率较高，后者效率较低；</p>
<p>（5）前者无法实现如果队列为空等待元素到来的操作；</p>
<p>（6）前者是非阻塞队列，后者是阻塞队列；</p>
<p>（7）前者无法用在线程池中，后者可以；</p>
<h2 id="DelayQueue是阻塞-队列吗？"><a href="#DelayQueue是阻塞-队列吗？" class="headerlink" title="DelayQueue是阻塞-队列吗？"></a>DelayQueue是阻塞-队列吗？</h2><p>从继承体系可以看到，DelayQueue实现了BlockingQueue，所以它是一个阻塞队列。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210817205623.png" alt="image-20210817205623249"></p>
<h2 id="DelayQueue的实现方式？"><a href="#DelayQueue的实现方式？" class="headerlink" title="DelayQueue的实现方式？"></a>DelayQueue的实现方式？</h2><p>DelayQueue内部存储结构使用优先级队列；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于控制并发的锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 优先级队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> PriorityQueue&lt;E&gt;();</span><br><span class="line">    <span class="comment">// 用于标记当前是否有线程在排队（仅用于取元素时）</span></span><br><span class="line">    <span class="keyword">private</span> Thread leader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 条件，用于表示现在是否有可取的元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition();</span><br></pre></td></tr></table></figure>

<h2 id="DelayQueue如何保证并发安全"><a href="#DelayQueue如何保证并发安全" class="headerlink" title="DelayQueue如何保证并发安全?"></a>DelayQueue如何保证并发安全?</h2><p>DelayQueue使用重入锁和条件来控制并发安全；</p>
<p>因为DelayQueue是阻塞队列，且优先级队列是无界的，所以入队不会阻塞不会超时，因此它的四个入队方法是一样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> offer(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        offer(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> offer(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            q.offer(e);</span><br><span class="line">            <span class="keyword">if</span> (q.peek() == e) &#123;</span><br><span class="line">                leader = <span class="keyword">null</span>;</span><br><span class="line">                available.signal();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>入队方法比较简单：</p>
<p>（1）加锁；</p>
<p>（2）添加元素到优先级队列中；</p>
<p>（3）如果添加的元素是堆顶元素，就把leader置为空，并唤醒等待在条件available上的线程；</p>
<p>（4）解锁；</p>
<p>因为DelayQueue是阻塞队列，所以它的出队有四个不同的方法，有抛出异常的，有阻塞的，有不阻塞的，有超时的。</p>
<p>我们这里主要分析两个，poll()和take()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            E first = q.peek();</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span> || first.getDelay(NANOSECONDS) &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> q.poll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>poll()方法比较简单：</p>
<p>（1）加锁；</p>
<p>（2）检查第一个元素，如果为空或者还没到期，就返回null；</p>
<p>（3）如果第一个元素到期了就调用poll()弹出第一个元素；</p>
<p>（4）解锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 堆顶元素</span></span><br><span class="line">                E first = q.peek();</span><br><span class="line">                <span class="comment">// 如果堆顶元素为空，说明队列中还没有元素，直接阻塞等待</span></span><br><span class="line">                <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 堆顶元素的到期时间</span></span><br><span class="line">                    <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                    <span class="comment">// 如果小于0说明已到期，直接调用poll()方法弹出堆顶元素</span></span><br><span class="line">                    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> q.poll();</span><br><span class="line">    </span><br><span class="line">                    <span class="comment">// 如果delay大于0 ，则下面要阻塞了</span></span><br><span class="line">    </span><br><span class="line">                    <span class="comment">// 将first置为空方便gc，因为有可能其它元素弹出了这个元素</span></span><br><span class="line">                    <span class="comment">// 这里还持有着引用不会被清理</span></span><br><span class="line">                    first = <span class="keyword">null</span>; <span class="comment">// don&#x27;t retain ref while waiting</span></span><br><span class="line">                    <span class="comment">// 如果前面有其它线程在等待，直接进入等待</span></span><br><span class="line">                    <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                        available.await();</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 如果leader为null，把当前线程赋值给它</span></span><br><span class="line">                        Thread thisThread = Thread.currentThread();</span><br><span class="line">                        leader = thisThread;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 等待delay时间后自动醒过来</span></span><br><span class="line">                            <span class="comment">// 醒过来后把leader置空并重新进入循环判断堆顶元素是否到期</span></span><br><span class="line">                            <span class="comment">// 这里即使醒过来后也不一定能获取到元素</span></span><br><span class="line">                            <span class="comment">// 因为有可能其它线程先一步获取了锁并弹出了堆顶元素</span></span><br><span class="line">                            <span class="comment">// 条件锁的唤醒分成两步，先从Condition的队列里出队</span></span><br><span class="line">                            <span class="comment">// 再入队到AQS的队列中，当其它线程调用LockSupport.unpark(t)的时候才会真正唤醒</span></span><br><span class="line">                            <span class="comment">// 关于AQS我们后面会讲的^^</span></span><br><span class="line">                            available.awaitNanos(delay);</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="comment">// 如果leader还是当前线程就把它置为空，让其它线程有机会获取元素</span></span><br><span class="line">                            <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                                leader = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 成功出队后，如果leader为空且堆顶还有元素，就唤醒下一个等待的线程</span></span><br><span class="line">            <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// signal()只是把等待的线程放到AQS的队列里面，并不是真正的唤醒</span></span><br><span class="line">                available.signal();</span><br><span class="line">            <span class="comment">// 解锁，这才是真正的唤醒</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>take()方法稍微要复杂一些：</p>
<p>（1）加锁；</p>
<p>（2）判断堆顶元素是否为空，为空的话直接阻塞等待；</p>
<p>（3）判断堆顶元素是否到期，到期了直接poll()出元素；</p>
<p>（4）没到期，再判断前面是否有其它线程在等待，有则直接等待；</p>
<p>（5）前面没有其它线程在等待，则把自己当作第一个线程等待delay时间后唤醒，再尝试获取元素；</p>
<p>（6）获取到元素之后再唤醒下一个等待的线程；</p>
<p>（7）解锁；</p>
<h2 id="DelayQueue主要用于什么场景？"><a href="#DelayQueue主要用于什么场景？" class="headerlink" title="DelayQueue主要用于什么场景？"></a>DelayQueue主要用于什么场景？</h2><p>DelayQueue常用于定时任务</p>
<h2 id="java中的线程池实现定时任务是直接用的DelayQueue吗？"><a href="#java中的线程池实现定时任务是直接用的DelayQueue吗？" class="headerlink" title="java中的线程池实现定时任务是直接用的DelayQueue吗？"></a>java中的线程池实现定时任务是直接用的DelayQueue吗？</h2><p>当然不是，ScheduledThreadPoolExecutor中使用的是它自己定义的内部类DelayedWorkQueue，其实里面的实现逻辑基本都是一样的，只不过DelayedWorkQueue里面没有使用现在的PriorityQueue，而是使用数组又实现了一遍优先级队列，本质上没有什么区别。</p>
<h2 id="什么是双端队列？"><a href="#什么是双端队列？" class="headerlink" title="什么是双端队列？"></a>什么是双端队列？</h2><p>双端队列是一种特殊的队列，它的两端都可以进出元素，故而得名双端队列。</p>
<h2 id="ArrayDeque是怎么实现双端队列的？"><a href="#ArrayDeque是怎么实现双端队列的？" class="headerlink" title="ArrayDeque是怎么实现双端队列的？"></a>ArrayDeque是怎么实现双端队列的？</h2><p>ArrayDeque是一种以数组方式实现的双端队列，它是非线程安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储元素的数组</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elements; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line">    <span class="comment">// 队列头位置</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> head;</span><br><span class="line">    <span class="comment">// 队列尾位置</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="comment">// 最小初始容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_INITIAL_CAPACITY = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<h2 id="LinkedList与ArrayDeque的对比？"><a href="#LinkedList与ArrayDeque的对比？" class="headerlink" title="LinkedList与ArrayDeque的对比？"></a>LinkedList与ArrayDeque的对比？</h2><p>   ArrayList、ArrayDeque内部以数组的形式保存集合中的元素，因此随机访问元素时有较好的性能；而LinkedList内部以链表的形式来保存集合中的元素，因此随机访问集合中的元素时虽然性能较差，但在插入、删除元素时性能非常出色（只需要改变指针所指的地址即可）。需要指出的是，虽然Vector也是以数组的形式来存储</p>
<h2 id="双端队列是否可以作为栈使用？"><a href="#双端队列是否可以作为栈使用？" class="headerlink" title="双端队列是否可以作为栈使用？"></a>双端队列是否可以作为栈使用？</h2><p>可以</p>
<p>ArrayDeque可以直接作为栈使用；</p>
<h2 id="LinkedList是List和Deque的集合体？"><a href="#LinkedList是List和Deque的集合体？" class="headerlink" title="LinkedList是List和Deque的集合体？"></a>LinkedList是List和Deque的集合体？</h2><p>是</p>
<p>LinkedList在功能上等于ArrayList + ArrayDeque；</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210817210645.png" alt="image-20210817210645275"></p>
<h2 id="集合指定初始容量的好处？"><a href="#集合指定初始容量的好处？" class="headerlink" title="集合指定初始容量的好处？"></a>集合指定初始容量的好处？</h2><p>集合是我们在Java编程中使用非常广泛的，它就像大海，海纳百川，像万能容器，盛装万物，而且这个大海，万能容器还可以无限变大（如果条件允许）。当这个海、容器的量变得非常大的时候，它的初始容量就会显得很重要了，因为挖海、扩容是需要消耗大量的人力物力财力的。同样的道理，Collection的初始容量也显得异常重要。所以：<strong>对于已知的情景，请为集合指定初始容量。</strong></p>
<p>如ArrayList每次新增一个元素，就会检测ArrayList的当前容量是否已经到达临界点，如果到达临界点则会扩容1.5倍。然而ArrayList的扩容以及数组的拷贝生成新的数组是相当耗资源的。所以若我们事先已知集合的使用场景，知道集合的大概范围，我们最好是指定初始化容量，这样对资源的利用会更加好，尤其是大数据量的前提下，效率的提升和资源的利用会显得更加具有优势。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小肥龙吃大冰淇淋</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lvxueyang.vip/post/4f9185fb.html">http://lvxueyang.vip/post/4f9185fb.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://lvxueyang.vip" target="_blank">小肥龙吃大冰淇淋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></div><div class="post_share"><div class="social-share" data-image="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/bg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/adbd2430.html"><img class="prev-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis面试题</div></div></a></div><div class="next-post pull-right"><a href="/post/e40627a3.html"><img class="next-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">设计模式-解释器模式</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/1bff3c65.html" title="MyBatis面试题"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-11</div><div class="title">MyBatis面试题</div></div></a></div><div><a href="/post/adbd2430.html" title="Redis面试题"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-31</div><div class="title">Redis面试题</div></div></a></div><div><a href="/post/489ef953.html" title="Spring面试题"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-14</div><div class="title">Spring面试题</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E5%92%8CLinkedList%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">ArrayList和LinkedList有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E7%9A%84sublist%E4%BF%AE%E6%94%B9%E6%98%AF%E5%90%A6%E5%BD%B1%E5%93%8Dlist%E6%9C%AC%E8%BA%AB%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">ArrayList的sublist修改是否影响list本身？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SynchronizedList%E3%80%81Vector%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">3.</span> <span class="toc-text">SynchronizedList、Vector有什么区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arrays-asList-T%E2%80%A6args-%E8%8E%B7%E5%BE%97%E7%9A%84List%E7%89%B9%E7%82%B9"><span class="toc-number">4.</span> <span class="toc-text">Arrays.asList(T…args)获得的List特点?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterator%E5%92%8CListIterator%E5%8C%BA%E5%88%AB"><span class="toc-number">5.</span> <span class="toc-text">Iterator和ListIterator区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A9%E5%AE%B9%E7%9A%84%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">ArrayList是怎么扩容的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E3%80%81%E6%9F%A5%E8%AF%A2%E5%85%83%E7%B4%A0%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%90%84%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">ArrayList插入、删除、查询元素的时间复杂度各是多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%B1%82%E4%B8%A4%E4%B8%AA%E9%9B%86%E5%90%88%E7%9A%84%E5%B9%B6%E9%9B%86%E3%80%81%E4%BA%A4%E9%9B%86%E3%80%81%E5%B7%AE%E9%9B%86%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">怎么求两个集合的并集、交集、差集？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">ArrayList是怎么实现序列化和反序列化的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E6%96%B9%E6%B3%95toArray-%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">集合的方法toArray()有什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFfail-fast%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">什么是fail-fast？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">11.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">11.2.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fail-fast%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="toc-number">11.3.</span> <span class="toc-text">fail-fast解决办法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedList%E6%98%AF%E5%8D%95%E9%93%BE%E8%A1%A8%E8%BF%98%E6%98%AF%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">LinkedList是单链表还是双链表实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedList%E9%99%A4%E4%BA%86%E4%BD%9C%E4%B8%BAList%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%E5%A4%84%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">LinkedList除了作为List还有什么用处？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedList%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E3%80%81%E6%9F%A5%E8%AF%A2%E5%85%83%E7%B4%A0%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%90%84%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">LinkedList插入、删除、查询元素的时间复杂度各是多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%EF%BC%9F"><span class="toc-number">15.</span> <span class="toc-text">什么是随机访问？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RandomAccess%E6%8E%A5%E5%8F%A3"><span class="toc-number">15.0.1.</span> <span class="toc-text">RandomAccess接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E9%9B%86%E5%90%88%E6%94%AF%E6%8C%81%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%EF%BC%9F%E4%BB%96%E4%BB%AC%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%85%B1%E6%80%A7%EF%BC%9F"><span class="toc-number">16.</span> <span class="toc-text">哪些集合支持随机访问？他们都有哪些共性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CopyOnWriteArrayList%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">17.</span> <span class="toc-text">CopyOnWriteArrayList是怎么保证并发安全的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CopyOnWriteArrayList%E7%9A%84%E5%AE%9E%E7%8E%B0%E9%87%87%E7%94%A8%E4%BA%86%E4%BB%80%E4%B9%88%E6%80%9D%E6%83%B3%EF%BC%9F"><span class="toc-number">18.</span> <span class="toc-text">CopyOnWriteArrayList的实现采用了什么思想？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CopyOnWriteArrayList%E6%98%AF%E4%B8%8D%E6%98%AF%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="toc-number">19.</span> <span class="toc-text">CopyOnWriteArrayList是不是强一致性的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CopyOnWriteArrayListaddIfAbsent-E-e-%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">20.</span> <span class="toc-text">CopyOnWriteArrayListaddIfAbsent(E e)了解吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CopyOnWriteArrayList%E9%80%82%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">21.</span> <span class="toc-text">CopyOnWriteArrayList适用于什么样的场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CopyOnWriteArrayList%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E3%80%81%E6%9F%A5%E8%AF%A2%E5%85%83%E7%B4%A0%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%90%84%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">22.</span> <span class="toc-text">CopyOnWriteArrayList插入、删除、查询元素的时间复杂度各是多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CopyOnWriteArrayList%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89size%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="toc-number">23.</span> <span class="toc-text">CopyOnWriteArrayList为什么没有size属性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%8F%A4%E8%80%81%E7%9A%84%E9%9B%86%E5%90%88Vector%E5%92%8CStack%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E9%99%B7%EF%BC%9F"><span class="toc-number">24.</span> <span class="toc-text">比较古老的集合Vector和Stack有什么缺陷？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%9F"><span class="toc-number">25.</span> <span class="toc-text">什么是散列表？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"><span class="toc-number">26.</span> <span class="toc-text">常见的散列函数?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A2%B0%E6%92%9E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">27.</span> <span class="toc-text">碰撞解决方案?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%9F"><span class="toc-number">28.</span> <span class="toc-text">怎么实现一个散列表？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E4%B8%ADHashMap%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E7%9A%84%E6%BC%94%E8%BF%9B%EF%BC%9F"><span class="toc-number">29.</span> <span class="toc-text">java中HashMap实现方式的演进？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E7%9A%84%E5%AE%B9%E9%87%8F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">30.</span> <span class="toc-text">HashMap的容量有什么特点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E5%93%88%E5%B8%8C%E6%A1%B6%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E4%BD%8D%E7%BD%AE%EF%BC%9F"><span class="toc-number">31.</span> <span class="toc-text">HashMap如何确定哈希桶数组索引位置？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%AE%B9%E7%9A%84%EF%BC%9F"><span class="toc-number">32.</span> <span class="toc-text">HashMap是怎么进行扩容的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E7%9A%84put%E6%96%B9%E6%B3%95"><span class="toc-number">33.</span> <span class="toc-text">HashMap的put方法?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%EF%BC%9F"><span class="toc-number">34.</span> <span class="toc-text">HashMap中的元素是否是有序的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E4%BD%95%E6%97%B6%E8%BF%9B%E8%A1%8C%E6%A0%91%E5%8C%96%EF%BC%9F%E4%BD%95%E6%97%B6%E8%BF%9B%E8%A1%8C%E5%8F%8D%E6%A0%91%E5%8C%96%EF%BC%9F"><span class="toc-number">35.</span> <span class="toc-text">HashMap何时进行树化？何时进行反树化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83%E4%B8%8E%E6%8C%87%E6%95%B0%E5%88%86%E5%B8%83"><span class="toc-number">36.</span> <span class="toc-text">泊松分布与指数分布</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83"><span class="toc-number">36.1.</span> <span class="toc-text">泊松分布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E6%95%B0%E5%88%86%E5%B8%83"><span class="toc-number">36.2.</span> <span class="toc-text">指数分布</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E7%BC%A9%E5%AE%B9%E7%9A%84%EF%BC%9F"><span class="toc-number">37.</span> <span class="toc-text">HashMap是怎么进行缩容的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E3%80%81%E6%9F%A5%E8%AF%A2%E5%85%83%E7%B4%A0%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%90%84%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">38.</span> <span class="toc-text">HashMap插入、删除、查询元素的时间复杂度各是多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0%E9%83%A8%E5%88%86%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%85%B6%E5%AE%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A3%E6%9B%BF%E5%90%97%EF%BC%9F"><span class="toc-number">39.</span> <span class="toc-text">HashMap中的红黑树实现部分可以用其它数据结构代替吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedHashMap%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">40.</span> <span class="toc-text">LinkedHashMap是怎么实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedHashMap%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%E5%90%97%EF%BC%9F%E6%80%8E%E4%B9%88%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%B3%95%EF%BC%9F"><span class="toc-number">41.</span> <span class="toc-text">LinkedHashMap是有序的吗？怎么个有序法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedHashMap%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0LRU%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="toc-number">42.</span> <span class="toc-text">LinkedHashMap如何实现LRU缓存淘汰策略？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WeakHashMap%E4%BD%BF%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-number">43.</span> <span class="toc-text">WeakHashMap使用的数据结构？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WeakHashMap%E5%85%B7%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">44.</span> <span class="toc-text">WeakHashMap具有什么特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WeakHashMap%E9%80%9A%E5%B8%B8%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">45.</span> <span class="toc-text">WeakHashMap通常用来做什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WeakHashMap%E4%BD%BF%E7%94%A8String%E4%BD%9C%E4%B8%BAkey%E6%98%AF%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">46.</span> <span class="toc-text">WeakHashMap使用String作为key是需要注意些什么？为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-number">47.</span> <span class="toc-text">什么是强引用、软引用、弱引用、虚引用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">48.</span> <span class="toc-text">红黑树具有哪些特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeMap%E5%B0%B1%E6%9C%89%E5%BA%8F%E7%9A%84%E5%90%97%EF%BC%9F%E6%80%8E%E4%B9%88%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%B3%95%EF%BC%9F"><span class="toc-number">49.</span> <span class="toc-text">TreeMap就有序的吗？怎么个有序法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeMap%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E6%89%A9%E5%AE%B9%EF%BC%9F"><span class="toc-number">50.</span> <span class="toc-text">TreeMap是否需要扩容？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B7%A6%E6%97%8B%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%B3%E6%97%8B%EF%BC%9F"><span class="toc-number">51.</span> <span class="toc-text">什么是左旋？什么是右旋？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E6%80%8E%E4%B9%88%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0%EF%BC%9F"><span class="toc-number">52.</span> <span class="toc-text">红黑树怎么插入元素？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%86%8D%E5%B9%B3%E8%A1%A1"><span class="toc-number">52.1.</span> <span class="toc-text">插入再平衡</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E6%80%8E%E4%B9%88%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%EF%BC%9F"><span class="toc-number">53.</span> <span class="toc-text">红黑树怎么删除元素？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%B9%B3%E8%A1%A1%EF%BC%9F"><span class="toc-number">54.</span> <span class="toc-text">为什么要进行平衡？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%9F"><span class="toc-number">55.</span> <span class="toc-text">如何实现红黑树的遍历？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%85%81%E8%AE%B8key%E4%B8%BAnull"><span class="toc-number">56.</span> <span class="toc-text">TreeMap为什么不允许key为null?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeMap%E4%B8%AD%E6%98%AF%E6%80%8E%E4%B9%88%E9%81%8D%E5%8E%86%E7%9A%84%EF%BC%9F"><span class="toc-number">57.</span> <span class="toc-text">TreeMap中是怎么遍历的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeMap%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E3%80%81%E6%9F%A5%E8%AF%A2%E5%85%83%E7%B4%A0%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%90%84%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">58.</span> <span class="toc-text">TreeMap插入、删除、查询元素的时间复杂度各是多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">59.</span> <span class="toc-text">HashMap在多线程环境中什么时候会出现问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-number">60.</span> <span class="toc-text">ConcurrentHashMap的存储结构？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">61.</span> <span class="toc-text">ConcurrentHashMap是怎么保证并发安全的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A9%E5%AE%B9%E7%9A%84%EF%BC%9F"><span class="toc-number">62.</span> <span class="toc-text">ConcurrentHashMap是怎么扩容的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap%E7%9A%84size-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9F%A5%E9%81%93%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">63.</span> <span class="toc-text">ConcurrentHashMap的size()方法的实现知道多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap%E6%98%AF%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">64.</span> <span class="toc-text">ConcurrentHashMap是强一致性的吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap%E4%B8%8D%E8%83%BD%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">65.</span> <span class="toc-text">ConcurrentHashMap不能解决什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap%E7%9A%84sizeCtl%E7%9F%A5%E9%81%93%E5%90%97"><span class="toc-number">66.</span> <span class="toc-text">ConcurrentHashMap的sizeCtl知道吗?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap%E4%B8%AD%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E8%BF%90%E7%94%A8%E5%88%B0%E5%88%86%E6%AE%B5%E9%94%81%E7%9A%84%E6%80%9D%E6%83%B3%EF%BC%9F"><span class="toc-number">67.</span> <span class="toc-text">ConcurrentHashMap中哪些地方运用到分段锁的思想？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%AA%E5%85%B1%E4%BA%AB%EF%BC%9F%E4%B8%BA%E4%BD%95%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BC%AA%E5%85%B1%E4%BA%AB-%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E4%BC%AA%E5%85%B1%E4%BA%AB%EF%BC%9F"><span class="toc-number">68.</span> <span class="toc-text">什么是伪共享？为何会出现伪共享?怎么避免伪共享？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%AA%E5%85%B1%E4%BA%AB%EF%BC%9F"><span class="toc-number">68.1.</span> <span class="toc-text">什么是伪共享？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BD%95%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BC%AA%E5%85%B1%E4%BA%AB"><span class="toc-number">68.2.</span> <span class="toc-text">为何会出现伪共享</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E4%BC%AA%E5%85%B1%E4%BA%AB"><span class="toc-number">68.2.1.</span> <span class="toc-text">如何解决伪共享</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%B3%E8%A1%A8%EF%BC%9F"><span class="toc-number">69.</span> <span class="toc-text">什么是跳表？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentSkipList%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">70.</span> <span class="toc-text">ConcurrentSkipList是有序的吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentSkipList%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">71.</span> <span class="toc-text">ConcurrentSkipList是如何保证线程安全的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentSkipList%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E3%80%81%E6%9F%A5%E8%AF%A2%E5%85%83%E7%B4%A0%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%90%84%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">72.</span> <span class="toc-text">ConcurrentSkipList插入、删除、查询元素的时间复杂度各是多少？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0"><span class="toc-number">72.1.</span> <span class="toc-text">添加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">72.2.</span> <span class="toc-text">删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2"><span class="toc-number">72.3.</span> <span class="toc-text">查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentSkipList%E7%9A%84%E7%B4%A2%E5%BC%95%E5%85%B7%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">73.</span> <span class="toc-text">ConcurrentSkipList的索引具有什么特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8%E8%B7%B3%E8%A1%A8%E8%80%8C%E4%B8%8D%E6%98%AF%E7%BA%A2%E9%BB%91%E6%A0%91%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%9F"><span class="toc-number">74.</span> <span class="toc-text">为什么Redis选择使用跳表而不是红黑树来实现有序集合？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashSet%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E4%B8%8D%E9%87%8D%E5%A4%8D%EF%BC%9F"><span class="toc-number">75.</span> <span class="toc-text">HashSet怎么保证添加元素不重复？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashSet%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">76.</span> <span class="toc-text">HashSet是有序的吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashSet%E6%98%AF%E5%90%A6%E5%85%81%E8%AE%B8null%E5%85%83%E7%B4%A0%EF%BC%9F"><span class="toc-number">77.</span> <span class="toc-text">HashSet是否允许null元素？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set%E6%98%AF%E5%90%A6%E6%9C%89get-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">78.</span> <span class="toc-text">Set是否有get()方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashSet%E6%BA%90%E7%A0%81%EF%BC%9F"><span class="toc-number">79.</span> <span class="toc-text">HashSet源码？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedHashSet%E7%9A%84%E5%BA%95%E5%B1%82%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E5%AD%98%E5%82%A8%E5%85%83%E7%B4%A0%EF%BC%9F"><span class="toc-number">80.</span> <span class="toc-text">LinkedHashSet的底层使用什么存储元素？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedHashSet%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%E5%90%97%EF%BC%9F%E6%80%8E%E4%B9%88%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%B3%95%EF%BC%9F"><span class="toc-number">81.</span> <span class="toc-text">LinkedHashSet是有序的吗？怎么个有序法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedHashSet%E6%94%AF%E6%8C%81%E6%8C%89%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%BA%8F%E5%90%97%EF%BC%9F"><span class="toc-number">82.</span> <span class="toc-text">LinkedHashSet支持按元素访问顺序排序吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeSet%E7%9C%9F%E7%9A%84%E6%98%AF%E4%BD%BF%E7%94%A8TreeMap%E6%9D%A5%E5%AD%98%E5%82%A8%E5%85%83%E7%B4%A0%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">83.</span> <span class="toc-text">TreeSet真的是使用TreeMap来存储元素的吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeSet%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%E5%90%97%EF%BC%9F%E6%80%8E%E4%B9%88%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%B3%95%EF%BC%9F"><span class="toc-number">84.</span> <span class="toc-text">TreeSet是有序的吗？怎么个有序法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeSet%E5%92%8CLinkedHashSet%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">85.</span> <span class="toc-text">TreeSet和LinkedHashSet有何不同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeSet%E5%92%8CSortedSet%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%EF%BC%9F"><span class="toc-number">86.</span> <span class="toc-text">TreeSet和SortedSet有什么区别和联系？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CopyOnWriteArraySet%E6%98%AF%E7%94%A8Map%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">87.</span> <span class="toc-text">CopyOnWriteArraySet是用Map实现的吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CopyOnWriteArraySet%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%E5%90%97%EF%BC%9F%E6%80%8E%E4%B9%88%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%B3%95%EF%BC%9F"><span class="toc-number">88.</span> <span class="toc-text">CopyOnWriteArraySet是有序的吗？怎么个有序法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CopyOnWriteArraySet%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">89.</span> <span class="toc-text">CopyOnWriteArraySet怎么保证并发安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CopyOnWriteArraySet%E4%BB%A5%E4%BD%95%E7%A7%8D%E6%96%B9%E5%BC%8F%E4%BF%9D%E8%AF%81%E5%85%83%E7%B4%A0%E4%B8%8D%E9%87%8D%E5%A4%8D%EF%BC%9F"><span class="toc-number">90.</span> <span class="toc-text">CopyOnWriteArraySet以何种方式保证元素不重复？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AASet%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%AE%8C%E5%85%A8%E4%B8%80%E8%87%B4%EF%BC%9F"><span class="toc-number">91.</span> <span class="toc-text">如何比较两个Set中的元素是否完全一致？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AAList%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%AE%8C%E5%85%A8%E7%9B%B8%E7%AD%89%E5%91%A2%EF%BC%9F"><span class="toc-number">92.</span> <span class="toc-text">如何比较两个List中的元素是否完全相等呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentSkipListSet%E7%9A%84%E5%BA%95%E5%B1%82%E6%98%AFConcurrentSkipListMap%E5%90%97%EF%BC%9F"><span class="toc-number">93.</span> <span class="toc-text">ConcurrentSkipListSet的底层是ConcurrentSkipListMap吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentSkipListSet%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%E5%90%97%EF%BC%9F%E6%80%8E%E4%B9%88%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%B3%95%EF%BC%9F"><span class="toc-number">94.</span> <span class="toc-text">ConcurrentSkipListSet是有序的吗？怎么个有序法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentSkipListSet%E6%BA%90%E7%A0%81%EF%BC%9F"><span class="toc-number">95.</span> <span class="toc-text">ConcurrentSkipListSet源码？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86%E5%8C%96%EF%BC%9F"><span class="toc-number">96.</span> <span class="toc-text">什么是堆？什么是堆化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-number">97.</span> <span class="toc-text">什么是优先级队列？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PriorityQueue%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">98.</span> <span class="toc-text">PriorityQueue是怎么实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PriorityQueue%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">99.</span> <span class="toc-text">PriorityQueue是有序的吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PriorityQueue%E5%85%A5%E9%98%9F%E3%80%81%E5%87%BA%E9%98%9F%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%90%84%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">100.</span> <span class="toc-text">PriorityQueue入队、出队的时间复杂度各是多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PriorityQueue%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E6%89%A9%E5%AE%B9%EF%BC%9F%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99%E5%91%A2%EF%BC%9F"><span class="toc-number">101.</span> <span class="toc-text">PriorityQueue是否需要扩容？扩容规则呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayBlockingQueue%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">102.</span> <span class="toc-text">ArrayBlockingQueue的实现方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayBlockingQueue%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E6%89%A9%E5%AE%B9%EF%BC%9F"><span class="toc-number">103.</span> <span class="toc-text">ArrayBlockingQueue是否需要扩容？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayBlockingQueue%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">104.</span> <span class="toc-text">ArrayBlockingQueue怎么保证线程安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayBlockingQueue%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">105.</span> <span class="toc-text">ArrayBlockingQueue有什么缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedBlockingQueue%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">106.</span> <span class="toc-text">LinkedBlockingQueue的实现方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedBlockingQueue%E6%98%AF%E6%9C%89%E7%95%8C%E7%9A%84%E8%BF%98%E6%98%AF%E6%97%A0%E7%95%8C%E7%9A%84%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-number">107.</span> <span class="toc-text">LinkedBlockingQueue是有界的还是无界的队列？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedBlockingQueue%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">108.</span> <span class="toc-text">LinkedBlockingQueue怎么保证线程安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedBlockingQueue%E4%B8%8EArrayBlockingQueue%E5%AF%B9%E6%AF%94%EF%BC%9F"><span class="toc-number">109.</span> <span class="toc-text">LinkedBlockingQueue与ArrayBlockingQueue对比？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SynchronousQueue%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">110.</span> <span class="toc-text">SynchronousQueue的实现方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SynchronousQueue%E7%9C%9F%E7%9A%84%E6%98%AF%E6%97%A0%E7%BC%93%E5%86%B2%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">111.</span> <span class="toc-text">SynchronousQueue真的是无缓冲的吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SynchronousQueue%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">112.</span> <span class="toc-text">SynchronousQueue怎么保证线程安全？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#transfer-%E6%96%B9%E6%B3%95"><span class="toc-number">112.1.</span> <span class="toc-text">transfer()方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SynchronousQueue%E7%9A%84%E5%85%AC%E5%B9%B3%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">113.</span> <span class="toc-text">SynchronousQueue的公平模式和非公平模式有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SynchronousQueue%E5%9C%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E6%83%85%E6%99%AF%E4%B8%8B%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">114.</span> <span class="toc-text">SynchronousQueue在高并发情景下会有什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PriorityBlockingQueue%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">115.</span> <span class="toc-text">PriorityBlockingQueue的实现方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PriorityBlockingQueue%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E6%89%A9%E5%AE%B9%EF%BC%9F"><span class="toc-number">116.</span> <span class="toc-text">PriorityBlockingQueue是否需要扩容？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PriorityBlockingQueue%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">117.</span> <span class="toc-text">PriorityBlockingQueue怎么保证线程安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PriorityBlockingQueue%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E9%9C%80%E8%A6%81notFull%E6%9D%A1%E4%BB%B6%EF%BC%9F"><span class="toc-number">118.</span> <span class="toc-text">PriorityBlockingQueue为什么不需要notFull条件？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E9%87%8D%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-number">119.</span> <span class="toc-text">什么是双重队列？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedTransferQueue%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%EF%BC%9F"><span class="toc-number">120.</span> <span class="toc-text">LinkedTransferQueue是怎么实现阻塞队列的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedTransferQueue%E6%98%AF%E6%80%8E%E4%B9%88%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">121.</span> <span class="toc-text">LinkedTransferQueue是怎么控制并发安全的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#xfer"><span class="toc-number">121.1.</span> <span class="toc-text">xfer()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedTransferQueue%E4%B8%8ESynchronousQueue%E6%9C%89%E4%BB%80%E4%B9%88%E5%BC%82%E5%90%8C%EF%BC%9F"><span class="toc-number">122.</span> <span class="toc-text">LinkedTransferQueue与SynchronousQueue有什么异同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentLinkedQueue%E6%98%AF%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%90%97%EF%BC%9F"><span class="toc-number">123.</span> <span class="toc-text">ConcurrentLinkedQueue是阻塞队列吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentLinkedQueue%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">124.</span> <span class="toc-text">ConcurrentLinkedQueue如何保证并发安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentLinkedQueue%E8%83%BD%E7%94%A8%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%97%EF%BC%9F"><span class="toc-number">125.</span> <span class="toc-text">ConcurrentLinkedQueue能用于线程池吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentLinkedQueue%E4%B8%8ELinkedBlockingQueue%E5%AF%B9%E6%AF%94%EF%BC%9F"><span class="toc-number">126.</span> <span class="toc-text">ConcurrentLinkedQueue与LinkedBlockingQueue对比？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DelayQueue%E6%98%AF%E9%98%BB%E5%A1%9E-%E9%98%9F%E5%88%97%E5%90%97%EF%BC%9F"><span class="toc-number">127.</span> <span class="toc-text">DelayQueue是阻塞-队列吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DelayQueue%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">128.</span> <span class="toc-text">DelayQueue的实现方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DelayQueue%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8"><span class="toc-number">129.</span> <span class="toc-text">DelayQueue如何保证并发安全?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DelayQueue%E4%B8%BB%E8%A6%81%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">130.</span> <span class="toc-text">DelayQueue主要用于什么场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%98%AF%E7%9B%B4%E6%8E%A5%E7%94%A8%E7%9A%84DelayQueue%E5%90%97%EF%BC%9F"><span class="toc-number">131.</span> <span class="toc-text">java中的线程池实现定时任务是直接用的DelayQueue吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-number">132.</span> <span class="toc-text">什么是双端队列？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayDeque%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E7%9A%84%EF%BC%9F"><span class="toc-number">133.</span> <span class="toc-text">ArrayDeque是怎么实现双端队列的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedList%E4%B8%8EArrayDeque%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%9F"><span class="toc-number">134.</span> <span class="toc-text">LinkedList与ArrayDeque的对比？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BA%E6%A0%88%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">135.</span> <span class="toc-text">双端队列是否可以作为栈使用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedList%E6%98%AFList%E5%92%8CDeque%E7%9A%84%E9%9B%86%E5%90%88%E4%BD%93%EF%BC%9F"><span class="toc-number">136.</span> <span class="toc-text">LinkedList是List和Deque的集合体？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%AE%B9%E9%87%8F%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-number">137.</span> <span class="toc-text">集合指定初始容量的好处？</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 小肥龙吃大冰淇淋</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'pinglun-9gh2lmcnd8587831',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'pinglun-9gh2lmcnd8587831',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@latest/source/js/issues.min.js"></script><script src="//code.tidio.co/smwivpnwumemac2wohardi3d3gpud1ag.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>