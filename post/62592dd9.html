<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>java并发工具类-队列 | 小肥龙吃大冰淇淋</title><meta name="keywords" content="队列"><meta name="author" content="小肥龙吃大冰淇淋"><meta name="copyright" content="小肥龙吃大冰淇淋"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="java并发工具类-队列 BlockingQueue java.util.concurrent包中的Java BlockingQueue接口表示一个线程可以安全放入以及从中获取实例的队列。在本文中，我将向你展示如何使用BlockingQueue。  使用 一个BlockingQueue通常用于在线程上生成对象，另一个线程消耗对象。这是一个说明这个原则的图表：    生产线程将一直生成新对象并将它们">
<meta property="og:type" content="article">
<meta property="og:title" content="java并发工具类-队列">
<meta property="og:url" content="https://lvxueyangtiger.github.io/post/62592dd9.html">
<meta property="og:site_name" content="小肥龙吃大冰淇淋">
<meta property="og:description" content="java并发工具类-队列 BlockingQueue java.util.concurrent包中的Java BlockingQueue接口表示一个线程可以安全放入以及从中获取实例的队列。在本文中，我将向你展示如何使用BlockingQueue。  使用 一个BlockingQueue通常用于在线程上生成对象，另一个线程消耗对象。这是一个说明这个原则的图表：    生产线程将一直生成新对象并将它们">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212100.jpg">
<meta property="article:published_time" content="2024-05-30T01:10:36.308Z">
<meta property="article:modified_time" content="2023-10-12T01:47:46.659Z">
<meta property="article:author" content="小肥龙吃大冰淇淋">
<meta property="article:tag" content="队列">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212100.jpg"><link rel="shortcut icon" href="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210805191028.png"><link rel="canonical" href="https://lvxueyangtiger.github.io/post/62592dd9"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java并发工具类-队列',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-12 09:47:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/ali_icon.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mogai.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="小肥龙吃大冰淇淋" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">303</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">108</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">73</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212100.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小肥龙吃大冰淇淋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java并发工具类-队列</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-30T01:10:36.308Z" title="发表于 2024-05-30 09:10:36">2024-05-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-12T01:47:46.659Z" title="更新于 2023-10-12 09:47:46">2023-10-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JUC%E7%B3%BB%E5%88%97/">JUC系列</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>71分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java并发工具类-队列"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="java并发工具类-队列"><a href="#java并发工具类-队列" class="headerlink" title="java并发工具类-队列"></a>java并发工具类-队列</h2><p><img src="https://baiyp.ren/images/thread/queue/queue01.png" alt="img"></p>
<h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><blockquote>
<p><code>java.util.concurrent</code>包中的Java <code>BlockingQueue</code>接口表示一个线程可以安全放入以及从中获取实例的队列。在本文中，我将向你展示如何使用<code>BlockingQueue</code>。</p>
</blockquote>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><blockquote>
<p>一个<code>BlockingQueue</code>通常用于在线程上生成对象，另一个线程消耗对象。这是一个说明这个原则的图表：</p>
</blockquote>
<p><img src="https://baiyp.ren/images/thread/queue/blockingqueue01.png" alt="img"></p>
<p> 生产线程将一直生成新对象并将它们插入队列，直到达到队列的容量上限。如果阻塞队列达到其上限，则在尝试插入新对象时会阻止生产线程。它将一直被阻塞，直到消费线程将一个对象从队列中取出。</p>
<p> 消费线程不断将对象从阻塞队列中取出并处理它们。如果消费线程试图将对象从空队列中取出实例，那么消费线程将被阻塞，直到生产线程向队列放入一个对象。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><blockquote>
<p><code>BlockingQueue</code>有4组不同的方法用于插入，删除和检查队列中的元素。当不能立即执行所请求的操作时，每组方法的行为会不同。这是一个方法表：</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>add(o)</td>
<td>offer(o)</td>
<td>put(o)</td>
<td>offer(o, timeout, timeunit)</td>
</tr>
<tr>
<td>删除</td>
<td>remove(o)</td>
<td>poll()</td>
<td>take()</td>
<td>poll(timeout, timeunit)</td>
</tr>
<tr>
<td>访问</td>
<td>element()</td>
<td>peek()</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h5 id="方法行为"><a href="#方法行为" class="headerlink" title="方法行为"></a>方法行为</h5><blockquote>
<p>这4种不同的行为意味着：</p>
</blockquote>
<h6 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h6><blockquote>
<p>如果请求的操作现在无法完成，则抛出异常。</p>
</blockquote>
<h6 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h6><blockquote>
<p>如果请求的操作现在无法完成，则返回特殊值(一般为 true / false).</p>
</blockquote>
<h6 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h6><blockquote>
<p>如果请求的操作现在无法完成，则方法调用将阻塞，直到操作能够进行。</p>
</blockquote>
<h6 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h6><p> 如果请求的操作现在无法完成，则方法调用将阻塞直到它能够进行，但等待不超过给定的超时。返回一个特殊值，告知操作是否成功（通常为true / false）</p>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p> 无法插入<code>null</code>到<code>BlockingQueue</code>中。如果你尝试插入<code>null</code>， <code>BlockingQueue</code>则会抛出一个<code>NullPointerException</code>异常。</p>
<p> 你可以访问<code>BlockingQueue</code>内的所有元素，而不仅仅是开头和结尾的元素。例如，假设你已将一个对象入队等待处理，但你的应用程序决定取消它。你可以调用<code>remove(o)</code>这样的操作来删除队列中的特定对象。但是，这是个效率很低的操作，所以除非你真的需要，否则你不应该使用<code>Collection</code>中的这些方法。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><blockquote>
<p>这是一个Java <code>BlockingQueue</code>示例。该示例使用实现<code>BlockingQueue</code>接口的<code>ArrayBlockingQueue</code>类。</p>
</blockquote>
<h5 id="BlockingQueueExample"><a href="#BlockingQueueExample" class="headerlink" title="BlockingQueueExample"></a>BlockingQueueExample</h5><blockquote>
<p>首先， <code>BlockingQueueExample</code>类在不同的线程中启动<code>Producer</code>和<code>Consumer</code>。<code>Producer</code>将一个字符串插入共享的<code>BlockingQueue</code>，而<code>Consumer</code>使用它们。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue queue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(queue);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(queue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h5><blockquote>
<p>这是<code>Producer</code>类。注意每次<code>put()</code>调用之间它都会睡一秒钟。这将导致<code>Consumer</code>阻塞，为了等待获取队列中的对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> BlockingQueue queue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.put(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            queue.put(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            queue.put(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h5><blockquote>
<p>这是<code>Consumer</code>类。它从队列中取出对象，然后将它们打印到<code>System.out</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> BlockingQueue queue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(queue.take());</span><br><span class="line">            System.out.println(queue.take());</span><br><span class="line">            System.out.println(queue.take());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><blockquote>
<p>下面是一个测试：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingExample</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1024</span>);</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(queue);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(queue);</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(producer);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(consumer);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        </span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line"></span><br><span class="line">        Producer(BlockingQueue&lt;String&gt; queue) &#123;</span><br><span class="line">            <span class="keyword">this</span>.queue = queue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                queue.put(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                queue.put(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> BlockingQueue&lt;String&gt; queue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Consumer(BlockingQueue&lt;String&gt; queue) &#123;</span><br><span class="line">            <span class="keyword">this</span>.queue = queue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(queue.take());</span><br><span class="line">                System.out.println(queue.take());</span><br><span class="line">                System.out.println(queue.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BlockingDeque"><a href="#BlockingDeque" class="headerlink" title="BlockingDeque"></a>BlockingDeque</h3><blockquote>
<p><code>java.util.concurrent</code>中的<code>BlockingDeque</code>接口表示一个双向队列，它可以被线程安全的放入以及从中获取实例。在本文中，我将向你展示如何使用<code>BlockingDeque</code>。</p>
</blockquote>
<p> <code>BlockingDeque</code>类是一个<code>Deque</code>，它会阻塞尝试在deque中插入或删除的线程，以防它能够向队列中插入或删除元素。</p>
<p> deque是“Double Ended Queue”（双端队列）的缩写。因此，deque是一个队列，你可以从它的两端插入和获取元素。</p>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><blockquote>
<p>如果线程同时生成和使用同一队列的元素，则可以使用<code>BlockingDeque</code>。如果生成线程需要在队列的两端插入元素，并且消费线程需要从队列的两端移除元素，那么也可以使用它：</p>
</blockquote>
<p><img src="https://baiyp.ren/images/thread/queue/queue02.png" alt="img"></p>
<p> 线程将生成元素并将它们插入队列的任一端。如果deque当前已满，则插入线程将被阻塞，直到删除线程将元素从双端队列中取出。如果deque当前为空，则将阻止删除线程，直到插入线程将元素插入到双端队列中。</p>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><blockquote>
<p><code>BlockingDeque</code>有4组不同的方法用于插入，移除以及检查双端队列中的元素。如果不能立即执行所请求的操作，则每组方法的行为都不同。这是一个方法表：</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody><tr>
<td>Insert</td>
<td>addFirst(o)</td>
<td>offerFirst(o)</td>
<td>putFirst(o)</td>
<td>offerFirst(o, timeout, timeunit)</td>
</tr>
<tr>
<td>Remove</td>
<td>removeFirst(o)</td>
<td>pollFirst(o)</td>
<td>takeFirst(o)</td>
<td>pollFirst(timeout, timeunit)</td>
</tr>
<tr>
<td>Examine</td>
<td>getFirst(o)</td>
<td>peekFirst(o)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>抛出异常</td>
<td>返回特殊值</td>
<td>阻塞</td>
<td>超时</td>
<td></td>
</tr>
<tr>
<td>Insert</td>
<td>addLast(o)</td>
<td>offerLast(o)</td>
<td>putLast(o)</td>
<td>offerLast(o, timeout, timeunit)</td>
</tr>
<tr>
<td>Remove</td>
<td>removeLast(o)</td>
<td>pollLast(o)</td>
<td>takeLast(o)</td>
<td>pollLast(timeout, timeunit)</td>
</tr>
<tr>
<td>Examine</td>
<td>getLast(o)</td>
<td>peekLast(o)</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>这与<code>BlockingQueue</code>类似，只多了一组方法。</p>
<h4 id="继承自-BlockingQueue"><a href="#继承自-BlockingQueue" class="headerlink" title="继承自 BlockingQueue"></a>继承自 BlockingQueue</h4><p> <code>BlockingDeque</code>接口扩展<code>BlockingQueue</code>接口。这意味着你可以使用<code>BlockingDeque</code>作为<code>BlockingQueue</code>。如果这样做，各种插入方法会将元素添加到双端队列的末尾，而删除方法将从双端队列的开头删除元素，即<code>BlockingQueue</code>接口的插入和删除方法。</p>
<blockquote>
<p>下面是一个表格，对应了<code>BlockingQueue</code>和<code>BlockingDeque</code>的方法：</p>
</blockquote>
<table>
<thead>
<tr>
<th>BlockingQueue</th>
<th>BlockingDeque</th>
</tr>
</thead>
<tbody><tr>
<td>add()</td>
<td>addLast()</td>
</tr>
<tr>
<td>offer() x 2</td>
<td>offerLast() x 2</td>
</tr>
<tr>
<td>put()</td>
<td>putLast()</td>
</tr>
<tr>
<td>remove()</td>
<td>removeFirst()</td>
</tr>
<tr>
<td>poll() x 2</td>
<td>pollFirst() x 2</td>
</tr>
<tr>
<td>take()</td>
<td>takeFirst()</td>
</tr>
<tr>
<td>element()</td>
<td>getFirst()</td>
</tr>
<tr>
<td>peek()</td>
<td>peekFirst()</td>
</tr>
</tbody></table>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><blockquote>
<p>这是一个如何使用<code>BlockingDeque</code>方法的小代码示例：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BlockingDeque&lt;String&gt; deque = <span class="keyword">new</span> LinkedBlockingDeque&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">deque.addFirst(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">deque.addLast(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">String two = deque.takeLast();</span><br><span class="line">String one = deque.takeFirst();</span><br></pre></td></tr></table></figure>

<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><blockquote>
<p><code>ArrayBlockingQueue</code>类实现了<a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-util-concurrent/blockingqueue.html"><code>BlockingQueue</code></a>接口。阅读<a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-util-concurrent/blockingqueue.html"><code>BlockingQueue</code></a>文本以获取有关的更多信息。</p>
</blockquote>
<p> <code>ArrayBlockingQueue</code>是一个<strong>有界的阻塞队列</strong>，它将元素存储在数组内部。有界意味着它无法存储无限量的元素，它可以同时存储的元素数量有一个上限。你需要在实例化时设置上限，之后无法更改，所以它和<code>ArrayList</code>有些区别，不要因为它们的名称相似而将它们的功能混杂。</p>
<p> <code>ArrayBlockingQueue</code>内部是以FIFO（先入先出）次序来存储元素的。队列的头部是在队列中存活时间最长的元素，而队列的尾部是在队列中存活时间最短的元素。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><blockquote>
<p>以下是实例化和使用<code>ArrayBlockingQueue</code>的例子：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BlockingQueue queue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">queue.put(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">Object object = queue.take();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这是一个使用Java 泛型的<code>BlockingQueue</code>例子：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">queue.put(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">String string = queue.take();</span><br></pre></td></tr></table></figure>

<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><blockquote>
<p><code>ArrayBlockingQueue</code>中使用了这几个成员变量来保证操作，其实内部使用了一个循环数组，其中takeIndex和putIndex其实相当于队列的头部和尾部。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 使用数组保存元素 */</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 下一个take，poll，peek或remove方法调用时访问此下标的元素 */</span></span><br><span class="line">    <span class="keyword">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 下一个put, offer, 或add方法调用时访问此下标的元素 */</span></span><br><span class="line">    <span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**队列中的元素数量 */</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 保护所有操作的主锁 */</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 获取元素的等待条件 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 放置元素的等待条件 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure>

<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><blockquote>
<p>构造函数如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用一个固定的数值和默认的访问规则创建，默认是使用非公平锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity the capacity of this queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> capacity &lt; 1&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用一个固定的数值和指定的访问规则创建</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity the capacity of this queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair if &#123;<span class="doctag">@code</span> true&#125; then queue accesses for threads blocked</span></span><br><span class="line"><span class="comment"> *        on insertion or removal, are processed in FIFO order;</span></span><br><span class="line"><span class="comment"> *        if &#123;<span class="doctag">@code</span> false&#125; the access order is unspecified.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> capacity &lt; 1&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *使用一个固定的数值和指定的访问规则创建，并将给定集合中的元素</span></span><br><span class="line"><span class="comment"> * 增加到队列中，增加的顺序是指定的集合迭代器的遍历顺序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity the capacity of this queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair if &#123;<span class="doctag">@code</span> true&#125; then queue accesses for threads blocked</span></span><br><span class="line"><span class="comment"> *        on insertion or removal, are processed in FIFO order;</span></span><br><span class="line"><span class="comment"> *        if &#123;<span class="doctag">@code</span> false&#125; the access order is unspecified.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c the collection of elements to initially contain</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> capacity&#125; is less than</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> c.size()&#125;, or less than 1.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection or any</span></span><br><span class="line"><span class="comment"> *         of its elements are null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair,</span></span></span><br><span class="line"><span class="params"><span class="function">                          Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(capacity, fair);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// Lock only for visibility, not mutual exclusion</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (E e : c)</span><br><span class="line">                items[i++] = Objects.requireNonNull(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        count = i;</span><br><span class="line">        putIndex = (i == capacity) ? <span class="number">0</span> : i;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="增加操作"><a href="#增加操作" class="headerlink" title="增加操作"></a>增加操作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.add(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 内部重用offer方法</span></span><br><span class="line">    <span class="keyword">if</span> (offer(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 如果增加失败，抛出异常指示队列已满</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查是否是否为null，如果是抛出NPE异常</span></span><br><span class="line">    Objects.requireNonNull(e);</span><br><span class="line">    <span class="comment">// 加锁。  此处使用final的原因是将成员变量赋值为局部变量，</span></span><br><span class="line">    <span class="comment">// 然后使用此变量就不需要经过两次访问，即先访问this，再</span></span><br><span class="line">    <span class="comment">// 访问lock，轻微提升程序性能，后面此种方法的使用也是一样。</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列满了，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (count == items.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 否则，加入队列</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">requireNonNull</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    items[putIndex] = e;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length) putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">// 随机通知一个等待的线程</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Objects.requireNonNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列已经，在notFull上阻塞自己等待通知</span></span><br><span class="line">        <span class="comment">// 关于等待-通知机制已经说过很多次，此处不再多说</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// 超时方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Objects.requireNonNull(e);</span><br><span class="line">    <span class="comment">// 计算超时时间，转换为纳秒</span></span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列已满，超时等待，如果时间用完，返回false</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除指定元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列中存在元素</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">            <span class="comment">// 注意此处精彩的循环使用，因为内部是一个循环数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = takeIndex, end = putIndex,</span><br><span class="line">                     to = (i &lt; end) ? end : items.length;</span><br><span class="line">                 ; i = <span class="number">0</span>, to = end) &#123;</span><br><span class="line">                <span class="keyword">for</span> (; i &lt; to; i++)</span><br><span class="line">                    <span class="keyword">if</span> (o.equals(items[i])) &#123;</span><br><span class="line">                        removeAt(i);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">if</span> (to == end) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeAt</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> removeIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[removeIndex] != null;</span></span><br><span class="line">    <span class="comment">// assert removeIndex &gt;= 0 &amp;&amp; removeIndex &lt; items.length;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="comment">// 如果删除的是头元素，只需修改头元素下标即可</span></span><br><span class="line">    <span class="keyword">if</span> (removeIndex == takeIndex) &#123;</span><br><span class="line">        <span class="comment">// removing front item; just advance</span></span><br><span class="line">        items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (++takeIndex == items.length) takeIndex = <span class="number">0</span>;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="comment">// 此处是为了保持迭代器与队列的一致性</span></span><br><span class="line">        <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">            itrs.elementDequeued();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// an &quot;interior&quot; remove</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// slide over all others up through putIndex.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = removeIndex, putIndex = <span class="keyword">this</span>.putIndex;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> pred = i;</span><br><span class="line">            <span class="keyword">if</span> (++i == items.length) i = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 如果已经移到了最后一个元素，跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (i == putIndex) &#123;</span><br><span class="line">                items[pred] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">this</span>.putIndex = pred;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将元素前移一位</span></span><br><span class="line">            items[pred] = items[i];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">            itrs.removedAt(removeIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    notFull.signal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重用poll方法，如果队列为空，抛出异常</span></span><br><span class="line">    E x = poll();</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="comment">// 获取头元素，因为使用Object[]保存，所以要进行类型转换</span></span><br><span class="line">    <span class="comment">// 因为只能增加指定类型的元素，所以可以确保类型转换一定</span></span><br><span class="line">    <span class="comment">// 会成功，抑制此非受检警告</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    E e = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length) takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阻塞方法以及超时方法和增加操作一样，此处不多做讲解。</p>
<h5 id="访问操作"><a href="#访问操作" class="headerlink" title="访问操作"></a>访问操作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// element()方法在AbstractQueue&lt;E&gt;类中，ArrayBlockingQueue继承自此类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重用peek方法，如果队列为空抛出异常</span></span><br><span class="line">    E x = peek();</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> itemAt(takeIndex); <span class="comment">// null when queue is empty</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> E <span class="title">itemAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) items[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h5><blockquote>
<p>部分方法逻辑简单，有兴趣自己查看即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="comment">// 如果队列中存在元素，清空队列</span></span><br><span class="line">        <span class="keyword">if</span> ((k = count) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            circularClear(items, takeIndex, putIndex);</span><br><span class="line">            takeIndex = putIndex;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 使迭代器保持一致</span></span><br><span class="line">            <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">                itrs.queueIsEmpty();</span><br><span class="line">            <span class="comment">// 如果有线程等待插入元素，唤醒</span></span><br><span class="line">            <span class="keyword">for</span> (; k &gt; <span class="number">0</span> &amp;&amp; lock.hasWaiters(notFull); k--)</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将存在的元素全部置为null即可，等待 gc回收它们，此时等于清空了队列。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">circularClear</span><span class="params">(Object[] items, <span class="keyword">int</span> i, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert 0 &lt;= i &amp;&amp; i &lt; items.length;</span></span><br><span class="line">    <span class="comment">// assert 0 &lt;= end &amp;&amp; end &lt; items.length;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> to = (i &lt; end) ? end : items.length;</span><br><span class="line">         ; i = <span class="number">0</span>, to = end) &#123;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; to; i++) items[i] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (to == end) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重用drainTo(Collection&lt;? super E&gt; c, int maxElements)方法</span></span><br><span class="line">    <span class="keyword">return</span> drainTo(c, Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="comment">// 如果指定的集合是自己，抛出异常，符合BlockingQueue接口文档中的定义</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (maxElements &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取需要转移的元素数量</span></span><br><span class="line">        <span class="keyword">int</span> n = Math.min(maxElements, count);</span><br><span class="line">        <span class="keyword">int</span> take = takeIndex;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过直接访问数组，比重复调用poll()方法再增加性能会高很多</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                E e = (E) items[take];</span><br><span class="line">                c.add(e);</span><br><span class="line">                items[take] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (++take == items.length) take = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Restore invariants even if c.add() threw</span></span><br><span class="line">            <span class="comment">// 做一些处理工作</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                count -= i;</span><br><span class="line">                takeIndex = take;</span><br><span class="line">                <span class="keyword">if</span> (itrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">                        itrs.queueIsEmpty();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; take)</span><br><span class="line">                        itrs.takeIndexWrapped();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (; i &gt; <span class="number">0</span> &amp;&amp; lock.hasWaiters(notFull); i--)</span><br><span class="line">                    notFull.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="核心要点"><a href="#核心要点" class="headerlink" title="核心要点"></a>核心要点</h5><ol>
<li>内部使用了一个循环数组</li>
<li>是一个有界数组，提供了容量后无法被更改</li>
<li>可以指定锁的公平性</li>
</ol>
<h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><blockquote>
<p><code>DelayQueue</code>类实现<a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-util-concurrent/blockingqueue.html"><code>BlockingQueue</code></a>接口。阅读<a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-util-concurrent/blockingqueue.html"><code>BlockingQueue</code></a>文本以获取有关的更多信息。</p>
</blockquote>
<p> <code>DelayQueue</code>内部阻止元素直到某个延迟到期，元素必须实现接口<code>java.util.concurrent.Delayed</code>。以下是<code>java.util.concurrent.Delayed</code>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Delayed</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Delayed</span>&lt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit timeUnit)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>getDelay()</code>方法返回的值应该是在释放此元素之前剩余的延迟。如果返回0或负值，则延迟将被视为已过期，并且在<code>DelayQueue</code>调用下一个<code>take()</code>等操作时释放。</p>
<p> 传递给<code>getDelay()</code>方法的<code>TimeUnit</code>实例是一个<code>Enum</code>，它说明了延迟的时间单位。<code>TimeUnit</code>枚举有以下值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DAYS</span><br><span class="line">HOURS</span><br><span class="line">MINUTES</span><br><span class="line">SECONDS</span><br><span class="line">MILLISECONDS</span><br><span class="line">MICROSECONDS</span><br><span class="line">NANOSECONDS</span><br></pre></td></tr></table></figure>

<p> <code>Delayed</code>接口继承了<code>java.lang.Comparable</code>接口，这意味着<code>Delayed</code>对象可以被相互比较。这可能是在<code>DelayQueue</code>内部用于排序队列中的元素，因此它们能够按到期时间排序释放。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><blockquote>
<p>以下是使用<code>DelayQueue</code>的示例：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DelayQueue queue = <span class="keyword">new</span> DelayQueue();</span><br><span class="line">        Delayed element1 = <span class="keyword">new</span> DelayedElement();</span><br><span class="line">        queue.put(element1);</span><br><span class="line">        Delayed element2 = queue.take();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>DelayedElement</code>是我创建的<code>Delayed</code>接口的实现。它不是<code>java.util.concurrent</code>包的一部分。你必须创建自己的<code>Delayed</code>接口实现才能使用<code>DelayQueue</code>类。</p>
<h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h4><h5 id="整体介绍"><a href="#整体介绍" class="headerlink" title="整体介绍"></a>整体介绍</h5><blockquote>
<p>从<code>DelayQueue</code>类的泛型定义中可以看出，此类只能储存继承自<code>Delayed</code>接口的元素，内部使用一个优先级队列对元素进行排序。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Delayed</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> PriorityQueue&lt;E&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待队列的头节点，可以视作一个缓存</span></span><br><span class="line">    <span class="comment">// 当一个线程成为leader，它只会等待指定延迟的时间，但</span></span><br><span class="line">    <span class="comment">// 其他线程会一直等到。所以leader线程在获取到元素后</span></span><br><span class="line">    <span class="comment">// 一定要释放其他线程，除非其他线程临时成为leader</span></span><br><span class="line">    <span class="keyword">private</span> Thread leader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当队列头部的一个新元素可获得（即超时到期）或者一个新线程成为leader，唤醒此等待条件上的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition();</span><br></pre></td></tr></table></figure>

<h5 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h5><blockquote>
<p>只有两个构造方法，一个是默认构造方法，一个是给定一个集合，并将其中元素增加到等待队列中。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DelayQueue</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> DelayQueue&#125; initially containing the elements of the</span></span><br><span class="line"><span class="comment"> * given collection of &#123;<span class="doctag">@link</span> Delayed&#125; instances.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c the collection of elements to initially contain</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection or any</span></span><br><span class="line"><span class="comment"> *         of its elements are null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DelayQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="增加操作-1"><a href="#增加操作-1" class="headerlink" title="增加操作"></a>增加操作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重用offer方法</span></span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将元素增加到优先级队列中</span></span><br><span class="line">        q.offer(e);</span><br><span class="line">        <span class="keyword">if</span> (q.peek() == e) &#123;</span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为是无界队列，所以插入不会被阻塞。超时方法同理</span></span><br><span class="line">    offer(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="删除操作-1"><a href="#删除操作-1" class="headerlink" title="删除操作"></a>删除操作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E x = poll();</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取并删除第一个元素，如果队列为空返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取第一个元素</span></span><br><span class="line">        E first = q.peek();</span><br><span class="line">        <span class="keyword">return</span> (first == <span class="keyword">null</span> || first.getDelay(NANOSECONDS) &gt; <span class="number">0</span>)</span><br><span class="line">            ? <span class="keyword">null</span></span><br><span class="line">            : q.poll();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提取并删除队列的第一个元素，如果队列为空则等待 </span></span><br><span class="line"><span class="comment"> * 直到有可获得的元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the head of this queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            E first = q.peek();</span><br><span class="line">            <span class="comment">// 如果队列为空，阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                available.await();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 获取头元素的等待延迟</span></span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> q.poll();</span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don&#x27;t retain ref while waiting</span></span><br><span class="line">                <span class="comment">// 如果已经有线程在等待获取头元素，那么阻塞自己</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="comment">// 否则，自己就是leader，等待给定延迟</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果成功获取到元素并且队列不为空，唤醒其他线程</span></span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves and removes the head of this queue, waiting if necessary</span></span><br><span class="line"><span class="comment"> * until an element with an expired delay is available on this queue,</span></span><br><span class="line"><span class="comment"> * or the specified wait time expires.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the head of this queue, or &#123;<span class="doctag">@code</span> null&#125; if the</span></span><br><span class="line"><span class="comment"> *         specified waiting time elapses before an element with</span></span><br><span class="line"><span class="comment"> *         an expired delay becomes available</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            E first = q.peek();</span><br><span class="line">            <span class="comment">// 如果队列为空，超时等待</span></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    nanos = available.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> q.poll();</span><br><span class="line">                <span class="comment">// 如果延迟还未到期，而指定的超时已到期，那么返回null</span></span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don&#x27;t retain ref while waiting</span></span><br><span class="line">                <span class="keyword">if</span> (nanos &lt; delay || leader != <span class="keyword">null</span>)</span><br><span class="line">                    nanos = available.awaitNanos(nanos);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">long</span> timeLeft = available.awaitNanos(delay);</span><br><span class="line">                        nanos -= delay - timeLeft;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="访问操作-1"><a href="#访问操作-1" class="headerlink" title="访问操作"></a>访问操作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E x = peek();</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 委托给优先级队列获取</span></span><br><span class="line">        <span class="keyword">return</span> q.peek();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> drainTo(c, Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (maxElements &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (E first;</span><br><span class="line">             n &lt; maxElements</span><br><span class="line">                 &amp;&amp; (first = q.peek()) != <span class="keyword">null</span></span><br><span class="line">                 &amp;&amp; first.getDelay(NANOSECONDS) &lt;= <span class="number">0</span>;) &#123;</span><br><span class="line">            <span class="comment">// 增加到集合中</span></span><br><span class="line">            c.add(first);   <span class="comment">// In this order, in case add() throws.</span></span><br><span class="line">            <span class="comment">// 从队列中删除此元素</span></span><br><span class="line">            q.poll();</span><br><span class="line">            ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><blockquote>
<p>迭代器使用数组保存队列中的元素，当创建一个迭代器时，使用<code>toArray()</code>方法将当前队列转换为数组，所以此迭代器<strong>不一定</strong>会和内部的优先级队列<strong>保持一致</strong>。迭代器除了提供访问操作外，只提供了一个删除操作，这个删除操作保证不会出现不一致的情况。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr(toArray());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Snapshot iterator that works off  of underlying q array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] array; <span class="comment">// Array of all elements</span></span><br><span class="line">    <span class="keyword">int</span> cursor;           <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="keyword">int</span> lastRet;          <span class="comment">// index of last element, or -1 if no such</span></span><br><span class="line"></span><br><span class="line">    Itr(Object[] array) &#123;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; array.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cursor &gt;= array.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> (E)array[lastRet = cursor++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        removeEQ(array[lastRet]);</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeEQ</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取优先级队列的迭代器，然后执行删除操作</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;E&gt; it = q.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o == it.next()) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="核心要点-1"><a href="#核心要点-1" class="headerlink" title="核心要点"></a>核心要点</h5><ol>
<li>使用此队列时，元素必须要实现<code>Delayed</code>接口</li>
<li>当已经有一个线程等待获取队列头元素时，其他也想要获取元素的线程就会进行等待阻塞状态</li>
<li>迭代器不和内部的优先级队列保持一致性</li>
<li>迭代器的<code>remove()</code>方法与内部的优先级队列保持一致性</li>
</ol>
<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><blockquote>
<p><code>LinkedBlockingQueue</code>类实现了<a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-util-concurrent/blockingqueue.html"><code>BlockingQueue</code></a>接口。阅读<a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-util-concurrent/blockingqueue.html"><code>BlockingQueue</code></a>文本以获取有关的更多信息。</p>
</blockquote>
<p> <code>LinkedBlockingQueue</code>在内部将元素存储在链接结构（链接节点）中。如果需要，该链接结构可以具有一个上限。如果未指定上限，则使用<code>Integer.MAX_VALUE</code>作为上限。</p>
<p> <code>LinkedBlockingQueue</code>内部将元素以FIFO（先入先出）次序存储。队列的头部是已在队列中的时间最长的元素，队列的尾部是已在队列中的时间最短的元素。</p>
<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><blockquote>
<p>以下是如何实例化和使用<code>LinkedBlockingQueue</code>：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BlockingQueue&lt;String&gt; unbounded = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;();</span><br><span class="line">BlockingQueue&lt;String&gt; bounded   = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">bounded.put(<span class="string">&quot;Value&quot;</span>);</span><br><span class="line"></span><br><span class="line">String value = bounded.take();</span><br></pre></td></tr></table></figure>

<h4 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h4><h5 id="整体介绍-1"><a href="#整体介绍-1" class="headerlink" title="整体介绍"></a>整体介绍</h5><blockquote>
<p><code>LinkedBlockingQueue</code>内部使用了一个单向链表，同时它提供了两个锁，一个用于获取并删除元素，一个用于增加元素。<code>count</code>字段使用原子变量，避免修改它时需要同时获取两个锁。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下面中的一个：</span></span><br><span class="line"><span class="comment">     * - 真实的后继节点</span></span><br><span class="line"><span class="comment">     * - 这个节点本身，此时原后继节点现在是head.next，即第一个元素</span></span><br><span class="line"><span class="comment">     * - null, 意味没有后继节点，此节点是队列最后一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(E x) &#123; item = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Current number of elements */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Head of linked list.</span></span><br><span class="line"><span class="comment"> * Invariant: head.item == null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tail of linked list.</span></span><br><span class="line"><span class="comment"> * Invariant: last.next == null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Lock held by take, poll, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure>

<h5 id="增加操作-2"><a href="#增加操作-2" class="headerlink" title="增加操作"></a>增加操作</h5><blockquote>
<p>注意进行增加操作时，只对<code>putLock</code>加锁，如果还对<code>takeLock</code>也进行加锁，那么就会影响性能。同时，为了弥补此方法带来的后果，<code>count</code>使用原子变量，进行CAS更新，防止数据不一致。</p>
</blockquote>
<p> 为了提升性能，在增加元素成功后，如果队列还没有满，那么便唤醒其他因队列满而被阻塞的插入线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 注意即使count没有被锁保护，它依然可以被用作等待条件</span></span><br><span class="line">        <span class="comment">// 判定。因为此时count只会被减少(putLock已加锁)，如果容量</span></span><br><span class="line">        <span class="comment">// 改变，会被唤醒。count在其他地方的使用也与此相似。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列已满，阻塞自己</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入队列中</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        <span class="comment">// CAS更新count值</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="comment">// 如果队列没满，唤醒其他等待插入的线程</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果队列原来是空队列，唤醒等待提取元素的线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert putLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert last.next == null;</span></span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    <span class="comment">// 先加锁，才能调用对应Condtion的signal()方法</span></span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="comment">// 队列已满，返回false</span></span><br><span class="line">    <span class="keyword">if</span> (count.get() == capacity)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count.get() &lt; capacity) &#123;</span><br><span class="line">            enqueue(node);</span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 等待-超时机制</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(<span class="keyword">new</span> Node&lt;E&gt;(e));</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="删除操作-2"><a href="#删除操作-2" class="headerlink" title="删除操作"></a>删除操作</h5><blockquote>
<p>删除操作与增加操作一样。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 当队列为空，阻塞自己</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将头节点出队</span></span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="comment">// 如果队列还有元素，唤醒其他等待提取元素的线程</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果原本队列是满的，唤醒增加线程，因为现在元素已经被取出，队列不满</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert takeLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert head.item == null;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头节点为空，其中不存储元素</span></span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    h.next = h; <span class="comment">// help GC</span></span><br><span class="line">    head = first;</span><br><span class="line">    E x = first.item;</span><br><span class="line">    first.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    E x = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count.get() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = dequeue();</span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除一个指定元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 将两个锁全部加锁</span></span><br><span class="line">    fullyLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; pred = head, p = pred.next;</span><br><span class="line">             p != <span class="keyword">null</span>;</span><br><span class="line">             pred = p, p = p.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(p.item)) &#123;</span><br><span class="line">                <span class="comment">// 从队列中移除此节点</span></span><br><span class="line">                unlink(p, pred);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放全部两个锁</span></span><br><span class="line">        fullyUnlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlink</span><span class="params">(Node&lt;E&gt; p, Node&lt;E&gt; pred)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert putLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert takeLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// p.next没有被设置为null，为了保证迭代器遍历到p时继续工作，</span></span><br><span class="line">    <span class="comment">// 保证弱一致性</span></span><br><span class="line">    p.item = <span class="keyword">null</span>;</span><br><span class="line">    pred.next = p.next;</span><br><span class="line">    <span class="keyword">if</span> (last == p)</span><br><span class="line">        last = pred;</span><br><span class="line">    <span class="keyword">if</span> (count.getAndDecrement() == capacity)</span><br><span class="line">        notFull.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="访问操作-2"><a href="#访问操作-2" class="headerlink" title="访问操作"></a>访问操作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列为空，返回null</span></span><br><span class="line">    <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 返回第一个元素</span></span><br><span class="line">        <span class="keyword">return</span> (count.get() &gt; <span class="number">0</span>) ? head.next.item : <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="其他操作-1"><a href="#其他操作-1" class="headerlink" title="其他操作"></a>其他操作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fullyLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; p, h = head; (p = h.next) != <span class="keyword">null</span>; h = p) &#123;</span><br><span class="line">            <span class="comment">// 使得next指向自己</span></span><br><span class="line">            h.next = h;</span><br><span class="line">            <span class="comment">// 解除对元素实体的引用</span></span><br><span class="line">            p.item = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = last;</span><br><span class="line">        <span class="comment">// assert head.item == null &amp;&amp; head.next == null;</span></span><br><span class="line">        <span class="comment">// 如果原来队列是满的，唤醒等待的插入线程</span></span><br><span class="line">        <span class="keyword">if</span> (count.getAndSet(<span class="number">0</span>) == capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fullyUnlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> drainTo(c, Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (maxElements &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> signalNotFull = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前队列中的元素数量</span></span><br><span class="line">        <span class="keyword">int</span> n = Math.min(maxElements, count.get());</span><br><span class="line">        <span class="comment">// count.get provides visibility to first n Nodes</span></span><br><span class="line">        Node&lt;E&gt; h = head;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将n个元素加入到指定集合中</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">                Node&lt;E&gt; p = h.next;</span><br><span class="line">                c.add(p.item);</span><br><span class="line">                p.item = <span class="keyword">null</span>;</span><br><span class="line">                h.next = h;</span><br><span class="line">                h = p;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Restore invariants even if c.add() threw</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// assert h.item == null;</span></span><br><span class="line">                head = h;</span><br><span class="line">                signalNotFull = (count.getAndAdd(-i) == capacity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">        <span class="keyword">if</span> (signalNotFull)</span><br><span class="line">            signalNotFull();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h5><blockquote>
<p><code>LinkedBlockingQueue</code>的迭代器与<code>DelayQueue</code>的不同，<code>DelayQueue</code>的迭代器与原组件没有任何的一致性，而<code>LinkedBlockingQueue</code>的迭代器与内部的链表保持了弱一致性。</p>
</blockquote>
<p> 注意它的<code>next()</code>方法，它会跳过内容为null的节点，回忆前面删除操作中的<code>remove(Object)</code>方法，他没有修改节点的next字段，如果修改了，迭代器就会无法正常工作，而为了保证一致性，迭代器也需要跳过这个空节点。</p>
<p> 而它的<code>forEachRemaining(Consumer&lt;? super E&gt; action)</code>方法是分批次进行处理的，每批64个元素，如果数量小于64，那就使用此数量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; next;           <span class="comment">// 持有nextItem的节点</span></span><br><span class="line">    <span class="keyword">private</span> E nextItem;             <span class="comment">// 下一个进行处理的元素</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; lastRet;        <span class="comment">// 上一个返回的元素，即当前正在使用的</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; ancestor;       <span class="comment">// Helps unlink lastRet on remove()</span></span><br><span class="line"></span><br><span class="line">    Itr() &#123;</span><br><span class="line">        fullyLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 保存第一个元素</span></span><br><span class="line">            <span class="keyword">if</span> ((next = head.next) != <span class="keyword">null</span>)</span><br><span class="line">                nextItem = next.item;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            fullyUnlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; p;</span><br><span class="line">        <span class="keyword">if</span> ((p = next) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        lastRet = p;</span><br><span class="line">        E x = nextItem;</span><br><span class="line">        fullyLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            E e = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 注意此处，遇到空节点会跳过去访问下一个节点</span></span><br><span class="line">            <span class="keyword">for</span> (p = p.next; p != <span class="keyword">null</span> &amp;&amp; (e = p.item) == <span class="keyword">null</span>; )</span><br><span class="line">                p = succ(p);</span><br><span class="line">            next = p;</span><br><span class="line">            nextItem = e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            fullyUnlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Node&lt;E&gt; <span class="title">succ</span><span class="params">(Node&lt;E&gt; p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 正常出队的元素next字段会指向自己</span></span><br><span class="line">        <span class="keyword">if</span> (p == (p = p.next))</span><br><span class="line">            p = head.next;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// A variant of forEachFrom</span></span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        Node&lt;E&gt; p;</span><br><span class="line">        <span class="keyword">if</span> ((p = next) == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        lastRet = p;</span><br><span class="line">        next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> batchSize = <span class="number">64</span>;</span><br><span class="line">        Object[] es = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> n, len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            fullyLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (es == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                    <span class="comment">// 获取真正存在的元素的数量，如果多于64，分批进行，一批为64个</span></span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;E&gt; q = p; q != <span class="keyword">null</span>; q = succ(q))</span><br><span class="line">                        <span class="keyword">if</span> (q.item != <span class="keyword">null</span> &amp;&amp; ++len == batchSize)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    es = <span class="keyword">new</span> Object[len];</span><br><span class="line">                    es[<span class="number">0</span>] = nextItem;</span><br><span class="line">                    nextItem = <span class="keyword">null</span>;</span><br><span class="line">                    n = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    n = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// n为1的使用只因为p=p.next，经过此步后p已经不是首元素，</span></span><br><span class="line">                <span class="comment">// 而是第二个元素。而后面批次的插入直接从0开始即可</span></span><br><span class="line">                <span class="comment">// 将元素放入数组中</span></span><br><span class="line">                <span class="keyword">for</span> (; p != <span class="keyword">null</span> &amp;&amp; n &lt; len; p = succ(p))</span><br><span class="line">                    <span class="keyword">if</span> ((es[n] = p.item) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        lastRet = p;</span><br><span class="line">                        n++;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                fullyUnlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 分别调用accept方法</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> E e = (E) es[i];</span><br><span class="line">                action.accept(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (n &gt; <span class="number">0</span> &amp;&amp; p != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前元素</span></span><br><span class="line">        Node&lt;E&gt; p = lastRet;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        lastRet = <span class="keyword">null</span>;</span><br><span class="line">        fullyLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.item != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ancestor == <span class="keyword">null</span>)</span><br><span class="line">                    ancestor = head;</span><br><span class="line">                <span class="comment">// 获取p的前驱结点</span></span><br><span class="line">                ancestor = findPred(p, ancestor);</span><br><span class="line">                <span class="comment">// 从链表中删除结点p</span></span><br><span class="line">                unlink(p, ancestor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            fullyUnlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="核心要点-2"><a href="#核心要点-2" class="headerlink" title="核心要点"></a>核心要点</h5><ol>
<li>内部使用一个单向链表，以FIFO顺序存储</li>
<li>可以在链表两头同时进行操作，所以使用两个锁分别保护</li>
<li>插入线程在执行完操作后如果队列未满会唤醒其他等待插入的线程，同时队列非空还会唤醒等待获取元素的线程；提取线程同理。</li>
<li>迭代器与单向链表保持弱一致性，调用<code>remove(T)</code>方法删除一个元素后，不会解除其对下一个结点的next引用，否则迭代器将无法工作。</li>
<li>迭代器的<code>forEachRemaining(Consumer&lt;? super E&gt; action)</code>以64个元素为一批进行操作</li>
</ol>
<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><blockquote>
<p><code>PriorityBlockingQueue</code>类实现了<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://tutorials.jenkov.com/java-util-concurrent/blockingqueue.html"><code>BlockingQueue</code></a>接口。阅读<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://tutorials.jenkov.com/java-util-concurrent/blockingqueue.html"><code>BlockingQueue</code></a>文本以获取有关的更多信息。</p>
</blockquote>
<p> <code>PriorityBlockingQueue</code>是一个<strong>无限的并发队列</strong>。它使用与<code>java.util.PriorityQueue</code>类相同的排序规则。你不能将null插入此队列。</p>
<p> 插入<code>java.util.PriorityQueue</code>的所有元素必须实现<code>java.lang.Comparable</code>接口。因此，元素根据你在<code>Comparable</code> 中的实现进行优先级排序。</p>
<p> 注意，对于具有相同优先级的元素（<code>compare()== 0</code>），不会强制执行任何特定行为。</p>
<p> 另请注意，如果你从<code>PriorityBlockingQueue</code>得到一个<code>Iterator</code>，<code>Iterator</code>不保证按优先级顺序迭代元素。</p>
<h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><blockquote>
<p>以下是使用<code>PriorityBlockingQueue</code>的示例：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> PriorityBlockingQueue&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//String implements java.lang.Comparable</span></span><br><span class="line">queue.put(<span class="string">&quot;Value&quot;</span>);</span><br><span class="line"></span><br><span class="line">String value = queue.take();</span><br></pre></td></tr></table></figure>

<h4 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h4><blockquote>
<p><code>PriorityBlockingQueue</code>内部使用了一个以数组为基础的二叉堆，所有的公共操作使用一个锁来进行保护。当对数组进行扩容时，放弃主锁，使用一个简单的自旋锁进行扩容，这样做是为了让扩容和提取元素同步进行。</p>
</blockquote>
<h5 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认初始化大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组可分配的最大容量。</span></span><br><span class="line"><span class="comment"> * 一些虚拟机在数组中分配了对象头，尝试分配更大的容量</span></span><br><span class="line"><span class="comment"> * 可能会导致OOM，请求的数组容量超过了允许的上限。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 优先级队列使用Comparator进行排序，或者通过元素的自然顺序，</span></span><br><span class="line"><span class="comment"> * 即实现了Comparable接口。如果没有比较器：对于在堆中的每个结点n， </span></span><br><span class="line"><span class="comment"> * 以及它的后代 d，n &lt;= d。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较器，为null代表使用自然顺序排序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分配时的自旋锁，通过CAS获得</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> allocationSpinLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只为序列化操作使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> PriorityQueue&lt;E&gt; q;</span><br></pre></td></tr></table></figure>

<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                             Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">this</span>.notEmpty = lock.newCondition();</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果给定的集合是 SortedSet或者 PriorityQueue， 这个优先级</span></span><br><span class="line"><span class="comment"> * 队列根据同样的顺序排序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">this</span>.notEmpty = lock.newCondition();</span><br><span class="line">    <span class="keyword">boolean</span> heapify = <span class="keyword">true</span>; <span class="comment">// true 如果不知道二叉堆的顺序</span></span><br><span class="line">    <span class="keyword">boolean</span> screen = <span class="keyword">true</span>;  <span class="comment">// true 如果必须检查null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 针对 SortedSet和 PriorityQueue处理</span></span><br><span class="line">    <span class="keyword">if</span> (c <span class="keyword">instanceof</span> SortedSet&lt;?&gt;) &#123;</span><br><span class="line">        SortedSet&lt;? extends E&gt; ss = (SortedSet&lt;? extends E&gt;) c;</span><br><span class="line">        <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) ss.comparator();</span><br><span class="line">        heapify = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c <span class="keyword">instanceof</span> PriorityBlockingQueue&lt;?&gt;) &#123;</span><br><span class="line">        PriorityBlockingQueue&lt;? extends E&gt; pq =</span><br><span class="line">            (PriorityBlockingQueue&lt;? extends E&gt;) c;</span><br><span class="line">        <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) pq.comparator();</span><br><span class="line">        screen = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (pq.getClass() == PriorityBlockingQueue.class) <span class="comment">// exact match</span></span><br><span class="line">            heapify = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="comment">// If c.toArray incorrectly doesn&#x27;t return Object[],  it.</span></span><br><span class="line">    <span class="keyword">if</span> (a.getClass() != Object[].class)</span><br><span class="line">        a = Arrays.Of(a, n, Object[].class);</span><br><span class="line">    <span class="keyword">if</span> (screen &amp;&amp; (n == <span class="number">1</span> || <span class="keyword">this</span>.comparator != <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (a[i] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.queue = a;</span><br><span class="line">    <span class="keyword">this</span>.size = n;</span><br><span class="line">    <span class="keyword">if</span> (heapify)</span><br><span class="line">        heapify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="增加操作-3"><a href="#增加操作-3" class="headerlink" title="增加操作"></a>增加操作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为PriorityBlockingQueue本身拒绝插入null，所以offer也需要抛出NPE，</span></span><br><span class="line"><span class="comment">// 复用offer方法即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此队列是无界的，不会返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">int</span> n, cap;</span><br><span class="line">    Object[] array;</span><br><span class="line">    <span class="comment">// 扩容</span></span><br><span class="line">    <span class="keyword">while</span> ((n = size) &gt;= (cap = (array = queue).length))</span><br><span class="line">        tryGrow(array, cap);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将元素插入二叉堆中</span></span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">            siftUpComparable(n, e, array);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftUpUsingComparator(n, e, array, cmp);</span><br><span class="line">        size = n + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 唤醒等待获取元素的线程</span></span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryGrow</span><span class="params">(Object[] array, <span class="keyword">int</span> oldCap)</span> </span>&#123;</span><br><span class="line">    lock.unlock(); <span class="comment">// must release and then re-acquire main lock</span></span><br><span class="line">    Object[] newArray = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 获取自旋锁</span></span><br><span class="line">    <span class="keyword">if</span> (allocationSpinLock == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        ALLOCATIONSPINLOCK.compareAndSet(<span class="keyword">this</span>, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 计算新容量。如果当前容量很小，那么直接扩容一倍多一点，</span></span><br><span class="line">            <span class="comment">// 因为此时容量可能会迅速增长，否则扩容50%即可</span></span><br><span class="line">            <span class="keyword">int</span> newCap = oldCap + ((oldCap &lt; <span class="number">64</span>) ?</span><br><span class="line">                                   (oldCap + <span class="number">2</span>) : <span class="comment">// grow faster if small</span></span><br><span class="line">                                   (oldCap &gt;&gt; <span class="number">1</span>));</span><br><span class="line">            <span class="comment">// 如果新容量大于最大容量，那么计算当前最小容量（+1），</span></span><br><span class="line">            <span class="comment">// 如果依然大于最大容量，抛出OOM</span></span><br><span class="line">            <span class="keyword">if</span> (newCap - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;    <span class="comment">// possible overflow</span></span><br><span class="line">                <span class="keyword">int</span> minCap = oldCap + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (minCap &lt; <span class="number">0</span> || minCap &gt; MAX_ARRAY_SIZE)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">                newCap = MAX_ARRAY_SIZE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newCap &gt; oldCap &amp;&amp; queue == array)</span><br><span class="line">                newArray = <span class="keyword">new</span> Object[newCap];</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            allocationSpinLock = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// CAS竞争自旋锁失败，调度此线程</span></span><br><span class="line">    <span class="keyword">if</span> (newArray == <span class="keyword">null</span>) <span class="comment">// back off if another thread is allocating</span></span><br><span class="line">        Thread.yield();</span><br><span class="line">    <span class="comment">// 加锁，拷贝元素</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">if</span> (newArray != <span class="keyword">null</span> &amp;&amp; queue == array) &#123;</span><br><span class="line">        queue = newArray;</span><br><span class="line">        System.array(array, <span class="number">0</span>, newArray, <span class="number">0</span>, oldCap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此队列是无界的，所以永远不会被阻塞，复用offer方法即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    offer(e); <span class="comment">// never need to block</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e); <span class="comment">// never need to block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="删除操作-3"><a href="#删除操作-3" class="headerlink" title="删除操作"></a>删除操作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = size - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 队列为空返回null</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取头元素</span></span><br><span class="line">        Object[] array = queue;</span><br><span class="line">        E result = (E) array[<span class="number">0</span>];</span><br><span class="line">        E x = (E) array[n];</span><br><span class="line">        array[n] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 整理二叉堆</span></span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">            siftDownComparable(<span class="number">0</span>, x, array, n);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftDownUsingComparator(<span class="number">0</span>, x, array, n, cmp);</span><br><span class="line">        size = n;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    E result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> ( (result = dequeue()) == <span class="keyword">null</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    E result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> ( (result = dequeue()) == <span class="keyword">null</span> &amp;&amp; nanos &gt; <span class="number">0</span>)</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="访问操作-3"><a href="#访问操作-3" class="headerlink" title="访问操作"></a>访问操作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (size == <span class="number">0</span>) ? <span class="keyword">null</span> : (E) queue[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="迭代器-2"><a href="#迭代器-2" class="headerlink" title="迭代器"></a>迭代器</h5><blockquote>
<p><code>PriorityBlockingQueue</code>类中的迭代器和<code>DelayQueue</code>中的迭代器一样，都不会与原组件保证一致性。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用toArray()方法获取当前的二叉堆</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr(toArray());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Snapshot iterator that works off  of underlying q array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] array; <span class="comment">// Array of all elements</span></span><br><span class="line">    <span class="keyword">int</span> cursor;           <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="keyword">int</span> lastRet;          <span class="comment">// index of last element, or -1 if no such</span></span><br><span class="line"></span><br><span class="line">    Itr(Object[] array) &#123;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; array.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cursor &gt;= array.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> (E)array[lastRet = cursor++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        removeEQ(array[lastRet]);</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="核心要点-3"><a href="#核心要点-3" class="headerlink" title="核心要点"></a>核心要点</h5><ol>
<li>必须提供要<code>Comparator</code>接口或者队列元素实现<code>Comparable</code>接口。</li>
<li>可以同时进行扩容和提取元素的操作，不过只能有一个线程进行扩容</li>
<li>数组大小小于64时，进行双倍容量的扩展，否则扩容1.5倍</li>
<li>使用迭代器访问元素的顺序不会按指定的比较器顺序</li>
<li>迭代器不会与原数组保持一致性</li>
</ol>
<h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><blockquote>
<p><code>LinkedBlockingDeque</code>类实现了<a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-util-concurrent/blockingdeque.html"><code>BlockingDeque</code></a>接口。阅读<a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-util-concurrent/blockingdeque.html"><code>BlockingDeque</code></a>文本以获取有关的更多信息。</p>
</blockquote>
<p> <code>Deque</code>来自“双端队列” 这个词。<code>Deque</code>是一个队列，你可以在插入和删除队列两端的元素。</p>
<p> <code>LinkedBlockingDeque</code>是一个<code>Deque</code>，如果一个线程试图从中获取一个元素，而队列空的，不管线程从哪一端试图获取元素，都会被阻塞。</p>
<h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><blockquote>
<p>以下是实例化和使用<code>LinkedBlockingDeque</code>的例子：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BlockingDeque&lt;String&gt; deque = <span class="keyword">new</span> LinkedBlockingDeque&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">deque.addFirst(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">deque.addLast(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">String two = deque.takeLast();</span><br><span class="line">String one = deque.takeFirst();</span><br></pre></td></tr></table></figure>

<h4 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h4><h5 id="整体介绍-2"><a href="#整体介绍-2" class="headerlink" title="整体介绍"></a>整体介绍</h5><p> <code>LinkedBlockingDeque</code>与<code>LinkedBlockingQueue</code>的实现大体上类似，区别在于<code>LinkedBlockingDeque</code>提供的操作更多。并且<code>LinkedBlockingQueue</code>内置两个锁分别用于put和take操作，而<code>LinkedBlockingDeque</code>只使用一个锁控制所有操作。因为队列能够同时在头尾进行put和take操作，所以使用两个锁也需要将两个锁同时加锁才能保证操作的同步性，不如只使用一个锁的性能好</p>
<blockquote>
<p>同步节点相比<code>LinkedBlockingQueue</code>多了一个<code>prev</code>字段。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(E x) &#123;</span><br><span class="line">        item = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="增加操作-4"><a href="#增加操作-4" class="headerlink" title="增加操作"></a>增加操作</h5><blockquote>
<p>增加操作相比<code>LinkedBlockingQueue</code>只能在队列尾部增加，它能在队列的头尾两端都进行增加操作。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 复用offer方法</span></span><br><span class="line">    <span class="keyword">if</span> (!offerFirst(e))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Deque full&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!offerLast(e))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Deque full&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 构造节点</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 插入到队列头部</span></span><br><span class="line">        <span class="keyword">return</span> linkFirst(node);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">linkFirst</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列已满，返回false</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= capacity)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 获取头节点，将自己的 next字段指向头节点，然后设置自己为头节点</span></span><br><span class="line">    Node&lt;E&gt; f = first;</span><br><span class="line">    node.next = f;</span><br><span class="line">    first = node;</span><br><span class="line">    <span class="comment">// 如果队列为空，尾节点也指向自己</span></span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        last = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = node;</span><br><span class="line">    ++count;</span><br><span class="line">    <span class="comment">// 唤醒等待获取元素的线程</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 插入到队列尾部</span></span><br><span class="line">        <span class="keyword">return</span> linkLast(node);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">linkLast</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果队列已满，返回false</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= capacity)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 将自己设置为尾节点</span></span><br><span class="line">    Node&lt;E&gt; l = last;</span><br><span class="line">    node.prev = l;</span><br><span class="line">    last = node;</span><br><span class="line">    <span class="comment">// 如果队列为空，头节点也指向自己</span></span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">        first = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = node;</span><br><span class="line">    ++count;</span><br><span class="line">    <span class="comment">// 唤醒等待获取元素的线程</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putFirst</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列已满，等待</span></span><br><span class="line">        <span class="keyword">while</span> (!linkFirst(node))</span><br><span class="line">            notFull.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putLast</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列已满，等待</span></span><br><span class="line">        <span class="keyword">while</span> (!linkLast(node))</span><br><span class="line">            notFull.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="comment">// 计算超时时间</span></span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列已满，超时等待</span></span><br><span class="line">        <span class="keyword">while</span> (!linkFirst(node)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!linkLast(node)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="删除操作-4"><a href="#删除操作-4" class="headerlink" title="删除操作"></a>删除操作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 复用poll操作</span></span><br><span class="line">    E x = pollFirst();</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E x = pollLast();</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取头节点的值，并删除它</span></span><br><span class="line">        <span class="keyword">return</span> unlinkFirst();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列为空，返回null</span></span><br><span class="line">    Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 重置头节点</span></span><br><span class="line">    Node&lt;E&gt; n = f.next;</span><br><span class="line">    E item = f.item;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = f; <span class="comment">// help GC</span></span><br><span class="line">    first = n;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        n.prev = <span class="keyword">null</span>;</span><br><span class="line">    --count;</span><br><span class="line">    <span class="comment">// 唤醒等待插入的线程</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unlinkLast();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">    Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 队列为空，返回null</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 更新尾节点</span></span><br><span class="line">    Node&lt;E&gt; p = l.prev;</span><br><span class="line">    E item = l.item;</span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = l; <span class="comment">// help GC</span></span><br><span class="line">    last = p;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p.next = <span class="keyword">null</span>;</span><br><span class="line">    --count;</span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">takeFirst</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        E x;</span><br><span class="line">        <span class="comment">// 如果队列为空，等待</span></span><br><span class="line">        <span class="keyword">while</span> ( (x = unlinkFirst()) == <span class="keyword">null</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">takeLast</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        E x;</span><br><span class="line">        <span class="comment">// 如果队列为空，等待</span></span><br><span class="line">        <span class="keyword">while</span> ( (x = unlinkLast()) == <span class="keyword">null</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        E x;</span><br><span class="line">        <span class="keyword">while</span> ( (x = unlinkFirst()) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        E x;</span><br><span class="line">        <span class="keyword">while</span> ( (x = unlinkLast()) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="访问操作-4"><a href="#访问操作-4" class="headerlink" title="访问操作"></a>访问操作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 复用peek方法</span></span><br><span class="line">    E x = peekFirst();</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E x = peekLast();</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列不为空，返回头元素</span></span><br><span class="line">        <span class="keyword">return</span> (first == <span class="keyword">null</span>) ? <span class="keyword">null</span> : first.item;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列不为空，返回尾元素</span></span><br><span class="line">        <span class="keyword">return</span> (last == <span class="keyword">null</span>) ? <span class="keyword">null</span> : last.item;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="BlockingQueue-方法"><a href="#BlockingQueue-方法" class="headerlink" title="BlockingQueue 方法"></a>BlockingQueue 方法</h5><blockquote>
<p>由于<code>BlockingDeque</code>继承自<code>BlockingQueue</code>接口，所以需要实现<code>BlockingQueue</code>中的方法，具体只需要复用前面提到的方法即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offerLast(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    putLast(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offerLast(e, timeout, unit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pollFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> takeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pollFirst(timeout, unit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> peekFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="核心要点-4"><a href="#核心要点-4" class="headerlink" title="核心要点"></a>核心要点</h5><ol>
<li>内部使用一个双向链表</li>
<li>可以在链表两头同时进行put和take操作，只能使用一个锁</li>
<li>插入线程在执行完操作后如果队列未满会唤醒其他等待插入的线程，同时队列非空还会唤醒等待获取元素的线程；take线程同理。</li>
<li>迭代器与内部的双向链表保持弱一致性，调用<code>remove(T)</code>方法删除一个元素后，不会解除其对下一个结点的next引用，否则迭代器将无法工作。</li>
<li>迭代器的<code>forEachRemaining(Consumer&lt;? super E&gt; action)</code>以64个元素为一批进行操作</li>
<li><code>forEach(Consumer&lt;? super E&gt; action)</code>，<code>removeIf</code>，<code>removeAll</code>，<code>retainAll</code>都是64个元素为一批进行操作</li>
</ol>
<h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><blockquote>
<p><code>SynchronousQueue</code>类实现了<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://tutorials.jenkov.com/java-util-concurrent/blockingqueue.html"><code>BlockingQueue</code></a>接口。阅读<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://tutorials.jenkov.com/java-util-concurrent/blockingqueue.html"><code>BlockingQueue</code></a>文本以获取有关的更多信息。</p>
</blockquote>
<p> <code>SynchronousQueue</code>是一个内部只能包含一个元素的队列。插入元素到队列的线程被阻塞，直到另一个线程从队列中获取了队列中存储的元素。同样，如果线程尝试获取元素并且当前不存在任何元素，则该线程将被阻塞，直到线程将元素插入队列。</p>
<p> 将这个类称为队列有点夸大其词。这更像是一个点。</p>
<h4 id="源码-5"><a href="#源码-5" class="headerlink" title="源码"></a>源码</h4><p> <code>SynchronousQueue</code>的内部实现了两个类，一个是<code>TransferStack</code>类，使用LIFO顺序存储元素，这个类用于非公平模式；还有一个类是<code>TransferQueue</code>，使用FIFI顺序存储元素，这个类用于公平模式。这两个类继承自”Nonblocking Concurrent Objects with Condition Synchronization”算法，此算法是由W. N. Scherer III 和 M. L. Scott提出的，关于此算法的理论内容在这个网站中：<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://www.cs.rochester.edu/u/scott/synchronization/pseudocode/duals.html">http://www.cs.rochester.edu/u/scott/synchronization/pseudocode/duals.html</a>。两个类的性能差不多，FIFO通常用于在竞争下支持更高的吞吐量，而LIFO在一般的应用中保证更高的线程局部性。</p>
<p> 队列（或者栈）的节点在任何时间要么是”date”模式 —— 通过put操作提供的元素的模式，要么是”request”模式 —— 通过take操作取出元素的模式，要么为空。还有一个模式是”fulfill”模式，当队列有一个data节点时，请求从队列中获取一个元素就会构造一个”fulfill”模式的节点，反之亦然。这个类最有趣的特性在于任何操作都能够计算出现在队列头节点处于什么模式，然后根据它进行操作而无需使用锁。</p>
<p> 队列和栈都继承了抽象类<code>Transferer</code>，这个类只定义了一个方法<code>transfer</code>，此方法可以既可以执行put也可以执行take操作。这两个操作被统一到了一个方法中，因为在<code>dual</code>数据结构中，put和take操作是对称的，所以相近的所有结点都可以被结合。使用<code>transfer</code>方法是从长远来看的，它相比分为两个几乎重复的部分来说更加容易理解。</p>
<p> 队列和栈数据结构在概念上有许多相似性，但是在真正的实现细节上却几乎没有什么相似的地方。为了简单起见，它们保持清晰，这样在以后它们能以不同的方法扩展。</p>
<p> 在<code>SynchronousQueue</code>中使用的队列和栈的算法和”Nonblocking Concurrent Objects with Condition Synchronization”算法相比是不同的版本，包括对取消的处理。主要的差别如下：</p>
<ol>
<li><p>最初的算法使用了位标记指针，但是此类在结点中使用了模式位，这导致了很多深入的改变。</p>
</li>
<li><p><code>SynchronousQueue</code>必须阻塞线程，直到变为<code>fulfilled</code>模式。</p>
</li>
<li><p>支持取消操作，通过超时和中断方式，包括清除被取消的结点/线程，以避免无法进行垃圾回收和无用的内存消耗。</p>
</li>
</ol>
<p> 阻塞主要通过<code>LockSupport</code>的<code>park/unpark</code>方法完成，除了下一个结点将要变为<code>fulfilled</code>模式的情况，这时会在多处理器机器中使用自旋等待。在非常忙碌的<code>SynchronousQueue</code>中，自旋可以显着改变吞吐量。而在不忙碌的情况下，自旋的次数就会变的足够小，不会影响性能。</p>
<p> 清除操作在队列和栈中以不同的方式完成。对于队列，当结点被取消时，我们总是可以在O(1)时间立刻删除它。但是如果它被固定在队尾，它就必须等待直到其他取消操作完成。对于栈来说，我们需要以O(n)时间遍历来确保能够删除这个结点，不过这个操作可以和其他访问栈的线程同时进行。</p>
<blockquote>
<p>队列和栈的父类为<code>Transferer</code>。它只定义了一个通用方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行put或者take操作/</span></span><br><span class="line"><span class="comment">     * 如果参数e非空，这个元素将被交给一个消费线程；如果为null，</span></span><br><span class="line"><span class="comment">     * 则请求返回一个被生产者提交的元素。</span></span><br><span class="line"><span class="comment">     * 如果返回的结果非空，那么元素被提交了或被接受了；如果为null，</span></span><br><span class="line"><span class="comment">     * 这个操作可能因为超时或者中断失败了。调用者可以通过检查</span></span><br><span class="line"><span class="comment">     * Thread.interrupted来区分到底是因为什么元素失败。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="TransferStack"><a href="#TransferStack" class="headerlink" title="TransferStack"></a>TransferStack</h5><blockquote>
<p>这个类继承自Scherer-Scott的 <em>dual stack</em> 算法，但不完全相同，它使用结点而不是位标记指针。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferStack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Modes for SNodes, ORed together in node fields */</span></span><br><span class="line">    <span class="comment">/** 表示一个未满足的消费者 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST    = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** 表示一个未满足的生产者 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATA       = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** Node is fulfilling another unfulfilled DATA or REQUEST */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FULFILLING = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFulfilling</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> (m &amp; FULFILLING) != <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Node class for TransferStacks. */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> SNode next;        <span class="comment">// 栈中的下一个结点</span></span><br><span class="line">        <span class="keyword">volatile</span> SNode match;       <span class="comment">// 匹配此结点的结点</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter;     <span class="comment">// 控制 park/unpark</span></span><br><span class="line">        Object item;                <span class="comment">// 数据</span></span><br><span class="line">        <span class="keyword">int</span> mode;</span><br></pre></td></tr></table></figure>

<h5 id="核心算法-transfer"><a href="#核心算法-transfer" class="headerlink" title="核心算法 transfer"></a>核心算法 transfer</h5><blockquote>
<p>使用put操作时参数e不为空，而使用take操作时参数e为null，而<code>timed</code>和<code>nanos</code>指定是否使用超时。</p>
</blockquote>
<ol>
<li>如果头节点为空或者已经包含了相同模式的结点，那么尝试将结点<br> 增加到栈中并且等待匹配。如果被取消，返回null</li>
<li>如果头节点是一个模式不同的结点，尝试将一个<code>fulfilling</code>结点加入到栈中，匹配相应的等待结点，然后一起从栈中弹出，并且返回匹配的元素。匹配和弹出操作可能无法进行，由于其他线程正在执行操作3</li>
<li>如果栈顶已经有了一个<code>fulfilling</code>结点，帮助它完成它的匹配和弹出操作，然后继续。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 基础算法，循环尝试下面三种操作中的一个：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. 如果头节点为空或者已经包含了相同模式的结点，尝试将结点</span></span><br><span class="line"><span class="comment">     *    增加到栈中并且等待匹配。如果被取消，返回null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. 如果头节点是一个模式不同的结点，尝试将一个`fulfilling`结点加入</span></span><br><span class="line"><span class="comment">     *    到栈中，匹配相应的等待结点，然后一起从栈中弹出，</span></span><br><span class="line"><span class="comment">     *    并且返回匹配的元素。匹配和弹出操作可能无法进行，</span></span><br><span class="line"><span class="comment">     *    由于其他线程正在执行操作3</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. 如果栈顶已经有了一个`fulfilling`结点，帮助它完成</span></span><br><span class="line"><span class="comment">     *    它的匹配和弹出操作，然后继续。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    SNode s = <span class="keyword">null</span>; <span class="comment">// constructed/reused as needed</span></span><br><span class="line">    <span class="comment">// 传入参数为null代表请求获取一个元素，否则表示插入元素</span></span><br><span class="line">    <span class="keyword">int</span> mode = (e == <span class="keyword">null</span>) ? REQUEST : DATA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        SNode h = head;</span><br><span class="line">        <span class="comment">// 如果头节点为空或者和当前模式相同</span></span><br><span class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span> || h.mode == mode) &#123;  <span class="comment">// empty or same-mode</span></span><br><span class="line">            <span class="comment">// 设置超时时间为 0，立刻返回</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;     <span class="comment">// can&#x27;t wait</span></span><br><span class="line">                <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.isCancelled())</span><br><span class="line">                    casHead(h, h.next);     <span class="comment">// pop cancelled node</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 构造一个结点并且设为头节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s = snode(s, e, h, mode))) &#123;</span><br><span class="line">                <span class="comment">// 等待满足</span></span><br><span class="line">                SNode m = awaitFulfill(s, timed, nanos);</span><br><span class="line">                <span class="keyword">if</span> (m == s) &#123;               <span class="comment">// wait was cancelled</span></span><br><span class="line">                    clean(s);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((h = head) != <span class="keyword">null</span> &amp;&amp; h.next == s)</span><br><span class="line">                    casHead(h, s.next);     <span class="comment">// help s&#x27;s fulfiller</span></span><br><span class="line">                <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 检查头节点是否为FULFILLIING</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isFulfilling(h.mode)) &#123; <span class="comment">// try to fulfill</span></span><br><span class="line">            <span class="keyword">if</span> (h.isCancelled())            <span class="comment">// already cancelled</span></span><br><span class="line">                casHead(h, h.next);         <span class="comment">// pop and retry</span></span><br><span class="line">            <span class="comment">// 更新头节点为自己</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123;</span><br><span class="line">                <span class="comment">// 循环直到匹配成功</span></span><br><span class="line">                <span class="keyword">for</span> (;;) &#123; <span class="comment">// loop until matched or waiters disappear</span></span><br><span class="line">                    SNode m = s.next;       <span class="comment">// m is s&#x27;s match</span></span><br><span class="line">                    <span class="keyword">if</span> (m == <span class="keyword">null</span>) &#123;        <span class="comment">// all waiters are gone</span></span><br><span class="line">                        casHead(s, <span class="keyword">null</span>);   <span class="comment">// pop fulfill node</span></span><br><span class="line">                        s = <span class="keyword">null</span>;           <span class="comment">// use new node next time</span></span><br><span class="line">                        <span class="keyword">break</span>;              <span class="comment">// restart main loop</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    SNode mn = m.next;</span><br><span class="line">                    <span class="keyword">if</span> (m.tryMatch(s)) &#123;</span><br><span class="line">                        casHead(s, mn);     <span class="comment">// pop both s and m</span></span><br><span class="line">                        <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">                    &#125; <span class="keyword">else</span>                  <span class="comment">// lost match</span></span><br><span class="line">                        s.casNext(m, mn);   <span class="comment">// help unlink</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 帮助满足的结点匹配</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// help a fulfiller</span></span><br><span class="line">            SNode m = h.next;               <span class="comment">// m is h&#x27;s match</span></span><br><span class="line">            <span class="keyword">if</span> (m == <span class="keyword">null</span>)                  <span class="comment">// waiter is gone</span></span><br><span class="line">                casHead(h, <span class="keyword">null</span>);           <span class="comment">// pop fulfilling node</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                SNode mn = m.next;</span><br><span class="line">                <span class="keyword">if</span> (m.tryMatch(h))          <span class="comment">// help match</span></span><br><span class="line">                    casHead(h, mn);         <span class="comment">// pop both h and m</span></span><br><span class="line">                <span class="keyword">else</span>                        <span class="comment">// lost match</span></span><br><span class="line">                    h.casNext(m, mn);       <span class="comment">// help unlink</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 当一个结点插入到栈中，它要么能和其他结点匹配然后一起出栈，否则就需要等待一个匹配的结点到来。在等待的过程中，一般使用自旋等待代替阻塞（在多处理器环境下），因为很有可能会有相应结点到来。如果自旋结束还没有匹配，那么就设置waiter然后阻塞自己，在阻塞自己之前还会再检查至少一次是否有匹配的结点。</p>
<blockquote>
<p>如果等待的过程中由于超时到期或者中断，那么需要取消此节点，方法是将<code>match</code>字段指向自己，然后返回。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">SNode <span class="title">awaitFulfill</span><span class="params">(SNode s, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    Thread w = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> spins = shouldSpin(s)</span><br><span class="line">        ? (timed ? MAX_TIMED_SPINS : MAX_UNTIMED_SPINS)</span><br><span class="line">        : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (w.isInterrupted())</span><br><span class="line">            s.tryCancel();</span><br><span class="line">        SNode m = s.match;</span><br><span class="line">        <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                s.tryCancel();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Thread.onSpinWait();</span><br><span class="line">            spins = shouldSpin(s) ? (spins - <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>)</span><br><span class="line">            s.waiter = w; <span class="comment">// establish waiter so can park next iter</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; SPIN_FOR_TIMEOUT_THRESHOLD)</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用TransferStack即SynchronousQueue的非公平模式时，先put再take结点变化如下（注意DATA节点是插入线程构造的，而REQUEST是提取元素的线程的模式，此节点在构造时会变为FULFILLING节点，此处依然使用REQUEST以指代是take线程）：</p>
<p><img src="https://baiyp.ren/images/thread/queue/queue03.png" alt="img"></p>
<p> 如果先take再put时，插入线程则会构建一个模式为[11]的结点，而<code>11 &amp; FULFILLING != 0</code>， 所以<code>isFulfilling(h.mode)</code>方法会返回true。</p>
<p><img src="https://baiyp.ren/images/thread/queue/queue04.png" alt="img"></p>
<h5 id="清除"><a href="#清除" class="headerlink" title="清除"></a>清除</h5><blockquote>
<p>在最坏的情况我们需要遍历整个栈来删除节点s。如果有多个线程并发调用<code>clean</code>方法，我们不会知道其他线程可能已经删除了此节点。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clean</span><span class="params">(SNode s)</span> </span>&#123;</span><br><span class="line">    s.item = <span class="keyword">null</span>;   <span class="comment">// forget item</span></span><br><span class="line">    s.waiter = <span class="keyword">null</span>; <span class="comment">// forget thread</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * At worst we may need to traverse entire stack to unlink</span></span><br><span class="line"><span class="comment">     * s. If there are multiple concurrent calls to clean, we</span></span><br><span class="line"><span class="comment">     * might not see s if another thread has already removed</span></span><br><span class="line"><span class="comment">     * it. But we can stop when we see any node known to</span></span><br><span class="line"><span class="comment">     * follow s. We use s.next unless it too is cancelled, in</span></span><br><span class="line"><span class="comment">     * which case we try the node one past. We don&#x27;t check any</span></span><br><span class="line"><span class="comment">     * further because we don&#x27;t want to doubly traverse just to</span></span><br><span class="line"><span class="comment">     * find sentinel.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    SNode past = s.next;</span><br><span class="line">    <span class="keyword">if</span> (past != <span class="keyword">null</span> &amp;&amp; past.isCancelled())</span><br><span class="line">        past = past.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除头部被取消的节点</span></span><br><span class="line">    SNode p;</span><br><span class="line">    <span class="keyword">while</span> ((p = head) != <span class="keyword">null</span> &amp;&amp; p != past &amp;&amp; p.isCancelled())</span><br><span class="line">        casHead(p, p.next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除中间的节点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p != past) &#123;</span><br><span class="line">        SNode n = p.next;</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="keyword">null</span> &amp;&amp; n.isCancelled())</span><br><span class="line">            p.casNext(n, n.next);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="TransferQueue"><a href="#TransferQueue" class="headerlink" title="TransferQueue"></a>TransferQueue</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This extends Scherer-Scott dual queue algorithm, differing,</span></span><br><span class="line"><span class="comment">     * among other ways, by using modes within nodes rather than</span></span><br><span class="line"><span class="comment">     * marked pointers. The algorithm is a little simpler than</span></span><br><span class="line"><span class="comment">     * that for stacks because fulfillers do not need explicit</span></span><br><span class="line"><span class="comment">     * nodes, and matching is done by CAS&#x27;ing QNode.item field</span></span><br><span class="line"><span class="comment">     * from non-null to null (for put) or vice versa (for take).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Node class for TransferQueue. */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">QNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> QNode next;          <span class="comment">// next node in queue</span></span><br><span class="line">        <span class="keyword">volatile</span> Object item;         <span class="comment">// CAS&#x27;ed to or from null</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter;       <span class="comment">// to control park/unpark</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isData;</span><br></pre></td></tr></table></figure>

<h5 id="transfer方法"><a href="#transfer方法" class="headerlink" title="transfer方法"></a>transfer方法</h5><ol>
<li>如果队列为空或者头节点模式和自己的模式相同，尝试将自己增加到队列的等待者中，等待被满足或者被取消</li>
<li>如果队列包含了在等待的节点，并且本次调用是与之模式匹配的调用，尝试通过CAS修改等待节点item字段然后将其出队</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Basic algorithm is to loop trying to take either of</span></span><br><span class="line"><span class="comment">     * two actions:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If queue apparently empty or holding same-mode nodes,</span></span><br><span class="line"><span class="comment">     *    try to add node to queue of waiters, wait to be</span></span><br><span class="line"><span class="comment">     *    fulfilled (or cancelled) and return matching item.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If queue apparently contains waiting items, and this</span></span><br><span class="line"><span class="comment">     *    call is of complementary mode, try to fulfill by CAS&#x27;ing</span></span><br><span class="line"><span class="comment">     *    item field of waiting node and dequeuing it, and then</span></span><br><span class="line"><span class="comment">     *    returning matching item.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * In each case, along the way, check for and try to help</span></span><br><span class="line"><span class="comment">     * advance head and tail on behalf of other stalled/slow</span></span><br><span class="line"><span class="comment">     * threads.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The loop starts off with a null check guarding against</span></span><br><span class="line"><span class="comment">     * seeing uninitialized head or tail values. This never</span></span><br><span class="line"><span class="comment">     * happens in current SynchronousQueue, but could if</span></span><br><span class="line"><span class="comment">     * callers held non-volatile/final ref to the</span></span><br><span class="line"><span class="comment">     * transferer. The check is here anyway because it places</span></span><br><span class="line"><span class="comment">     * null checks at top of loop, which is usually faster</span></span><br><span class="line"><span class="comment">     * than having them implicitly interspersed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    QNode s = <span class="keyword">null</span>; <span class="comment">// constructed/reused as needed</span></span><br><span class="line">    <span class="keyword">boolean</span> isData = (e != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        QNode t = tail;</span><br><span class="line">        QNode h = head;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span> || h == <span class="keyword">null</span>)         <span class="comment">// saw uninitialized value</span></span><br><span class="line">            <span class="keyword">continue</span>;                       <span class="comment">// spin</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果队列为空或者模式与头节点相同</span></span><br><span class="line">        <span class="keyword">if</span> (h == t || t.isData == isData) &#123; <span class="comment">// empty or same-mode</span></span><br><span class="line">            QNode tn = t.next;</span><br><span class="line">            <span class="comment">// 如果有其他线程修改了tail，进入下一循环重读</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail)                  <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 如果有其他线程修改了tail，尝试cas更新尾节点，进入下一循环重读</span></span><br><span class="line">            <span class="keyword">if</span> (tn != <span class="keyword">null</span>) &#123;               <span class="comment">// lagging tail</span></span><br><span class="line">                advanceTail(t, tn);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 超时返回</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>)       <span class="comment">// can&#x27;t wait</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 构建一个新节点</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">                s = <span class="keyword">new</span> QNode(e, isData);</span><br><span class="line">            <span class="comment">// 尝试CAS设置尾节点的next字段指向自己</span></span><br><span class="line">            <span class="comment">// 如果失败，重试</span></span><br><span class="line">            <span class="keyword">if</span> (!t.casNext(<span class="keyword">null</span>, s))        <span class="comment">// failed to link in</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">      </span><br><span class="line">            <span class="comment">// cas设置当前节点为尾节点</span></span><br><span class="line">            advanceTail(t, s);              <span class="comment">// swing tail and wait</span></span><br><span class="line">            <span class="comment">// 等待匹配的节点</span></span><br><span class="line">            Object x = awaitFulfill(s, e, timed, nanos);</span><br><span class="line">            <span class="comment">// 如果被取消，删除自己，返回null</span></span><br><span class="line">            <span class="keyword">if</span> (x == s) &#123;                   <span class="comment">// wait was cancelled</span></span><br><span class="line">                clean(t, s);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果此节点没有被模式匹配的线程出队</span></span><br><span class="line">            <span class="comment">// 那么自己进行出队操作</span></span><br><span class="line">            <span class="keyword">if</span> (!s.isOffList()) &#123;           <span class="comment">// not already unlinked</span></span><br><span class="line">                advanceHead(t, s);          <span class="comment">// unlink if head</span></span><br><span class="line">                <span class="keyword">if</span> (x != <span class="keyword">null</span>)              <span class="comment">// and forget fields</span></span><br><span class="line">                    s.item = s;</span><br><span class="line">                s.waiter = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// complementary-mode</span></span><br><span class="line">            QNode m = h.next;               <span class="comment">// node to fulfill</span></span><br><span class="line">            <span class="comment">// 数据不一致，重读</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail || m == <span class="keyword">null</span> || h != head)</span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// inconsistent read</span></span><br><span class="line"></span><br><span class="line">            Object x = m.item;</span><br><span class="line">            <span class="keyword">if</span> (isData == (x != <span class="keyword">null</span>) ||    <span class="comment">// m already fulfilled     m已经匹配成功了</span></span><br><span class="line">                x == m ||                   <span class="comment">// m cancelled             m被取消了</span></span><br><span class="line">                !m.casItem(x, e)) &#123;         <span class="comment">// lost CAS                CAS竞争失败</span></span><br><span class="line">                <span class="comment">// 上面三个条件无论哪一个满足，都证明m已经失效无用了，</span></span><br><span class="line">                <span class="comment">// 需要将其出队</span></span><br><span class="line">                advanceHead(h, m);          <span class="comment">// dequeue and retry</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 成功匹配，依然需要将节点出队</span></span><br><span class="line">            advanceHead(h, m);              <span class="comment">// successfully fulfilled</span></span><br><span class="line">            <span class="comment">// 唤醒匹配节点，如果它被阻塞了</span></span><br><span class="line">            LockSupport.unpark(m.waiter);</span><br><span class="line">            <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">awaitFulfill</span><span class="params">(QNode s, E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Same idea as TransferStack.awaitFulfill */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    Thread w = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> spins = (head.next == s)</span><br><span class="line">        ? (timed ? MAX_TIMED_SPINS : MAX_UNTIMED_SPINS)</span><br><span class="line">        : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (w.isInterrupted())</span><br><span class="line">            s.tryCancel(e);</span><br><span class="line">        Object x = s.item;</span><br><span class="line">        <span class="comment">// item被修改后返回</span></span><br><span class="line">        <span class="comment">// 如果put操作在此等待，item会被更新为null</span></span><br><span class="line">        <span class="comment">// 如果take操作再次等待，item会由null变为一个值</span></span><br><span class="line">        <span class="keyword">if</span> (x != e)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                s.tryCancel(e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            --spins;</span><br><span class="line">            Thread.onSpinWait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>)</span><br><span class="line">            s.waiter = w;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; SPIN_FOR_TIMEOUT_THRESHOLD)</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用TransferQueue即公平模式插入节点，队列的变化如下：</p>
</blockquote>
<p><img src="https://baiyp.ren/images/thread/queue/queue05.png" alt="img"></p>
<p><img src="https://baiyp.ren/images/thread/queue/queue06.png" alt="img"></p>
<p>注意匹配的时候item的变化。</p>
<h5 id="public-operations"><a href="#public-operations" class="headerlink" title="public operations"></a>public operations</h5><blockquote>
<p><code>SynchronousQueue</code>类的公共操作都是依赖于<code>transfer</code>方法完成的，注意不同的方法调用<code>transfer</code>方法时提供的参数。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (transferer.transfer(e, <span class="keyword">false</span>, <span class="number">0</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Thread.interrupted();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (transferer.transfer(e, <span class="keyword">true</span>, unit.toNanos(timeout)) != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Thread.interrupted())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> transferer.transfer(e, <span class="keyword">true</span>, <span class="number">0</span>) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E e = transferer.transfer(<span class="keyword">null</span>, <span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    Thread.interrupted();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E e = transferer.transfer(<span class="keyword">null</span>, <span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> || !Thread.interrupted())</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> transferer.transfer(<span class="keyword">null</span>, <span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="核心要点-5"><a href="#核心要点-5" class="headerlink" title="核心要点"></a>核心要点</h5><ol>
<li>可以指定锁的公平性</li>
<li>队列内部不会存储元素，所以尽量避免使用<code>add</code>,<code>offer</code>此类立即返回的方法，除非有特殊需求</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小肥龙吃大冰淇淋</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lvxueyangtiger.github.io/post/62592dd9.html">https://lvxueyangtiger.github.io/post/62592dd9.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lvxueyangtiger.github.io" target="_blank">小肥龙吃大冰淇淋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%98%9F%E5%88%97/">队列</a></div><div class="post_share"><div class="social-share" data-image="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212100.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/10d00669.html"><img class="prev-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212050.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JAVA阻塞队列实现</div></div></a></div><div class="next-post pull-right"><a href="/post/f0cc69d3.html"><img class="next-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212120.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">java中的读写锁</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-%E9%98%9F%E5%88%97"><span class="toc-number">1.</span> <span class="toc-text">java并发工具类-队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockingQueue"><span class="toc-number">1.1.</span> <span class="toc-text">BlockingQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%A1%8C%E4%B8%BA"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">方法行为</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">1.1.2.1.1.</span> <span class="toc-text">抛出异常</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%80%BC"><span class="toc-number">1.1.2.1.2.</span> <span class="toc-text">特殊值</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E"><span class="toc-number">1.1.2.1.3.</span> <span class="toc-text">阻塞</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%B6%85%E6%97%B6"><span class="toc-number">1.1.2.1.4.</span> <span class="toc-text">超时</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.1.3.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#BlockingQueueExample"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">BlockingQueueExample</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Producer"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">Producer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Consumer"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">Consumer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockingDeque"><span class="toc-number">1.2.</span> <span class="toc-text">BlockingDeque</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%B3%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E8%87%AA-BlockingQueue"><span class="toc-number">1.2.3.</span> <span class="toc-text">继承自 BlockingQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">1.2.4.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayBlockingQueue"><span class="toc-number">1.3.</span> <span class="toc-text">ArrayBlockingQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">1.3.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81"><span class="toc-number">1.3.2.</span> <span class="toc-text">源码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">增加操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">删除操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">访问操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.2.6.</span> <span class="toc-text">辅助方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9"><span class="toc-number">1.3.2.7.</span> <span class="toc-text">核心要点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DelayQueue"><span class="toc-number">1.4.</span> <span class="toc-text">DelayQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">1.4.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81-1"><span class="toc-number">1.4.2.</span> <span class="toc-text">源码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">整体介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-1"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E6%93%8D%E4%BD%9C-1"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">增加操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-1"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">删除操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C-1"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">访问操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.2.6.</span> <span class="toc-text">其他操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.4.2.7.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9-1"><span class="toc-number">1.4.2.8.</span> <span class="toc-text">核心要点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedBlockingQueue"><span class="toc-number">1.5.</span> <span class="toc-text">LinkedBlockingQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="toc-number">1.5.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81-2"><span class="toc-number">1.5.2.</span> <span class="toc-text">源码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">整体介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E6%93%8D%E4%BD%9C-2"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">增加操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-2"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">删除操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C-2"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">访问操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C-1"><span class="toc-number">1.5.2.5.</span> <span class="toc-text">其他操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-1"><span class="toc-number">1.5.2.6.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9-2"><span class="toc-number">1.5.2.7.</span> <span class="toc-text">核心要点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PriorityBlockingQueue"><span class="toc-number">1.6.</span> <span class="toc-text">PriorityBlockingQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-5"><span class="toc-number">1.6.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81-3"><span class="toc-number">1.6.2.</span> <span class="toc-text">源码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-1"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E6%93%8D%E4%BD%9C-3"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">增加操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-3"><span class="toc-number">1.6.2.4.</span> <span class="toc-text">删除操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C-3"><span class="toc-number">1.6.2.5.</span> <span class="toc-text">访问操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-2"><span class="toc-number">1.6.2.6.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9-3"><span class="toc-number">1.6.2.7.</span> <span class="toc-text">核心要点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedBlockingDeque"><span class="toc-number">1.7.</span> <span class="toc-text">LinkedBlockingDeque</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-6"><span class="toc-number">1.7.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81-4"><span class="toc-number">1.7.2.</span> <span class="toc-text">源码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">整体介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E6%93%8D%E4%BD%9C-4"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">增加操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-4"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">删除操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C-4"><span class="toc-number">1.7.2.4.</span> <span class="toc-text">访问操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BlockingQueue-%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.2.5.</span> <span class="toc-text">BlockingQueue 方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9-4"><span class="toc-number">1.7.2.6.</span> <span class="toc-text">核心要点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SynchronousQueue"><span class="toc-number">1.8.</span> <span class="toc-text">SynchronousQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81-5"><span class="toc-number">1.8.1.</span> <span class="toc-text">源码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TransferStack"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">TransferStack</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95-transfer"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">核心算法 transfer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B8%85%E9%99%A4"><span class="toc-number">1.8.1.3.</span> <span class="toc-text">清除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TransferQueue"><span class="toc-number">1.8.1.4.</span> <span class="toc-text">TransferQueue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#transfer%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.1.5.</span> <span class="toc-text">transfer方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-operations"><span class="toc-number">1.8.1.6.</span> <span class="toc-text">public operations</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9-5"><span class="toc-number">1.8.1.7.</span> <span class="toc-text">核心要点</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 小肥龙吃大冰淇淋</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="framework-info"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202301132049386.png"/><span> </span><a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">晋ICP备2022012091号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'pinglun-9gh2lmcnd8587831',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'pinglun-9gh2lmcnd8587831',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@latest/source/js/issues.min.js"></script><script src="//code.tidio.co/smwivpnwumemac2wohardi3d3gpud1ag.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>