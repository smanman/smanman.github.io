<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JAVA零拷贝 | 小肥龙吃大冰淇淋</title><meta name="keywords" content="零拷贝"><meta name="author" content="小肥龙吃大冰淇淋"><meta name="copyright" content="小肥龙吃大冰淇淋"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JAVA-零拷贝 引言 传统的 Linux 操作系统的标准 I&#x2F;O 接口是基于数据拷贝操作的，即 I&#x2F;O 操作会导致数据在操作系统内核地址空间的缓冲区和应用程序地址空间定义的缓冲区之间进行传输。这样做最大的好处是可以减少磁盘 I&#x2F;O 的操作，因为如果所请求的数据已经存放在操作系统的高速缓冲存储器中，那么就不需要再进行实际的物理磁盘 I&#x2F;O 操作。但是数据传输过程中的数据拷贝操作却导致了极大的 CP">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA零拷贝">
<meta property="og:url" content="https://andice-cream.github.io/post/4aa1de86.html">
<meta property="og:site_name" content="小肥龙吃大冰淇淋">
<meta property="og:description" content="JAVA-零拷贝 引言 传统的 Linux 操作系统的标准 I&#x2F;O 接口是基于数据拷贝操作的，即 I&#x2F;O 操作会导致数据在操作系统内核地址空间的缓冲区和应用程序地址空间定义的缓冲区之间进行传输。这样做最大的好处是可以减少磁盘 I&#x2F;O 的操作，因为如果所请求的数据已经存放在操作系统的高速缓冲存储器中，那么就不需要再进行实际的物理磁盘 I&#x2F;O 操作。但是数据传输过程中的数据拷贝操作却导致了极大的 CP">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082137.jpg">
<meta property="article:published_time" content="2024-05-30T01:10:36.245Z">
<meta property="article:modified_time" content="2022-11-27T09:16:33.965Z">
<meta property="article:author" content="小肥龙吃大冰淇淋">
<meta property="article:tag" content="零拷贝">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082137.jpg"><link rel="shortcut icon" href="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210805191028.png"><link rel="canonical" href="https://andice-cream.github.io/post/4aa1de86"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JAVA零拷贝',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-27 17:16:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/ali_icon.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mogai.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="小肥龙吃大冰淇淋" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">178</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">73</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">40</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082137.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小肥龙吃大冰淇淋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JAVA零拷贝</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-30T01:10:36.245Z" title="发表于 2024-05-30 09:10:36">2024-05-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-27T09:16:33.965Z" title="更新于 2022-11-27 17:16:33">2022-11-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JAVA/">JAVA</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JAVA/%E5%8E%9F%E7%90%86/">原理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>19分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JAVA零拷贝"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="JAVA-零拷贝"><a href="#JAVA-零拷贝" class="headerlink" title="JAVA-零拷贝"></a>JAVA-零拷贝</h2><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203101023928.png" alt="img"></p>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p> 传统的 Linux 操作系统的标准 I/O 接口是基于数据拷贝操作的，即 I/O 操作会导致数据在操作系统内核地址空间的缓冲区和应用程序地址空间定义的缓冲区之间进行传输。这样做最大的好处是可以减少磁盘 I/O 的操作，因为如果所请求的数据已经存放在操作系统的高速缓冲存储器中，那么就不需要再进行实际的物理磁盘 I/O 操作。但是数据传输过程中的数据拷贝操作却导致了极大的 CPU 开销，限制了操作系统有效进行数据传输操作的能力。<br>​ 零拷贝（ zero-copy ）技术可以有效地改善数据传输的性能，在内核驱动程序（比如网络堆栈或者磁盘存储驱动程序）处理 I/O 数据的时候，零拷贝技术可以在某种程度上减少甚至完全避免不必要 CPU 数据拷贝操作。</p>
<h3 id="什么是零拷贝"><a href="#什么是零拷贝" class="headerlink" title="什么是零拷贝"></a>什么是零拷贝</h3><p> 零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。针对操作系统中的设备驱动程序、文件系统以及网络协议堆栈而出现的各种零拷贝技术极大地提升了特定应用程序的性能，并且使得这些应用程序可以更加有效地利用系统资源。这种性能的提升就是通过在数据拷贝进行的同时，允许 CPU 执行其他的任务来实现的。<br>​ 零拷贝技术可以减少数据拷贝和共享总线操作的次数，消除传输数据在存储器之间不必要的中间拷贝次数，从而有效地提高数据传输效率。而且，零拷贝技术减少了用户应用程序地址空间和操作系统内核地址空间之间因为上下文切换而带来的开销。进行大量的数据拷贝操作其实是一件简单的任务，从操作系统的角度来说，如果 CPU 一直被占用着去执行这项简单的任务，那么这将会是很浪费资源的；如果有其他比较简单的系统部件可以代劳这件事情，从而使得 CPU 解脱出来可以做别的事情，那么系统资源的利用则会更加有效。</p>
<h4 id="避免数据拷贝"><a href="#避免数据拷贝" class="headerlink" title="避免数据拷贝"></a>避免数据拷贝</h4><blockquote>
<p>综上所述，零拷贝技术的目标可以概括如下：</p>
</blockquote>
<ol>
<li>避免操作系统内核缓冲区之间进行数据拷贝操作。</li>
<li>避免操作系统内核和用户应用程序地址空间这两者之间进行数据拷贝操作。</li>
<li>用户应用程序可以避开操作系统直接访问硬件存储。</li>
<li>数据传输尽量让 DMA 来做。</li>
</ol>
<h4 id="将多种操作结合在一起"><a href="#将多种操作结合在一起" class="headerlink" title="将多种操作结合在一起"></a>将多种操作结合在一起</h4><ol>
<li>避免不必要的系统调用和上下文切换。</li>
<li>需要拷贝的数据可以先被缓存起来。</li>
<li>对数据进行处理尽量让硬件来做。</li>
</ol>
<h4 id="零拷贝给我们带来的好处"><a href="#零拷贝给我们带来的好处" class="headerlink" title="零拷贝给我们带来的好处"></a>零拷贝给我们带来的好处</h4><ol>
<li>减少甚至完全避免不必要的CPU拷贝，从而让CPU解脱出来去执行其他的任务。</li>
<li>减少内存带宽的占用。</li>
<li>通常零拷贝技术还能够减少用户空间和操作系统内核空间之间的上下文切换。</li>
</ol>
<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><h4 id="关于I-O内存映射"><a href="#关于I-O内存映射" class="headerlink" title="关于I/O内存映射"></a>关于I/O内存映射</h4><p> 设备通过控制总线，数据总线，状态总线与CPU相连。控制总数传送控制信号。在传统的操作中，都是通过读写设备寄存器的值来实现。但是这样耗费了CPU时钟。而且每取一次值都要读取设备寄存器，造成了效率的低下。在现代操作系统中。引用了I/O内存映射。即把寄存器的值映身到主存。对设备寄存器的操作，转换为对主存的操作，这样极大的提高了效率。</p>
<h4 id="CPU-COPY"><a href="#CPU-COPY" class="headerlink" title="CPU COPY"></a>CPU COPY</h4><p>通过计算机的组成原理我们知道, 内存的读写操作是需要CPU的协调数据总线,地址总线和控制总线来完成的，因此在”拷贝”发生的时候,往往需要CPU暂停现有的处理逻辑,来协助内存的读写.这种我们称为CPU COPY，cpu copy不但占用了CPU资源,还占用了总线的带宽。</p>
<h4 id="DMA-COPY"><a href="#DMA-COPY" class="headerlink" title="DMA COPY"></a>DMA COPY</h4><p> DMA(DIRECT MEMORY ACCESS，直接内存存取)是现代计算机的重要功能，</p>
<p> 它允许不同速度的硬件装置来沟通，而不需要依赖于CPU的大量中断负载。否则，CPU需要从来源把每一片段的资料复制到暂存器，然后把它们再次写回到新的地方。在这个时间中，CPU对于其他的工作来说就无法使用</p>
<p> 它的一个重要 的特点就是, 当需要与外设进行数据交换时, CPU只需要初始化这个动作便可以继续执行其他指令,剩下的数据传输的动作完全由DMA来完成，可以看到DMA COPY是可以避免大量的CPU中断的</p>
<h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p> 本文中的上下文切换时指由用户态切换到内核态, 以及由内核态切换到用户态</p>
<h4 id="存在多次拷贝的原因"><a href="#存在多次拷贝的原因" class="headerlink" title="存在多次拷贝的原因"></a>存在多次拷贝的原因</h4><ol>
<li>操作系统为了保护系统不被应用程序有意或无意地破坏,为操作系统设置了用户态和内核态两种状态.用户态想要获取系统资源(例如访问硬盘), 必须通过系统调用进入到内核态, 由内核态获取到系统资源,再切换回用户态返回应用程序.</li>
<li>出于”readahead cache”和异步写入等等性能优化的需要, 操作系统在内核态中也增加了一个”内核缓冲区”(kernel buffer). 读取数据时并不是直接把数据读取到应用程序的buffer, 而先读取到kernel buffer, 再由kernel buffer复制到应用程序的buffer. 因此,数据在被应用程序使用之前,可能需要被多次拷贝</li>
</ol>
<h3 id="传统读操作"><a href="#传统读操作" class="headerlink" title="传统读操作"></a>传统读操作</h3><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203101030949.png" alt="img"></p>
<p><strong>JAVA用传统方式进行读操作时</strong>，<strong>整体流程</strong>如上图，具体如下：</p>
<ol>
<li>应用程序发起读数据操作，JVM会发起read()系统调用。</li>
<li>这时操作系统OS会进行<strong>一次上下文切换</strong>（把用户空间切换到内核空间）</li>
<li>通过<strong>磁盘控制器把数据copy到内核缓冲区</strong>中，这里的就发生了<strong>一次DMA Copy</strong></li>
<li>然后内核将<strong>数据copy到用户空间的应用缓冲区</strong>中，<strong>发生了一次CPU Copy</strong></li>
<li>read调用返回后，会<strong>再进行一次上下文切换</strong>（把内核空间切换到用户空间）</li>
</ol>
<p>我们看一下一个<strong>读操作</strong>，发了<strong>2次上下文切换，和2次数据copy</strong>，一次是DMA Copy，一次是CPU Copy。</p>
<blockquote>
<p>注意一点的是 内核从磁盘上面读取数据 是 <strong>不消耗CPU时间</strong>的，是通过磁盘控制器完成；称之为DMA Copy。</p>
</blockquote>
<h3 id="传统写操作"><a href="#传统写操作" class="headerlink" title="传统写操作"></a>传统写操作</h3><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203101033784.png" alt="img"></p>
<p>上图是JAVA传统的写操作，具体流程：</p>
<p>1、应用发起写操作，OS进行<strong>一次上下文切换</strong>（从用户空间切换为内核空间）</p>
<p>2、并且把数据copy到内核缓冲区Socket Buffer，<strong>做了一次CPU Copy</strong></p>
<p>3、内核空间再把数据copy到磁盘或其他存储（网卡，进行网络传输），<strong>进行了DMA Copy</strong></p>
<p>4、写入结束后返回，又从<strong>内核空间切换到用户空间</strong></p>
<h4 id="实际场景"><a href="#实际场景" class="headerlink" title="实际场景"></a>实际场景</h4><blockquote>
<p>回想现实世界的所有系统中, 不管是web应用服务器, ftp服务器,数据库服务器, 静态文件服务器等等, 所有涉及到数据传输的场景, 无非就一种:从硬盘上读取文件数据, 发送到网络上去。</p>
</blockquote>
<p>这个场景我们简化为一个模型:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File.read(fileDesc, buf, len);</span><br><span class="line">Socket.send(socket, buf, len);</span><br></pre></td></tr></table></figure>

<p>操作系统在实现这个模型时,需要有以下步骤:</p>
<ol>
<li>应用程序开始读文件的操作</li>
<li>应用程序发起系统调用, 从用户态切换到内核态(第一次上下文切换)</li>
<li>内核态中把数据从硬盘文件读取到内核中间缓冲区(kernel buf)</li>
<li>数据从内核中间缓冲区(kernel buf)复制到(用户态)应用程序缓冲区(app buf),从内核态切换回到用户态(第二次上下文切换)</li>
<li>应用程序开始发送数据到网络上</li>
<li>应用程序发起系统调用,从用户态切换到内核态(第三次上下文切换)</li>
<li>内核中把数据从应用程序(app buf)的缓冲区复制到socket的缓冲区(socket)</li>
<li>内核中再把数据从socket的缓冲区(socket buf)发送的网卡的缓冲区(NIC buf)上</li>
<li>从内核态切换回到用户态(第四次上下文切换)</li>
</ol>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203101033242.png" alt="img"></p>
<p>由上图可以很清晰地看到, 涉及到了四次拷贝:</p>
<ol>
<li>硬盘拷贝到内核缓冲区(DMA COPY)</li>
<li>内核缓冲区拷贝到应用程序缓冲区(CPU COPY)</li>
<li>应用程序缓冲区拷贝到socket缓冲区(CPU COPY)</li>
<li>socket buf拷贝到网卡的buf(DMA COPY)</li>
</ol>
<p>其中涉及到2次cpu中断, 还有4次的上下文切换</p>
<p> 很明显,第2次和第3次的的copy只是把数据复制到app buffer又原封不动的复制回来, 为此带来了两次的cpu copy和两次上下文切换, 是完全没有必要的</p>
<p> linux的零拷贝技术就是为了优化掉这两次不必要的拷贝</p>
<h3 id="传统IO"><a href="#传统IO" class="headerlink" title="传统IO"></a>传统IO</h3><p> 我们可以看出<strong>传统的IO读写操作</strong>，总共进行了<strong>4次上下文切换，4次Copy动作</strong>。我们可以看到<strong>数据在内核空间和应用空间之间来回复制</strong>，其实他们什么都没有做，就是复制而已，这个机制太浪费时间了，而且是<strong>浪费的CPU的时间</strong>。</p>
<p> 那我们能不能让数据不要来回复制呢？<strong>零拷贝这个技术就是来解决这个问题</strong>。关于零拷贝提供了两种解决方式：<strong>mmap+write方式、sendfile方式</strong></p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><blockquote>
<p>所有现代操作系统都使用虚拟内存，使用<strong>虚拟地址取代物理地址</strong>，这样做的好处就是：</p>
</blockquote>
<ol>
<li>多个虚拟内存可以指向同一个物理地址</li>
<li>虚拟内存空间可以远远大于物理内存空间</li>
</ol>
<p>我们利用<strong>第一条特性可以优化一下上面的设计思路</strong>，就是把<strong>内核空间和用户空间的虚拟地址映射到同一个物理地址</strong>，这样就不需要来回复制了，看图：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203101035122.png" alt="img"></p>
<h3 id="mmap-write方式"><a href="#mmap-write方式" class="headerlink" title="mmap+write方式"></a>mmap+write方式</h3><blockquote>
<p>使用mmap+write方式替换原来的传统IO方式，就是利用了虚拟内存的特性，看图</p>
</blockquote>
<p><img src="https://baiyp.ren/images/network/zerocopy/zerocopy04.png" alt="img"></p>
<p>整体流程的核心区别就是，把数据读取到内核缓冲区后，应用程序进行写入操作时，直接是把<strong>内核的Read Buffer的数据 复制到 Socket Buffer 以便进行写入，这次内核之间的复制也是需要CPU参与的</strong>。</p>
<blockquote>
<p>注意：最后把Socket Buffer数据拷贝到很多地方，统称protocol engine（协议引擎）</p>
</blockquote>
<p>这个流程就<strong>少了一个CPU Copy</strong>，提升了IO的速度。不过发现<strong>上下文的切换还是4次</strong>，没有减少，因为还是要<strong>应用程序发起write操作</strong>。那能不能减少上下文切换呢？</p>
<h3 id="sendfile方式"><a href="#sendfile方式" class="headerlink" title="sendfile方式"></a>sendfile方式</h3><p> 为了简化用户接口，同时还要继续保留 mmap()/write() 技术的优点：减少 CPU 的复制次数，Linux 在版本 2.1 中引入了 sendfile() 这个系统调用。</p>
<blockquote>
<p>这种方式可以替换上面的mmap+write方式，如：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mmap();</span><br><span class="line">write();</span><br></pre></td></tr></table></figure>

<p>替换为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sendfile();</span><br></pre></td></tr></table></figure>

<p>这样就减少了一次上下文切换，因为少了一个应用程序发起write操作，直接发起sendfile操作。</p>
<p>到这里就<strong>只有3次Copy，其中只有1次CPU Copy；3次上下文切换</strong>。那能不能把CPU Copy减少到没有呢？</p>
<h4 id="实际场景-1"><a href="#实际场景-1" class="headerlink" title="实际场景"></a>实际场景</h4><p>有了sendFile这个系统调用后, 我们read-send模型就可以简化为:</p>
<ol>
<li>应用程序开始读文件的操作</li>
<li>应用程序发起系统调用, 从用户态切换到内核态(第一次上下文切换)</li>
<li>内核态中把数据从硬盘文件读取到内核中间缓冲区</li>
<li>通过sendFile,在内核态中把数据从内核缓冲区复制到socket的缓冲区</li>
<li>内核中再把数据从socket的缓冲区发送的网卡的buf上</li>
<li>从内核态切换到用户态(第二次上下文切换)</li>
</ol>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203101049319.png" alt="img"></p>
<p>涉及到数据拷贝变成:</p>
<ol>
<li>硬盘拷贝到内核缓冲区(DMA COPY)</li>
<li>内核缓冲区拷贝到socket缓冲区(CPU COPY)</li>
<li>socket缓冲区拷贝到网卡的buf(DMA COPY)</li>
</ol>
<p>可以看到,一次read-send模型中, 利用sendFile系统调用后, 可以将4次数据拷贝减少到3次, 4次上下文切换减少到2次, 2次CPU中断减少到1次</p>
<p> 相对传统I/O, 这种零拷贝技术通过减少两次上下文切换, 1次cpu copy, 可以将I/O性能提高50%以上(网络数据, 未亲测)</p>
<p> 开始的术语中说到, 所谓的零拷贝的”零”, 是指用户态和内核态之间的拷贝次数为0, 从这个定义上来说, 现在的这个零拷贝技术已经是真正的”零”了</p>
<p> 然而, 对性能追求极致的伟大的科学家和工程师们并不满足于此. 精益求精的他们对中间第2次的cpu copy依旧耿耿于怀, 想尽千方百计要去掉这一次没有必要的数据拷贝和CPU中断</p>
<h3 id="scatter-gather特性的sendFile"><a href="#scatter-gather特性的sendFile" class="headerlink" title="scatter-gather特性的sendFile"></a>scatter-gather特性的sendFile</h3><p> Linux2.4内核进行了优化，<strong>提供了gather操作</strong>，这个操作可以把<strong>最后一次CPU Copy去除</strong>，什么原理呢？就是在内核空间Read Buffer和Socket Buffer不做数据复制，<strong>而是将Read Buffer的内存地址、偏移量记录到相应的Socket Buffer中</strong>，这样就不需要复制（<strong>其实本质就是和虚拟内存的解决方法思路一样，就是内存地址的记录</strong>），如图：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203101023372.png" alt="img"></p>
<h4 id="实际场景-2"><a href="#实际场景-2" class="headerlink" title="实际场景"></a>实际场景</h4><blockquote>
<p>这个优化后的sendFile, 我们称之为支持scatter-gather特性的sendFile</p>
</blockquote>
<p>在支持scatter-gather特性的sendFile的支撑下, 我们的模型可以优化为:</p>
<ol>
<li>应用程序开始读文件的操作</li>
<li>应用程序发起系统调用, 从用户态进入到内核态(第一次上下文切换)</li>
<li>内核态中把数据从硬盘文件读取到内核中间缓冲区</li>
<li>内核态中把数据在内核缓冲区的位置(offset)和数据大小(size)两个信息追加(append)到socket的缓冲区中去</li>
<li>网卡的buf上根据socekt缓冲区的offset和size从内核缓冲区中直接拷贝数据</li>
<li>从内核态返回到用户态(第二次上下文切换)</li>
</ol>
<p>这个过程如下图所示:</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203101023383.png" alt="img"></p>
<p>最后数据拷贝变成只有两次DMA COPY:</p>
<ol>
<li>硬盘拷贝到内核缓冲区(DMA COPY)</li>
<li>内核缓冲区拷贝到网卡的buf(DMA COPY)</li>
</ol>
<h3 id="JAVA零拷贝"><a href="#JAVA零拷贝" class="headerlink" title="JAVA零拷贝"></a>JAVA零拷贝</h3><h4 id="MappedByteBuffer"><a href="#MappedByteBuffer" class="headerlink" title="MappedByteBuffer"></a>MappedByteBuffer</h4><blockquote>
<p>MappedByteBuffer是一种效率低于零拷贝，但高于传统IO的IO操作。</p>
</blockquote>
<p> 算是一种弥补transferTo零拷贝时无法中间处理源数据的手段。不过如果要中间处理数据的话，效率就会变得比零拷贝低，如果不在java程序内做中间处理，效率其实和零拷贝差不多。</p>
<p> 其实MappedByteBuffer是抽象类，而具体实现是DirectByteBuffer和DirectByteBufferR，并且是DirectBuffer的实现。也就是说，MappedByteBuffer其实用的也是堆外内存。只不过暂时现在我只知道MappedByteBuffer只能对文件进行映射。把该文件指定偏移量范围的数据与堆外内存的偏移量一一对应（但数据并不会在创建MappedByteBuffer对象的时候立即加载到内存中）</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><ol>
<li>在get数据时，如果缓冲区中没有数据，则会去磁盘获取文件数据（并且预读一部分数据（page cache页缓存。不纠结这个）），然后放到该缓冲区中（MappedByteBuffer）。</li>
<li>如果put数据，则会先把数据放到该MappedByteBuffer对应的偏移量位置（操作系统会自己找时机动态把数据按索引对应关系刷回磁盘）</li>
<li>如果java程序需要处理这部分数据，可以通过get方法把数据读到jvm内存中（获取出来复制给字节数组或者变量），处理过这些数据之后，把结果再put回该缓冲区（如果不做这一步操作，其实MappedByteBuffer与transferTo是一样的，最多就是多创建几个MappedByteBuffer的java对象而已，其他的堆外内存是基本一样的）</li>
<li>然后再把MappedByteBuffer的数据写到其他通道（如：SocketChannel、FileChannel），这些通道对应的操作目标此时就像零拷贝的过程一样，把MappedByteBuffer直接复制到操作目标的DirectBuffer缓冲区中。</li>
</ol>
<h5 id="三种方式"><a href="#三种方式" class="headerlink" title="三种方式"></a>三种方式</h5><p> FileChannel提供了map方法来把文件影射为内存映像文件： MappedByteBuffer map(int mode,long position,long size); 可以把文件的从position开始的size大小的区域映射为内存映像文件，mode指出了 可访问该内存映像文件的方式：READ_ONLY,READ_WRITE,PRIVATE。</p>
<ul>
<li><strong>READ_ONLY</strong>（只读）： 试图修改得到的缓冲区将导致抛出 ReadOnlyBufferException.(MapMode.READ_ONLY)</li>
<li><strong>READ_WRITE</strong>（读/写）： 对得到的缓冲区的更改最终将传播到文件；该更改对映射到同一文件的其他程序不一定是可见的。 (MapMode.READ_WRITE)</li>
<li><strong>PRIVATE</strong>（专用）： 对得到的缓冲区的更改不会传播到文件，并且该更改对映射到同一文件的其他程序也不是可见的；相反，会创建缓冲区已 修改部分的专用副本。 (MapMode.PRIVATE)</li>
</ul>
<h5 id="三个方法"><a href="#三个方法" class="headerlink" title="三个方法"></a>三个方法</h5><ul>
<li>**fore()**：缓冲区是READ_WRITE模式下，此方法对缓冲区内容的修改强行写入文件</li>
<li>**load()**：将缓冲区的内容载入内存，并返回该缓冲区的引用</li>
<li>**isLoaded()**：如果缓冲区的内容在物理内存中，则返回真，否则返回假</li>
</ul>
<h5 id="三个特性"><a href="#三个特性" class="headerlink" title="三个特性"></a>三个特性</h5><blockquote>
<p>调用信道的map()方法后，即可将文件的某一部分或全部映射到内存中，映射内存缓冲区是个直接缓冲区，继承自ByteBuffer,但相对于ByteBuffer,它有更多的优点：</p>
</blockquote>
<ul>
<li>读取快</li>
<li>写入快</li>
<li>随时随地写入</li>
</ul>
<h5 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mapMemeryBuffer</span><span class="params">(<span class="keyword">boolean</span> isZeroCopy)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//对内缓存进行分配空间</span></span><br><span class="line">    ByteBuffer byteBuf = ByteBuffer.allocate(<span class="number">1024</span> * <span class="number">14</span> * <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">//设置写缓存带下</span></span><br><span class="line">    <span class="keyword">byte</span>[] bbb = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">14</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;e://迅雷下载//ideaIU-2019.3.exe&quot;</span>);</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;e://tmp//outFile.txt&quot;</span>);</span><br><span class="line">    FileChannel fc = fis.getChannel();</span><br><span class="line">    <span class="keyword">long</span> timeStar = System.currentTimeMillis();<span class="comment">// 得到当前的时间</span></span><br><span class="line">    MappedByteBuffer mbb = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isZeroCopy) &#123;</span><br><span class="line">        <span class="comment">//使用零拷贝进行读取</span></span><br><span class="line">        mbb = fc.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, fc.size());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//普通方式进行读取</span></span><br><span class="line">        fc.read(byteBuf);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(fc.size() / <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">long</span> timeEnd = System.currentTimeMillis();<span class="comment">// 得到当前的时间</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Read time :&quot;</span> + (timeEnd - timeStar) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    timeStar = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (isZeroCopy) &#123;</span><br><span class="line">        <span class="comment">//零拷贝方式写入</span></span><br><span class="line">        mbb.flip();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//普通方式写入</span></span><br><span class="line">        fos.write(bbb);</span><br><span class="line">    &#125;</span><br><span class="line">    timeEnd = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;Write time :&quot;</span> + (timeEnd - timeStar) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    fos.flush();</span><br><span class="line">    fc.close();</span><br><span class="line">    fis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;---------使用零拷贝--------------&quot;</span>);</span><br><span class="line">mapMemeryBuffer(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;---------不使用零拷贝--------------&quot;</span>);</span><br><span class="line">mapMemeryBuffer(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">---------使用零拷贝--------------</span><br><span class="line"><span class="number">673399</span></span><br><span class="line">Read time :2ms</span><br><span class="line">Write time :0ms</span><br><span class="line">---------不使用零拷贝--------------</span><br><span class="line"><span class="number">673399</span></span><br><span class="line">Read time :17ms</span><br><span class="line">Write time :15ms</span><br></pre></td></tr></table></figure>

<p> 可以看出速度有了很大的提升。MappedByteBuffer的确快，但也存在一些问题，主要就是内存占用和文件关闭等不确定问题。被MappedByteBuffer打开的文件只有在垃圾收集时才会被关闭，而这个点是不确定的。在javadoc里是这么说的：</p>
<blockquote>
<p>A mapped byte buffer and the file mapping that it represents remain valid until the buffer itself is garbage-collected.</p>
</blockquote>
<p>这里提供一种解决方案：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction() &#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       Method getCleanerMethod = buffer.getClass().getMethod(<span class="string">&quot;cleaner&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">       getCleanerMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       sun.misc.Cleaner cleaner = (sun.misc.Cleaner) </span><br><span class="line">       getCleanerMethod.invoke(byteBuffer, <span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">       cleaner.clean();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="transgerTo"><a href="#transgerTo" class="headerlink" title="transgerTo"></a>transgerTo</h4><blockquote>
<p>使用<code>transgerTo()</code>方法时涉及的步骤包括以下两步：</p>
</blockquote>
<ol>
<li><code>transgerTo</code>方法调用触发DMA引擎将文件上下文信息拷贝到内核读缓冲区，接着内核将数据从内核缓冲区拷贝到与外出套接字相关联的缓冲区。</li>
<li>DMA引擎将数据从内核套接字缓冲区传输到协议引擎（第三次数据拷贝）</li>
</ol>
<p>这是一个改进：上下文切换的次数从4次减少到2次，数据拷贝的次数从4次减少到3次（仅有一次数据拷贝消耗CPU资源）。然而，这并没有实现零拷贝的目标，如果底层网卡支持<em>gather operations</em>，可以进一步减少内核拷贝数据的次数。Linux 内核 从2.4 版本开始修改了套接字缓冲区描述符以满足这个要求。这种方法不仅减少了多个上下文切换，还消除了消耗CPU的重复数据拷贝。用户使用的方法没有任何变化，依然通过<code>transferTo</code>方法，但是方法的内部实现</p>
<p>发生了变化：</p>
<ol>
<li><code>transferTo</code>方法调用触发 DMA 引擎将文件上下文信息拷贝到内核缓冲区。</li>
<li>数据不会被拷贝到套接字缓冲区，只有数据的描述符（包括数据位置和长度）被拷贝到套接字缓冲区。DMA 引擎直接将数据从内核缓冲区拷贝到协议引擎，这样减少了最后一次需要消耗CPU的拷贝操作。</li>
</ol>
<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul>
<li>较大，读写较慢，追求速度</li>
<li>M内存不足，不能加载太大数据</li>
<li>带宽不够，即存在其他程序或线程存在大量的IO操作，导致带宽本来就小</li>
</ul>
<h5 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h5><blockquote>
<p>在Linux 内核2.6版本上，以毫秒统计使用传统方法和使用<code>transferTo</code>方法传输不同大小的文件的耗时。表1展示了测试结果：</p>
</blockquote>
<table>
<thead>
<tr>
<th>File size</th>
<th>Normal file transfer (ms)</th>
<th>transferTo (ms)</th>
</tr>
</thead>
<tbody><tr>
<td>7MB</td>
<td>156</td>
<td>45</td>
</tr>
<tr>
<td>21MB</td>
<td>337</td>
<td>128</td>
</tr>
<tr>
<td>63MB</td>
<td>843</td>
<td>387</td>
</tr>
<tr>
<td>98MB</td>
<td>1320</td>
<td>617</td>
</tr>
<tr>
<td>200MB</td>
<td>2124</td>
<td>1150</td>
</tr>
<tr>
<td>350MB</td>
<td>3631</td>
<td>1762</td>
</tr>
<tr>
<td>700MB</td>
<td>13498</td>
<td>4422</td>
</tr>
<tr>
<td>1GB</td>
<td>18399</td>
<td>8537</td>
</tr>
</tbody></table>
<p>从测试结果来看使用<code>transgerTo</code>的API和传统方法相比可以降低65%的传输时间。这可以有效的提高在不同I/O通道之间大量拷贝数据应用的性能。</p>
<h5 id="实战-1"><a href="#实战-1" class="headerlink" title="实战"></a>实战</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileTransferTo</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileChannel inChannel = FileChannel.open(Paths.get(<span class="string">&quot;e://迅雷下载//ideaIU-2019.3.exe&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">    FileChannel outChannel = FileChannel.open(Paths.get(<span class="string">&quot;e://tmp//outFile.txt&quot;</span>), StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.READ, StandardOpenOption.CREATE);</span><br><span class="line">    <span class="keyword">long</span> timeStar = System.currentTimeMillis();<span class="comment">// 得到当前的时间</span></span><br><span class="line">    inChannel.transferTo(<span class="number">0</span>, inChannel.size(), outChannel);</span><br><span class="line">    <span class="comment">//  outChannel.transferFrom(inChannel, 0, inChannel.size());</span></span><br><span class="line">    <span class="keyword">long</span> timeEnd = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;transferTo Write time :&quot;</span> + (timeEnd - timeStar) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    inChannel.close();</span><br><span class="line">    outChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">---------使用TransferTo零拷贝--------------</span><br><span class="line">transferTo Write time :557ms</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> 零拷贝技术在很多中间件中，都有利用；<strong>如：Kafka，Spark、RocketMQ等</strong>，这个在网络传输数据时，<strong>能够提升速度，提升系统性能、吞吐量</strong>。小伙伴们<strong>不一定会编写，可以先了解基本原理就行</strong>。很多好的中间件产品都需要了解一些计算机原理方面的知识，才会更深入的理解。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小肥龙吃大冰淇淋</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://andice-cream.github.io/post/4aa1de86.html">https://andice-cream.github.io/post/4aa1de86.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://andice-cream.github.io" target="_blank">小肥龙吃大冰淇淋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9B%B6%E6%8B%B7%E8%B4%9D/">零拷贝</a></div><div class="post_share"><div class="social-share" data-image="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082137.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/f73611c8.html"><img class="prev-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082137.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ThreadLocal全面解析</div></div></a></div><div class="next-post pull-right"><a href="/post/3b1a6ccc.html"><img class="next-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212035.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java性能调优实战</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA-%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.</span> <span class="toc-text">JAVA-零拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.2.</span> <span class="toc-text">什么是零拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.2.1.</span> <span class="toc-text">避免数据拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E5%A4%9A%E7%A7%8D%E6%93%8D%E4%BD%9C%E7%BB%93%E5%90%88%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="toc-number">1.2.2.</span> <span class="toc-text">将多种操作结合在一起</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%BB%99%E6%88%91%E4%BB%AC%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">1.2.3.</span> <span class="toc-text">零拷贝给我们带来的好处</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86"><span class="toc-number">1.3.</span> <span class="toc-text">预备知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EI-O%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-number">1.3.1.</span> <span class="toc-text">关于I&#x2F;O内存映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU-COPY"><span class="toc-number">1.3.2.</span> <span class="toc-text">CPU COPY</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DMA-COPY"><span class="toc-number">1.3.3.</span> <span class="toc-text">DMA COPY</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">1.3.4.</span> <span class="toc-text">上下文切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E5%A4%9A%E6%AC%A1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.3.5.</span> <span class="toc-text">存在多次拷贝的原因</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E8%AF%BB%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.</span> <span class="toc-text">传统读操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.</span> <span class="toc-text">传统写操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%9C%BA%E6%99%AF"><span class="toc-number">1.5.1.</span> <span class="toc-text">实际场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9FIO"><span class="toc-number">1.6.</span> <span class="toc-text">传统IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">1.7.</span> <span class="toc-text">虚拟内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mmap-write%E6%96%B9%E5%BC%8F"><span class="toc-number">1.8.</span> <span class="toc-text">mmap+write方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sendfile%E6%96%B9%E5%BC%8F"><span class="toc-number">1.9.</span> <span class="toc-text">sendfile方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%9C%BA%E6%99%AF-1"><span class="toc-number">1.9.1.</span> <span class="toc-text">实际场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scatter-gather%E7%89%B9%E6%80%A7%E7%9A%84sendFile"><span class="toc-number">1.10.</span> <span class="toc-text">scatter-gather特性的sendFile</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%9C%BA%E6%99%AF-2"><span class="toc-number">1.10.1.</span> <span class="toc-text">实际场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JAVA%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.11.</span> <span class="toc-text">JAVA零拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MappedByteBuffer"><span class="toc-number">1.11.1.</span> <span class="toc-text">MappedByteBuffer</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.11.1.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.11.1.2.</span> <span class="toc-text">三种方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="toc-number">1.11.1.3.</span> <span class="toc-text">三个方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E7%89%B9%E6%80%A7"><span class="toc-number">1.11.1.4.</span> <span class="toc-text">三个特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E6%88%98"><span class="toc-number">1.11.1.5.</span> <span class="toc-text">实战</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#transgerTo"><span class="toc-number">1.11.2.</span> <span class="toc-text">transgerTo</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.11.2.1.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83"><span class="toc-number">1.11.2.2.</span> <span class="toc-text">性能比较</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E6%88%98-1"><span class="toc-number">1.11.2.3.</span> <span class="toc-text">实战</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.12.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 小肥龙吃大冰淇淋</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="framework-info"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202301132049386.png"/><span> </span><a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">晋ICP备2022012091号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'pinglun-9gh2lmcnd8587831',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'pinglun-9gh2lmcnd8587831',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@latest/source/js/issues.min.js"></script><script src="//code.tidio.co/smwivpnwumemac2wohardi3d3gpud1ag.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>