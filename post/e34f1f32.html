<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Redis-高可用 | 小肥龙吃大冰淇淋</title><meta name="keywords" content="Redis"><meta name="author" content="小肥龙吃大冰淇淋"><meta name="copyright" content="小肥龙吃大冰淇淋"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="“高可用性”（High Availability）通常来描述一个系统经过专门的设计，从而减少停工时间，而保持其服务的高度可用性。CAP的A AP模型单机的Redis是无法保证高可用性的，当Redis服务器宕机后，即使在有持久化的机制下也无法保证不丢失数据。所以我们采用Redis多机和集群的方式来保证Redis的高可用性。单进程+单线程 + 多机 （集群）  主从复制Redis支持主从复制功能，可以">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis-高可用">
<meta property="og:url" content="https://andice-cream.github.io/post/e34f1f32.html">
<meta property="og:site_name" content="小肥龙吃大冰淇淋">
<meta property="og:description" content="“高可用性”（High Availability）通常来描述一个系统经过专门的设计，从而减少停工时间，而保持其服务的高度可用性。CAP的A AP模型单机的Redis是无法保证高可用性的，当Redis服务器宕机后，即使在有持久化的机制下也无法保证不丢失数据。所以我们采用Redis多机和集群的方式来保证Redis的高可用性。单进程+单线程 + 多机 （集群）  主从复制Redis支持主从复制功能，可以">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165211.jpg">
<meta property="article:published_time" content="2021-08-13T09:50:00.000Z">
<meta property="article:modified_time" content="2022-11-27T09:16:39.691Z">
<meta property="article:author" content="小肥龙吃大冰淇淋">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165211.jpg"><link rel="shortcut icon" href="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210805191028.png"><link rel="canonical" href="https://andice-cream.github.io/post/e34f1f32"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis-高可用',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-27 17:16:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/ali_icon.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mogai.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="小肥龙吃大冰淇淋" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">178</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">73</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">40</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165211.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小肥龙吃大冰淇淋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis-高可用</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-13T09:50:00.000Z" title="发表于 2021-08-13 17:50:00">2021-08-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-27T09:16:39.691Z" title="更新于 2022-11-27 17:16:39">2022-11-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis/">Redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>48分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis-高可用"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>“高可用性”（High Availability）通常来描述一个系统经过专门的设计，从而减少停工时间，而保持其服<br>务的高度可用性。CAP的A AP模型<br>单机的Redis是无法保证高可用性的，当Redis服务器宕机后，即使在有持久化的机制下也无法保证不丢<br>失数据。<br>所以我们采用Redis多机和集群的方式来保证Redis的高可用性。<br>单进程+单线程 + 多机 （集群） </p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>Redis支持主从复制功能，可以通过执行slaveof（Redis5以后改成replicaof）或者在配置文件中设置<br>slaveof(Redis5以后改成replicaof)来开启复制功能。<br> <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100134.png" alt="img"></p>
<p>（一主一从） </p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100139.png" alt="img"><br> （一主多从）<br> <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100145.png" alt="img"></p>
<p>（传递复制）<br>主对外从对内，主可写从不可写<br>主挂了，从不可为主 </p>
<h3 id="主从配置"><a href="#主从配置" class="headerlink" title="主从配置"></a>主从配置</h3><h4 id="主Redis配置"><a href="#主Redis配置" class="headerlink" title="主Redis配置"></a>主Redis配置</h4><p>无需特殊配置 </p>
<h4 id="从Redis配置"><a href="#从Redis配置" class="headerlink" title="从Redis配置"></a>从Redis配置</h4><p>修改从服务器上的 redis.conf 文件： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># slaveof &lt;masterip&gt; &lt;masterport&gt;</span></span><br><span class="line"><span class="comment"># 表示当前【从服务器】对应的【主服务器】的IP是192.168.10.135，端口是6379。</span></span><br><span class="line">replicaof 127.0.0.1 6379</span><br></pre></td></tr></table></figure>

<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><p>一主多从，主从同步<br>主负责写，从负责读<br>提升Redis的性能和吞吐量<br>主从的数据一致性问题 </p>
<h4 id="数据容灾"><a href="#数据容灾" class="headerlink" title="数据容灾"></a>数据容灾</h4><p>从机是主机的备份<br>主机宕机，从机可读不可写<br>默认情况下主机宕机后，从机不可为主机<br>利用哨兵可以实现主从切换，做到高可用 </p>
<h3 id="原理与实现"><a href="#原理与实现" class="headerlink" title="原理与实现"></a>原理与实现</h3><h4 id="复制流程"><a href="#复制流程" class="headerlink" title="复制流程"></a>复制流程</h4><h5 id="保存主节点信息"><a href="#保存主节点信息" class="headerlink" title="保存主节点信息"></a>保存主节点信息</h5><p>当客户端向从服务器发送slaveof(replicaof) 主机地址（127.0.0.1） 端口（6379）时：从服务器将主机<br>ip（127.0.0.1）和端口（6379）保存到redisServer的masterhost和masterport中。 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Struct redisServer&#123;</span><br><span class="line">  char *masterhost;//主服务器ip</span><br><span class="line">  int masterport;//主服务器端口</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>

<p>从服务器将向发送SLAVEOF命令的客户端返回OK，表示复制指令已经被接收，而实际上复制工作是在<br>OK返回之后进行。 </p>
<h5 id="建立socket连接"><a href="#建立socket连接" class="headerlink" title="建立socket连接"></a>建立socket连接</h5><p>slaver与master建立socket连接<br>slaver关联文件事件处理器<br>该处理器接收RDB文件（全量复制）、接收Master传播来的写命令（增量复制） </p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100150.png" alt="img"><br> 主服务器accept从服务器Socket连接后，创建相应的客户端状态。相当于从服务器是主服务器的Client<br>端。<br> <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100153.png" alt="img"></p>
<h5 id="发送ping命令"><a href="#发送ping命令" class="headerlink" title="发送ping命令"></a>发送ping命令</h5><p>Slaver向Master发送ping命令<br>1、检测socket的读写状态 </p>
<p>2、检测Master能否正常处理<br>Master的响应：<br>1、发送“pong” , 说明正常<br>2、返回错误，说明Master不正常<br>3、timeout，说明网络超时<br> <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100205.png" alt="img"></p>
<h5 id="权限验证"><a href="#权限验证" class="headerlink" title="权限验证"></a>权限验证</h5><p>主从正常连接后，进行权限验证<br>主未设置密码（requirepass=“”） ，从也不用设置密码（masterauth=“”）<br>主设置密码(requirepass!=””),从需要设置密码(masterauth=主的requirepass的值)<br>或者从通过auth命令向主发送密码<br> <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100210.png" alt="img"></p>
<h5 id="发送端口信息"><a href="#发送端口信息" class="headerlink" title="发送端口信息"></a>发送端口信息</h5><p>在身份验证步骤之后，从服务器将执行命令REPLCONF listening-port ，向主服务器发送从服务器的监<br>听端口号。<br> <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100213.png" alt="img"></p>
<h5 id="同步数据"><a href="#同步数据" class="headerlink" title="同步数据"></a>同步数据</h5><p>Redis 2.8之后分为全量同步和增量同步 。</p>
<h5 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h5><p>当同步数据完成后，主从服务器就会进入命令传播阶段，主服务器只要将自己执行的写命令发送给从服<br>务器，而从服务器只要一直执行并接收主服务器发来的写命令。 </p>
<h4 id="同步数据集"><a href="#同步数据集" class="headerlink" title="同步数据集"></a>同步数据集</h4><p>Redis 2.8以前使用SYNC命令同步复制<br>Redis 2.8之后采用PSYNC命令替代SYNC  </p>
<h5 id="旧版本"><a href="#旧版本" class="headerlink" title="旧版本"></a>旧版本</h5><p>Redis 2.8以前<br><strong>实现方式</strong><br>Redis的同步功能分为同步(sync)和命令传播(command propagate)。<br><strong>1）****同步操作：</strong><br> \1. 通过从服务器发送到SYNC命令给主服务器<br>\2. 主服务器生成RDB文件并发送给从服务器，同时发送保存所有写命令给从服务器<br>\3. 从服务器清空之前数据并执行解释RDB文件<br>\4. 保持数据一致（还需要命令传播过程才能保持一致）<br> <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100221.png" alt="img"></p>
<p><strong>2）命令传播操作：</strong><br> 同步操作完成后，主服务器执行写命令，该命令发送给从服务器并执行，使主从保存一致。<br>缺陷<br>没有全量同步和增量同步的概念，从服务器在同步时，会清空所有数据。<br>主从服务器断线后重复制，主服务器会重新生成RDB文件和重新记录缓冲区的所有命令，并全量同步到<br>从服务器上。 </p>
<h5 id="新版"><a href="#新版" class="headerlink" title="新版"></a>新版</h5><p>Redis 2.8以后<br>实现方式<br>在Redis 2.8之后使用PSYNC命令，具备完整重同步和部分重同步模式。 </p>
<ul>
<li><p>Redis 的主从同步，分为全量同步和增量同步。</p>
</li>
<li><p>只有从机第一次连接上主机是全量同步。</p>
</li>
<li><p>断线重连有可能触发全量同步也有可能是增量同步（ master 判断 runid 是否一致）。<br>   <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100225.png" alt="img"></p>
</li>
<li><p>除此之外的情况都是增量同步。 </p>
</li>
</ul>
<p><strong>全量同步</strong><br> Redis 的全量同步过程主要分三个阶段：</p>
<ul>
<li><p>同步快照阶段： Master 创建并发送快照RDB给 Slave ， Slave 载入并解析快照。 Master 同时将</p>
</li>
<li><p>此阶段所产生的新的写命令存储到缓冲区。</p>
</li>
<li><p>同步写缓冲阶段： Master 向 Slave 同步存储在缓冲区的写操作命令。</p>
</li>
<li><p>同步增量阶段： Master 向 Slave 同步写操作命令。<br>   <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100228.png" alt="img"></p>
</li>
</ul>
<p><strong>增量同步</strong> </p>
<ul>
<li>Redis增量同步主要指Slave完成初始化后开始正常工作时， Master 发生的写操作同步到 Slave 的<br>  过程。 </li>
<li>通常情况下， Master 每执行一个写命令就会向 Slave 发送相同的写命令，然后 Slave 接收并执<br>  行。 </li>
</ul>
<h4 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h4><p>在命令传播阶段，从服务器默认会以每秒一次的频率向主服务器发送命令： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">replconf ack &lt;replication_offset&gt;</span><br><span class="line"><span class="comment">#ack :应答</span></span><br><span class="line"><span class="comment">#replication_offset：从服务器当前的复制偏移量</span></span><br></pre></td></tr></table></figure>

<p>主要作用有三个： </p>
<ol>
<li><p>检测主从的连接状态<br> 检测主从服务器的网络连接状态<br> 通过向主服务器发送INFO replication命令，可以列出从服务器列表，可以看出从最后一次向主发<br> 送命令距离现在过了多少秒。lag的值应该在0或1之间跳动，如果超过1则说明主从之间的连接有<br> 故障。</p>
</li>
<li><p>辅助实现min-slaves<br> Redis可以通过配置防止主服务器在不安全的情况下执行写命令<br> min-slaves-to-write 3 （min-replicas-to-write 3 ）<br> min-slaves-max-lag 10 （min-replicas-max-lag 10）<br> 上面的配置表示：从服务器的数量少于3个，或者三个从服务器的延迟（lag）值都大于或等于10<br> 秒时，主服务器将拒绝执行写命令。这里的延迟值就是上面INFOreplication命令的lag值。</p>
</li>
<li><p>检测命令丢失<br> 如果因为网络故障，主服务器传播给从服务器的写命令在半路丢失，那么当从服务器向主服务器发<br> 送REPLCONF ACK命令时，主服务器将发觉从服务器当前的复制偏移量少于自己的复制偏移量，<br> 然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里面找到从服务器缺少的数<br> 据，并将这些数据重新发送给从服务器。（补发） 网络不断<br> 增量同步：网断了，再次连接时 </p>
</li>
</ol>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>哨兵（sentinel）是Redis的高可用性(High Availability)的解决方案：<br>由一个或多个sentinel实例组成sentinel集群可以监视一个或多个主服务器和多个从服务器。<br>当主服务器进入下线状态时，sentinel可以将该主服务器下的某一从服务器升级为主服务器继续提供服<br>务，从而保证redis的高可用性。 </p>
<h3 id="部署方案"><a href="#部署方案" class="headerlink" title="部署方案"></a>部署方案</h3><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100231.png" alt="img"></p>
<h3 id="搭建配置"><a href="#搭建配置" class="headerlink" title="搭建配置"></a>搭建配置</h3><p>在一台机器上采用伪分布式的方式部署。（生产环境应该是多台机器）<br>根据上面的部署方案搭建如下：<br>Redis-Master ：127.0.0.1 6379<br>采用安装的方式，正常安装和配置 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1 安装redis5.0</span></span><br><span class="line">mkdir redis-master</span><br><span class="line"><span class="built_in">cd</span> /var/redis-5.0.5/src/</span><br><span class="line">make install PREFIX=/var/redis-ms/redis-master</span><br><span class="line">cp /var/redis-5.0.5/redis.conf /var/redis-ms/redis-master/bin</span><br><span class="line"><span class="comment">#2 修改redis.conf</span></span><br><span class="line"><span class="comment"># 将`daemonize`由`no`改为`yes`</span></span><br><span class="line">daemonize yes</span><br><span class="line"><span class="comment"># 默认绑定的是回环地址，默认不能被其他机器访问</span></span><br><span class="line"><span class="comment"># bind 127.0.0.1</span></span><br><span class="line"><span class="comment"># 是否开启保护模式，由yes该为no</span></span><br><span class="line">protected-mode no</span><br></pre></td></tr></table></figure>

<p>Redis-Slaver1：127.0.0.1 6380 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装redis-slaver1</span></span><br><span class="line">mkdir redis-slaver1</span><br><span class="line">cp -r /var/redis-ms/redis-master/* /var/redis-ms/redis-slaver1</span><br><span class="line"><span class="comment">#修改配置文件</span></span><br><span class="line">vim /var/redis-ms/redis-slaver1/redis.conf</span><br><span class="line">port 6380</span><br><span class="line">replicaof 127.0.0.1 6379</span><br></pre></td></tr></table></figure>

<p>Redis-Slaver2：127.0.0.1 6381 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装redis-slaver2</span></span><br><span class="line">mkdir redis-slaver2</span><br><span class="line">cp -r /var/redis-ms/redis-master/* /var/redis-ms/redis-slaver2</span><br><span class="line"><span class="comment">#修改配置文件</span></span><br><span class="line">vim /var/redis-ms/redis-slaver2/redis.conf</span><br><span class="line">port 6381</span><br><span class="line">replicaof 127.0.0.1 6379</span><br></pre></td></tr></table></figure>

<p>Redis-Sentinel1:127.0.0.1 26379 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装redis-sentinel1</span></span><br><span class="line">mkdir redis-sentinel1</span><br><span class="line">cp -r /var/redis-ms/redis-master/* /var/redis-ms/redis-sentinel1</span><br><span class="line"><span class="comment">#拷贝sentinel.conf 配置文件并修改</span></span><br><span class="line">cp /var/redis-5.0.5/sentinel.conf /var/redis-ms/redis-sentinel1</span><br><span class="line"><span class="comment"># 哨兵sentinel实例运行的端口 默认26379</span></span><br><span class="line">port 26379</span><br><span class="line"><span class="comment"># 将`daemonize`由`no`改为`yes`</span></span><br><span class="line">daemonize yes</span><br><span class="line"><span class="comment"># 哨兵sentinel监控的redis主节点的 ip port</span></span><br><span class="line"><span class="comment"># master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。</span></span><br><span class="line"><span class="comment"># quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了</span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"><span class="comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提</span></span><br><span class="line">供密码</span><br><span class="line"><span class="comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"><span class="comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒，改成3秒</span></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 3000</span><br><span class="line"><span class="comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，</span></span><br><span class="line">这个数字越小，完成failover所需的时间就越长，</span><br><span class="line">但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。</span><br><span class="line">可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"><span class="comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面：</span></span><br><span class="line"><span class="comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span></span><br><span class="line"><span class="comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master</span></span><br><span class="line">那里同步数据时。</span><br><span class="line"><span class="comment">#3.当想要取消一个正在进行的failover所需要的时间。</span></span><br><span class="line"><span class="comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，</span></span><br><span class="line">slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span><br><span class="line"><span class="comment"># 默认三分钟</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure>

<p>Redis-Sentinel2:127.0.0.1 26380 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装redis-sentinel2</span></span><br><span class="line">mkdir redis-sentinel2</span><br><span class="line">cp -r /var/redis-ms/redis-sentinel1/* /var/redis-ms/redis-sentinel2</span><br><span class="line"><span class="comment">#修改sentinel.conf</span></span><br><span class="line">vim /var/redis-ms/redis-sentinel2/sentinel.conf</span><br><span class="line">port 26380</span><br></pre></td></tr></table></figure>

<p>Redis-Sentinel3:127.0.0.1 26381 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装redis-sentinel3</span></span><br><span class="line">mkdir redis-sentinel3</span><br><span class="line">cp -r /var/redis-ms/redis-sentinel1/* /var/redis-ms/redis-sentinel3</span><br><span class="line"><span class="comment">#修改sentinel.conf</span></span><br><span class="line">vim /var/redis-ms/redis-sentinel3/sentinel.conf</span><br><span class="line">port 26381</span><br></pre></td></tr></table></figure>

<p>配置好后依次执行<br>redis-master、redis-slaver1、redis-slaver2、redis-sentinel1、redis-sentinel2、redis-sentinel3 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动redis-master和redis-slaver</span></span><br><span class="line">在redis-master目录下 ./redis-server redis.conf</span><br><span class="line">在redis-slaver1目录下 ./redis-server redis.conf</span><br><span class="line">在redis-slaver2目录下 ./redis-server redis.conf</span><br><span class="line"><span class="comment">#启动redis-sentinel</span></span><br><span class="line">在redis-sentinel1目录下 ./redis-sentinel sentinel.conf</span><br><span class="line">在redis-sentinel2目录下 ./redis-sentinel sentinel.conf</span><br><span class="line">在redis-sentinel3目录下 ./redis-sentinel sentinel.conf</span><br><span class="line"><span class="comment">#查看启动状态</span></span><br><span class="line">[root@localhost bin]<span class="comment"># ps -ef |grep redis</span></span><br><span class="line">root 3602 1 0 01:33 ? 00:00:00 ./redis-server *:6379</span><br><span class="line">root 3647 1 0 01:37 ? 00:00:00 ./redis-server *:6380</span><br><span class="line">root 3717 1 0 01:40 ? 00:00:00 ./redis-server *:6381</span><br><span class="line">root 3760 1 0 01:42 ? 00:00:00 ./redis-sentinel *:26379</span><br><span class="line">[sentinel]</span><br><span class="line">root 3765 1 0 01:42 ? 00:00:00 ./redis-sentinel *:26380</span><br><span class="line">[sentinel]</span><br><span class="line">root 3770 1 0 01:42 ? 00:00:00 ./redis-sentinel *:26381</span><br><span class="line">[sentinel]</span><br><span class="line">root 3783 2261 0 01:42 pts/0 00:00:00 grep --color=auto redis</span><br></pre></td></tr></table></figure>

<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><h4 id="启动并初始化Sentinel"><a href="#启动并初始化Sentinel" class="headerlink" title="启动并初始化Sentinel"></a>启动并初始化Sentinel</h4><p>Sentinel是一个特殊的Redis服务器<br>不会进行持久化<br>Sentinel实例启动后<br>每个Sentinel会创建2个连向主服务器的网络连接<br>命令连接：用于向主服务器发送命令，并接收响应；<br>订阅连接：用于订阅主服务器的—sentinel—:hello频道。<br> <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100239.png" alt="img"></p>
<h4 id="获取主服务器信息"><a href="#获取主服务器信息" class="headerlink" title="获取主服务器信息"></a>获取主服务器信息</h4><p>Sentinel默认每10s一次，向被监控的主服务器发送info命令，获取主服务器和其下属从服务器的信息。 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info</span><br><span class="line"><span class="comment"># Server</span></span><br><span class="line">redis_version:5.0.5</span><br><span class="line">os:Linux 3.10.0-229.el7.x86_64 x86_64</span><br><span class="line">run_id:a4e06ab61b4116660aa37b85079ed482b0b695b1</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=1571684,lag=1</span><br><span class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=1571551,lag=1</span><br><span class="line">master_replid:366322125dd7dc9bc95ed3467cfec841c112e207</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:1571684</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:523109</span><br><span class="line">repl_backlog_histlen:1048576</span><br></pre></td></tr></table></figure>

<h4 id="获取从服务器信息"><a href="#获取从服务器信息" class="headerlink" title="获取从服务器信息"></a>获取从服务器信息</h4><p>当Sentinel发现主服务器有新的从服务器出现时，Sentinel还会向从服务器建立命令连接和订阅连接。<br>在命令连接建立之后，Sentinel还是默认10s一次，向从服务器发送info命令，并记录从服务器的信息。<br> <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100243.png" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Server</span></span><br><span class="line">redis_version:5.0.5</span><br><span class="line">os:Linux 3.10.0-229.el7.x86_64 x86_64</span><br><span class="line">run_id:e289b3286352aaf8cc9f1ac7ebcc6d36131b8321</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:0</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:1699595</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:366322125dd7dc9bc95ed3467cfec841c112e207</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:1699595</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:651020</span><br><span class="line">repl_backlog_histlen:1048576</span><br></pre></td></tr></table></figure>

<h4 id="向主服务器和从服务器发送消息-以订阅的方式"><a href="#向主服务器和从服务器发送消息-以订阅的方式" class="headerlink" title="向主服务器和从服务器发送消息(以订阅的方式)"></a>向主服务器和从服务器发送消息(以订阅的方式)</h4><p>默认情况下，Sentinel每2s一次，向所有被监视的主服务器和从服务器所订阅的—sentinel—:hello频道<br>上发送消息，消息中会携带Sentinel自身的信息和主服务器的信息。 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUBLISH _sentinel_:hello <span class="string">&quot;&lt; s_ip &gt; &lt; s_port &gt;&lt; s_runid &gt;&lt; s_epoch &gt; &lt; m_name &gt; &lt;</span></span><br><span class="line"><span class="string">m_ip &gt;&lt; m_port &gt;&lt;m_epoch&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="接收来自主服务器和从服务器的频道信息"><a href="#接收来自主服务器和从服务器的频道信息" class="headerlink" title="接收来自主服务器和从服务器的频道信息"></a>接收来自主服务器和从服务器的频道信息</h4><p>当Sentinel与主服务器或者从服务器建立起订阅连接之后，Sentinel就会通过订阅连接，向服务器发送<br>以下命令： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">subscribe —sentinel—:hello</span><br></pre></td></tr></table></figure>

<p>Sentinel彼此之间只创建命令连接，而不创建订阅连接，因为Sentinel通过订阅主服务器或从服务器，<br>就可以感知到新的Sentinel的加入，而一旦新Sentinel加入后，相互感知的Sentinel通过命令连接来通信<br>就可以了。 </p>
<h4 id="检测主观下线状态"><a href="#检测主观下线状态" class="headerlink" title="检测主观下线状态"></a>检测主观下线状态</h4><p>Sentinel每秒一次向所有与它建立了命令连接的实例(主服务器、从服务器和其他Sentinel)发送PING命<br>令<br>实例在down-after-milliseconds毫秒内返回无效回复(除了+PONG、-LOADING、-MASTERDOWN外)<br>实例在down-after-milliseconds毫秒内无回复（超时）<br>Sentinel就会认为该实例主观下线(SDown) </p>
<h4 id="检查客观下线状态"><a href="#检查客观下线状态" class="headerlink" title="检查客观下线状态"></a>检查客观下线状态</h4><p>当一个Sentinel将一个主服务器判断为主观下线后<br>Sentinel会向同时监控这个主服务器的所有其他Sentinel发送查询命令<br>主机的<br> <code>SENTINEL is-master-down-by-addr &lt;ip&gt; &lt;port&gt; &lt;current_epoch&gt; &lt;runid&gt; </code></p>
<p>其他Sentinel回复<br> <code>&lt;down_state&gt;&lt; leader_runid &gt;&lt; leader_epoch &gt; </code></p>
<p>判断它们是否也认为主服务器下线。如果达到Sentinel配置中的quorum数量的Sentinel实例都判断主服<br>务器为主观下线，则该主服务器就会被判定为客观下线(ODown)。</p>
<h4 id="选举Leader-Sentinel"><a href="#选举Leader-Sentinel" class="headerlink" title="选举Leader Sentinel"></a>选举Leader Sentinel</h4><p>当一个主服务器被判定为客观下线后，监视这个主服务器的所有Sentinel会通过选举算法（raft），选<br>出一个Leader Sentinel去执行failover（故障转移）操作。 </p>
<h3 id="哨兵leader选举"><a href="#哨兵leader选举" class="headerlink" title="哨兵leader选举"></a>哨兵leader选举</h3><p><strong>Raft</strong><br>Raft协议是用来解决分布式系统一致性问题的协议。<br>Raft协议描述的节点共有三种状态：Leader, Follower, Candidate。<br>term：Raft协议将时间切分为一个个的Term（任期），可以认为是一种“逻辑时间”。<br>选举流程：<br>Raft采用心跳机制触发Leader选举<br>系统启动后，全部节点初始化为Follower，term为0。<br> 节点如果收到了RequestVote或者AppendEntries，就会保持自己的Follower身份<br>节点如果一段时间内没收到AppendEntries消息，在该节点的超时时间内还没发现Leader，Follower就<br>会转换成Candidate，自己开始竞选Leader。<br>一旦转化为Candidate，该节点立即开始下面几件事情：</p>
<ul>
<li><p>增加自己的term。</p>
</li>
<li><p>启动一个新的定时器。</p>
</li>
<li><p>给自己投一票。</p>
</li>
<li><p>向所有其他节点发送RequestVote，并等待其他节点的回复。 </p>
</li>
</ul>
<p>如果在计时器超时前，节点收到多数节点的同意投票，就转换成Leader。同时向所有其他节点发送<br>AppendEntries，告知自己成为了Leader。<br>每个节点在一个term内只能投一票，采取先到先得的策略，Candidate前面说到已经投给了自己，<br>Follower会投给第一个收到RequestVote的节点。<br>Raft协议的定时器采取随机超时时间，这是选举Leader的关键。<br>在同一个term内，先转为Candidate的节点会先发起投票，从而获得多数票。<br><strong>Sentinel的leader选举流程</strong> </p>
<ol>
<li><p>某Sentinel认定master客观下线后，该Sentinel会先看看自己有没有投过票，如果自己已经投过票<br> 给其他Sentinel了，在一定时间内自己就不会成为Leader。</p>
</li>
<li><p>如果该Sentinel还没投过票，那么它就成为Candidate。</p>
</li>
<li><p>Sentinel需要完成几件事情： </p>
</li>
</ol>
<ul>
<li><p>更新故障转移状态为start</p>
</li>
<li><p>当前epoch加1，相当于进入一个新term，在Sentinel中epoch就是Raft协议中的term。</p>
</li>
<li><p>向其他节点发送 is-master-down-by-addr 命令请求投票。命令会带上自己的epoch。</p>
</li>
<li><p>给自己投一票（leader、leader_epoch） </p>
</li>
</ul>
<ol>
<li><p>当其它哨兵收到此命令时，可以同意或者拒绝它成为领导者；（通过判断epoch） </p>
</li>
<li><p>Candidate会不断的统计自己的票数，直到他发现认同他成为Leader的票数超过一半而且超过它配<br> 置的quorum，这时它就成为了Leader。 </p>
</li>
<li><p>其他Sentinel等待Leader从slave选出master后，检测到新的master正常工作后，就会去掉客观下<br> 线的标识。 </p>
</li>
</ol>
<h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>当选举出Leader Sentinel后，Leader Sentinel会对下线的主服务器执行故障转移操作，主要有三个步<br>骤： </p>
<ol>
<li><p>它会将失效 Master 的其中一个 Slave 升级为新的 Master , 并让失效 Master 的其他 Slave 改为复<br> 制新的 Master ；</p>
</li>
<li><p>当客户端试图连接失效的 Master 时，集群也会向客户端返回新 Master 的地址，使得集群可以使<br> 用现在的 Master 替换失效 Master 。</p>
</li>
<li><p>Master 和 Slave 服务器切换后， Master 的 redis.conf 、 Slave 的 redis.conf 和<br> sentinel.conf 的配置文件的内容都会发生相应的改变，即， Master 主服务器的 redis.conf<br> 配置文件中会多一行 replicaof 的配置， sentinel.conf 的监控目标会随之调换。 </p>
</li>
</ol>
<h3 id="主服务器的选择"><a href="#主服务器的选择" class="headerlink" title="主服务器的选择"></a>主服务器的选择</h3><p>哨兵leader根据以下规则从客观下线的主服务器的从服务器中选择出新的主服务器。</p>
<ol>
<li><p>过滤掉主观下线的节点</p>
</li>
<li><p>选择slave-priority最高的节点，如果由则返回没有就继续选择</p>
</li>
<li><p>选择出复制偏移量最大的系节点，因为复制偏移量越大则数据复制的越完整，如果由就返回了，没<br> 有就继续</p>
</li>
<li><p>选择run_id最小的节点，因为run_id越小说明重启次数越少 </p>
</li>
</ol>
<h2 id="集群与分区"><a href="#集群与分区" class="headerlink" title="集群与分区"></a>集群与分区</h2><p>分区是将数据分布在多个Redis实例（Redis主机）上，以至于每个实例只包含一部分数据。 </p>
<h3 id="分区的意义"><a href="#分区的意义" class="headerlink" title="分区的意义"></a>分区的意义</h3><ul>
<li>性能的提升<br>  单机Redis的网络I/O能力和计算资源是有限的，将请求分散到多台机器，充分利用多台机器的计算能力<br>  可网络带宽，有助于提高Redis总体的服务能力。</li>
<li>存储能力的横向扩展<br>  即使Redis的服务能力能够满足应用需求，但是随着存储数据的增加，单台机器受限于机器本身的存储<br>  容量，将数据分散到多台机器上存储使得Redis服务可以横向扩展。 </li>
</ul>
<h3 id="分区的方式"><a href="#分区的方式" class="headerlink" title="分区的方式"></a>分区的方式</h3><p>根据分区键（id）进行分区： </p>
<h4 id="范围分区"><a href="#范围分区" class="headerlink" title="范围分区"></a>范围分区</h4><p>根据id数字的范围比如1–10000、100001–20000…..90001-100000，每个范围分到不同的Redis实例<br>中 </p>
<table>
<thead>
<tr>
<th>id范围</th>
<th>Redis实例</th>
</tr>
</thead>
<tbody><tr>
<td>1–10000</td>
<td>Redis01</td>
</tr>
<tr>
<td>100001–20000</td>
<td>Redis02</td>
</tr>
<tr>
<td>……</td>
<td></td>
</tr>
<tr>
<td>90001-100000</td>
<td>Redis10</td>
</tr>
</tbody></table>
<p>好处：<br>实现简单，方便迁移和扩展<br>缺陷：<br>热点数据分布不均，性能损失<br> 非数字型key，比如uuid无法使用(可采用雪花算法替代)<br>分布式环境 主键 雪花算法<br>是数字<br>能排序 </p>
<h4 id="hash分区"><a href="#hash分区" class="headerlink" title="hash分区"></a>hash分区</h4><p>利用简单的hash算法即可：<br>Redis实例=hash(key)%N<br>key:要进行分区的键，比如user_id<br>N:Redis实例个数(Redis主机)<br>好处：<br>支持任何类型的key<br>热点分布较均匀，性能较好<br>缺陷：<br>迁移复杂，需要重新计算，扩展较差（利用一致性hash环） </p>
<h3 id="client端分区"><a href="#client端分区" class="headerlink" title="client端分区"></a>client端分区</h3><p>对于一个给定的key，客户端直接选择正确的节点来进行读写。许多Redis客户端都实现了客户端分区<br>(JedisPool)，也可以自行编程实现。 </p>
<h4 id="部署方案-1"><a href="#部署方案-1" class="headerlink" title="部署方案"></a>部署方案</h4><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100249.png" alt="img"></p>
<h4 id="客户端选择算法"><a href="#客户端选择算法" class="headerlink" title="客户端选择算法"></a>客户端选择算法</h4><h5 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h5><p>普通hash<br>hash(key)%N<br>hash:可以采用hash算法，比如CRC32、CRC16等<br>N:是Redis主机个数<br>比如： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">user_id : u001</span><br><span class="line"><span class="built_in">hash</span>(u001) : 1844213068</span><br><span class="line">Redis实例=1844213068%3</span><br><span class="line">余数为2，所以选择Redis3。</span><br></pre></td></tr></table></figure>

<p><strong>普通Hash的优势</strong><br> 实现简单，热点数据分布均匀<br><strong>普通Hash的缺陷</strong><br>节点数固定，扩展的话需要重新计算<br>查询时必须用分片的key来查，一旦key改变，数据就查不出了，所以要使用不易改变的key进行分片</p>
<h5 id="一致性hash"><a href="#一致性hash" class="headerlink" title="一致性hash"></a>一致性hash</h5><p><strong>基本概念</strong><br> 普通hash是对主机数量取模，而一致性hash是对2^32（4 294 967 296）取模。我们把2^32想象成一<br>个圆，就像钟表一样，钟表的圆可以理解成由60个点组成的圆，而此处我们把这个圆想象成由2^32个<br>点组成的圆，示意图如下：<br> <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100253.png" alt="img"></p>
<p>圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1,也就<br>是说0点左侧的第一个点代表2^32-1 。我们把这个由2的32次方个点组成的圆环称为hash环。<br> 假设我们有3台缓存服务器，服务器A、服务器B、服务器C，那么，在生产环境中，这三台服务器肯定<br>有自己的IP地址，我们使用它们各自的IP地址进行哈希计算，使用哈希后的结果对2^32取模，可以使用<br>如下公式：<br> <strong>hash（服务器的IP地址） % 2^32</strong><br> 通过上述公式算出的结果一定是一个0到2^32-1之间的一个整数，我们就用算出的这个整数，代表服务<br>器A、服务器B、服务器C，既然这个整数肯定处于0到2^32-1之间，那么，上图中的hash环上必定有一<br>个点与这个整数对应，也就是服务器A、服务器B、服务C就可以映射到这个环上，如下图：<br> <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100257.png" alt="img"></p>
<p>假设，我们需要使用Redis缓存数据，那么我们使用如下公式可以将数据映射到上图中的hash环上。<br><strong>hash（key） % 2^32</strong><br>映射后的示意图如下，下图中的橘黄色圆形表示数据 </p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100300.png" alt="img"><br> 现在服务器与数据都被映射到了hash环上，上图中的数据将会被缓存到服务器A上，因为从数据的位置<br>开始，沿顺时针方向遇到的第一个服务器就是A服务器，所以，上图中的数据将会被缓存到服务器A上。<br>如图：<br> <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100303.png" alt="img"></p>
<p>将缓存服务器与被缓存对象都映射到hash环上以后，从被缓存对象的位置出发，沿顺时针方向遇到的第<br>一个服务器，就是当前对象将要缓存于的服务器，由于被缓存对象与服务器hash后的值是固定的，所<br>以，在服务器不变的情况下，数据必定会被缓存到固定的服务器上，那么，当下次想要访问这个数据<br>时，只要再次使用相同的算法进行计算，即可算出这个数据被缓存在哪个服务器上，直接去对应的服务<br>器查找对应的数据即可。多条数据存储如下：<br> <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100306.png" alt="img"></p>
<p><strong>优点</strong> </p>
<p>添加或移除节点时，数据只需要做部分的迁移，比如上图中把C服务器移除，则数据4迁移到服务器A<br>中，而其他的数据保持不变。添加效果是一样的。<br> <strong>hash环偏移</strong><br> 在介绍一致性哈希的概念时，我们理想化的将3台服务器均匀的映射到了hash环上。也就是说数据的范<br>围是2^32/N。但实际情况往往不是这样的。有可能某个服务器的数据会很多，某个服务器的数据会很<br>少，造成服务器性能不平均。这种现象称为hash环偏移。<br> <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100310.png" alt="img"></p>
<p>理论上我们可以通过增加服务器的方式来减少偏移，但这样成本较高，所以我们可以采用虚拟节点的方<br>式，也就是虚拟服务器，如图：<br> <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100313.png" alt="img"></p>
<p>“虚拟节点”是”实际节点”（实际的物理服务器）在hash环上的复制品,一个实际节点可以对应多个虚拟节<br>点。<br>从上图可以看出，A、B、C三台服务器分别虚拟出了一个虚拟节点，当然，如果你需要，也可以虚拟出<br>更多的虚拟节点。引入虚拟节点的概念后，缓存的分布就均衡多了，上图中，1号、3号数据被缓存在服<br>务器A中，5号、4号数据被缓存在服务器B中，6号、2号数据被缓存在服务器C中，如果你还不放心，可<br>以虚拟出更多的虚拟节点，以便减小hash环偏斜所带来的影响，虚拟节点越多，hash环上的节点就越<br>多，缓存被均匀分布的概率就越大。 </p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><h5 id="复杂度高"><a href="#复杂度高" class="headerlink" title="复杂度高"></a>复杂度高</h5><p>客户端需要自己处理数据路由,高可用、故障转移等问题</p>
<p>使用分区，数据的处理会变得复杂，不得不对付多个redis数据库和AOF文件，不得在多个实例和主机之<br>间持久化你的数据。 </p>
<h5 id="不易扩展"><a href="#不易扩展" class="headerlink" title="不易扩展"></a>不易扩展</h5><p>一旦节点的增或者删操作，都会导致key无法在redis中命中，必须重新根据节点计算，并手动迁移全部<br>或部分数据。 </p>
<h3 id="proxy端分区"><a href="#proxy端分区" class="headerlink" title="proxy端分区"></a>proxy端分区</h3><p>在客户端和服务器端引入一个代理或代理集群，客户端将命令发送到代理上，由代理根据算法，将命令<br>路由到相应的服务器上。常见的代理有Codis（豌豆荚）和TwemProxy（Twitter）。 </p>
<h4 id="部署架构"><a href="#部署架构" class="headerlink" title="部署架构"></a>部署架构</h4><p>Codis由豌豆荚于2014年11月开源，基于Go和C开发，是近期涌现的、国人开发的优秀开源软件之一。<br> <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100358.png" alt="img"></p>
<p>Codis 3.x 由以下组件组成： </p>
<ul>
<li><p>Codis Server：基于 redis-3.2.8 分支开发。增加了额外的数据结构，以支持 slot 有关的操作以及<br>  数据迁移指令。</p>
</li>
<li><p>Codis Proxy：客户端连接的 Redis 代理服务, 实现了 Redis 协议。 除部分命令不支持以外，表现<br>  的和原生的 Redis 没有区别（就像 Twemproxy）。</p>
</li>
<li><p>对于同一个业务集群而言，可以同时部署多个 codis-proxy 实例；</p>
</li>
<li><p>不同 codis-proxy 之间由 codis-dashboard 保证状态同步。</p>
</li>
<li><p>Codis Dashboard：集群管理工具，支持 codis-proxy、codis-server 的添加、删除，以及据迁移<br>  等操作。在集群状态发生改变时，codis-dashboard 维护集群下所有 codis-proxy 的状态的一致<br>  性。</p>
</li>
<li><p>对于同一个业务集群而言，同一个时刻 codis-dashboard 只能有 0个或者1个；</p>
</li>
<li><p>所有对集群的修改都必须通过 codis-dashboard 完成。</p>
</li>
<li><p>Codis Admin：集群管理的命令行工具。</p>
</li>
<li><p>可用于控制 codis-proxy、codis-dashboard 状态以及访问外部存储。</p>
</li>
<li><p>Codis FE：集群管理界面。</p>
</li>
<li><p>多个集群实例共享可以共享同一个前端展示页面；</p>
</li>
<li><p>通过配置文件管理后端 codis-dashboard 列表，配置文件可自动更新。</p>
</li>
<li><p>Storage：为集群状态提供外部存储。</p>
</li>
<li><p>提供 Namespace 概念，不同集群的会按照不同 product name 进行组织；</p>
</li>
<li><p>目前仅提供了 Zookeeper、Etcd、Fs 三种实现，但是提供了抽象的 interface 可自行扩展。 </p>
</li>
</ul>
<h4 id="分片原理"><a href="#分片原理" class="headerlink" title="分片原理"></a>分片原理</h4><p>Codis 将所有的 key 默认划分为 1024 个槽位(slot)，它首先对客户端传过来的 key 进行 crc32 运算计算<br>哈希值，再将 hash 后的整数值对 1024 这个整数进行取模得到一个余数，这个余数就是对应 key 的槽<br>位。<br> <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100445.png" alt="img"></p>
<p>Codis的槽位和分组的映射关系就保存在codis proxy当中。 </p>
<h4 id="优点-amp-缺点"><a href="#优点-amp-缺点" class="headerlink" title="优点&amp;缺点"></a>优点&amp;缺点</h4><p><strong>优点</strong> </p>
<ul>
<li><p>对客户端透明,与codis交互方式和redis本身交互一样</p>
</li>
<li><p>支持在线数据迁移,迁移过程对客户端透明有简单的管理和监控界面</p>
</li>
<li><p>支持高可用,无论是redis数据存储还是代理节点</p>
</li>
<li><p>自动进行数据的均衡分配</p>
</li>
<li><p>最大支持1024个redis实例,存储容量海量</p>
</li>
<li><p>高性能 </p>
</li>
</ul>
<p><strong>缺点</strong> </p>
<ul>
<li><p>采用自有的redis分支,不能与原版的redis保持同步</p>
</li>
<li><p>如果codis的proxy只有一个的情况下, redis的性能会下降20%左右</p>
</li>
<li><p>某些命令不支持 </p>
</li>
</ul>
<h3 id="官方cluster分区"><a href="#官方cluster分区" class="headerlink" title="官方cluster分区"></a>官方cluster分区</h3><p>Redis3.0之后，Redis官方提供了完整的集群解决方案。<br>方案采用去中心化的方式，包括：sharding（分区）、replication（复制）、failover（故障转移）。<br>称为RedisCluster。<br>Redis5.0前采用redis-trib进行集群的创建和管理，需要ruby支持<br>Redis5.0可以直接使用Redis-cli进行集群的创建和管理 </p>
<h4 id="部署架构-1"><a href="#部署架构-1" class="headerlink" title="部署架构"></a>部署架构</h4><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100456.png" alt="img"></p>
<h5 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h5><p>RedisCluster由多个Redis节点组构成，是一个P2P无中心节点的集群架构，依靠Gossip协议传播的集<br>群。 </p>
<h5 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h5><p>Gossip协议是一个通信协议，一种传播消息的方式。<br>起源于：病毒传播<br>Gossip协议基本思想就是：<br>一个节点周期性(每秒)随机选择一些节点，并把信息传递给这些节点。<br>这些收到信息的节点接下来会做同样的事情，即把这些信息传递给其他一些随机选择的节点。<br>信息会周期性的传递给N个目标节点。这个N被称为fanout（扇出）<br>gossip协议包含多种消息，包括meet、ping、pong、fail、publish等等。 </p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>meet</td>
<td>sender向receiver发出，请求receiver加入sender的集群</td>
</tr>
<tr>
<td>ping</td>
<td>节点检测其他节点是否在线</td>
</tr>
<tr>
<td>pong</td>
<td>receiver收到meet或ping后的回复信息；在failover后，新的Master也会广播pong</td>
</tr>
<tr>
<td>fail</td>
<td>节点A判断节点B下线后，A节点广播B的fail信息，其他收到节点会将B节点标记为下线</td>
</tr>
<tr>
<td>publish</td>
<td>节点A收到publish命令，节点A执行该命令，并向集群广播publish命令，收到publish 命令的节点都会执行相同的publish命令</td>
</tr>
</tbody></table>
<p>通过gossip协议，cluster可以提供集群间状态同步更新、选举自助failover等重要的集群功能。 </p>
<h5 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h5><p>redis-cluster把所有的物理节点映射到[0-16383]个slot上,基本上采用平均分配和连续分配的方式。<br> 比如上图中有5个主节点，这样在RedisCluster创建时，slot槽可按下表分配： </p>
<table>
<thead>
<tr>
<th>节点名称</th>
<th>slot范围</th>
</tr>
</thead>
<tbody><tr>
<td>Redis1</td>
<td>0-3270</td>
</tr>
<tr>
<td>Redis2</td>
<td>3271-6542</td>
</tr>
<tr>
<td>Redis3</td>
<td>6543-9814</td>
</tr>
<tr>
<td>Redis4</td>
<td>9815-13087</td>
</tr>
<tr>
<td>Redis5</td>
<td>13088-16383</td>
</tr>
</tbody></table>
<p>cluster 负责维护节点和slot槽的对应关系 value——&gt;slot——–&gt;节点<br>当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把<br>结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点<br>数量大致均等的将哈希槽映射到不同的节点。<br>比如：<br>set name zhaoyun<br>hash(“name”)采用crc16算法，得到值：1324203551%16384=15903<br>根据上表15903在13088-16383之间，所以name被存储在Redis5节点。<br>slot槽必须在节点上连续分配，如果出现不连续的情况，则RedisCluster不能工作，详见容错。 </p>
<h5 id="RedisCluster的优势"><a href="#RedisCluster的优势" class="headerlink" title="RedisCluster的优势"></a>RedisCluster的优势</h5><ul>
<li><p>高性能<br>  Redis Cluster 的性能与单节点部署是同级别的。<br>  多主节点、负载均衡、读写分离</p>
</li>
<li><p>高可用<br>  Redis Cluster 支持标准的 主从复制配置来保障高可用和高可靠。<br>  failover<br>  Redis Cluster 也实现了一个类似 Raft 的共识方式，来保障整个集群的可用性。</p>
</li>
<li><p>易扩展<br>  向 Redis Cluster 中添加新节点，或者移除节点，都是透明的，不需要停机。<br>  水平、垂直方向都非常容易扩展。<br>  数据分区，海量数据，数据存储</p>
</li>
<li><p>原生<br>  部署 Redis Cluster 不需要其他的代理或者工具，而且 Redis Cluster 和单机 Redis 几乎完全兼<br>  容。 </p>
</li>
</ul>
<p><strong>集群搭建</strong> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RedisCluster最少需要三台主服务器，三台从服务器。</span><br><span class="line">端口号分别为：7001~7006</span><br><span class="line">mkdir redis-cluster/7001</span><br><span class="line">make install PREFIX=/var/redis-cluster/7001</span><br><span class="line">cp /var/redis-5.0.5/redis.conf /var/redis-cluster/7001/bin</span><br></pre></td></tr></table></figure>

<ul>
<li>第一步：创建7001实例，并编辑redis.conf文件，修改port为7001。<br>  注意：创建实例，即拷贝单机版安装时，生成的bin目录，为7001目录。 </li>
</ul>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100503.png" alt="img"></p>
<ul>
<li>第二步：修改redis.conf配置文件，打开cluster-enable yes<br>   <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100505.png" alt="img"></li>
<li>第三步：复制7001，创建7002~7006实例，注意端口修改。 </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp -r /var/redis-cluster/7001/* /var/redis-cluster/7002</span><br><span class="line">cp -r /var/redis-cluster/7001/* /var/redis-cluster/7003</span><br><span class="line">cp -r /var/redis-cluster/7001/* /var/redis-cluster/7004</span><br><span class="line">cp -r /var/redis-cluster/7001/* /var/redis-cluster/7005</span><br><span class="line">cp -r /var/redis-cluster/7001/* /var/redis-cluster/7006</span><br></pre></td></tr></table></figure>

<ul>
<li>第四步：创建start.sh，启动所有的实例 </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> 7001/bin</span><br><span class="line">./redis-server redis.conf</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">cd</span> 7002/bin</span><br><span class="line">./redis-server redis.conf</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">cd</span> 7003/bin</span><br><span class="line">./redis-server redis.conf</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">cd</span> 7004/bin</span><br><span class="line">./redis-server redis.conf</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">cd</span> 7005/bin</span><br><span class="line">./redis-server redis.conf</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">cd</span> 7006/bin</span><br><span class="line">./redis-server redis.conf</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">chmod u+x start.sh (赋写和执行的权限)</span><br><span class="line">./start.sh(启动RedisCluster)</span><br></pre></td></tr></table></figure>

<ul>
<li>第五步：创建Redis集群（创建时Redis里不要有数据） </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cluster-replicas ： 1 1从机 前三个为主</span></span><br><span class="line">[root@localhost bin]<span class="comment"># ./redis-cli --cluster create 192.168.72.128:7001</span></span><br><span class="line">192.168.72.128:7002 192.168.72.128:7003 192.168.72.128:7004</span><br><span class="line">192.168.72.128:7005 192.168.72.128:7006 --cluster-replicas 1</span><br><span class="line">&gt;&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica 192.168.127.128:7005 to 192.168.127.128:7001</span><br><span class="line">Adding replica 192.168.127.128:7006 to 192.168.127.128:7002</span><br><span class="line">Adding replica 192.168.127.128:7004 to 192.168.127.128:7003</span><br><span class="line">&gt;&gt;&gt; Trying to optimize slaves allocation <span class="keyword">for</span> anti-affinity</span><br><span class="line">[WARNING] Some slaves are <span class="keyword">in</span> the same host as their master</span><br><span class="line">M: 02fdca827762904854293590323bb398e6bee971 192.168.127.128:7001</span><br><span class="line">slots:[0-5460] (5461 slots) master</span><br><span class="line">M: 2dddc9d3925d129edd4c6bd5eab3bbad531277ec 192.168.127.128:7002</span><br><span class="line">slots:[5461-10922] (5462 slots) master</span><br><span class="line">M: 95598dd50a91a72812ab5d441876bf2ee40ceef4 192.168.127.128:7003</span><br><span class="line">slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: 633af51cfdadb907e4d930f3f10082a77b256efb 192.168.127.128:7004</span><br><span class="line">replicates 02fdca827762904854293590323bb398e6bee971</span><br><span class="line">S: 2191b40176f95a2a969bdcaccdd236aa01a3099a 192.168.127.128:7005</span><br><span class="line">replicates 2dddc9d3925d129edd4c6bd5eab3bbad531277ec</span><br><span class="line">S: 1d35bec18fcc23f2c555a25563b1e6f2ffa3b0e9 192.168.127.128:7006</span><br><span class="line">replicates 95598dd50a91a72812ab5d441876bf2ee40ceef4</span><br><span class="line">Can I <span class="built_in">set</span> the above configuration? (<span class="built_in">type</span> <span class="string">&#x27;yes&#x27;</span> to accept): yes</span><br><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span><br><span class="line">Waiting <span class="keyword">for</span> the cluster to join</span><br><span class="line">.....</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.127.128:7001)</span><br><span class="line">M: 02fdca827762904854293590323bb398e6bee971 192.168.127.128:7001</span><br><span class="line">slots:[0-5460] (5461 slots) master</span><br><span class="line">1 additional replica(s)</span><br><span class="line">M: 95598dd50a91a72812ab5d441876bf2ee40ceef4 192.168.127.128:7003</span><br><span class="line">slots:[10923-16383] (5461 slots) master</span><br><span class="line">1 additional replica(s)</span><br><span class="line">S: 2191b40176f95a2a969bdcaccdd236aa01a3099a 192.168.127.128:7005</span><br><span class="line">slots: (0 slots) slave</span><br><span class="line">replicates 2dddc9d3925d129edd4c6bd5eab3bbad531277ec</span><br><span class="line">S: 633af51cfdadb907e4d930f3f10082a77b256efb 192.168.127.128:7004</span><br><span class="line">slots: (0 slots) slave</span><br><span class="line">replicates 02fdca827762904854293590323bb398e6bee971</span><br><span class="line">S: 1d35bec18fcc23f2c555a25563b1e6f2ffa3b0e9 192.168.127.128:7006</span><br><span class="line">slots: (0 slots) slave</span><br><span class="line">replicates 95598dd50a91a72812ab5d441876bf2ee40ceef4</span><br><span class="line">M: 2dddc9d3925d129edd4c6bd5eab3bbad531277ec 192.168.127.128:7002</span><br><span class="line">slots:[5461-10922] (5462 slots) master</span><br><span class="line">1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<p>命令客户端连接集群<br>命令： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-cli -h 127.0.0.1 -p 7001 -c</span><br></pre></td></tr></table></figure>

<p>注意：-c 表示是以redis集群方式进行连接 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost redis-cluster]<span class="comment"># cd 7001</span></span><br><span class="line">[root@localhost 7001]<span class="comment"># ./redis-cli -h 127.0.0.1 -p 7001 -c</span></span><br><span class="line">127.0.0.1:7001&gt; <span class="built_in">set</span> name1 aaa</span><br><span class="line">-&gt; Redirected to slot [12933] located at 127.0.0.1:7003</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7003&gt;</span><br></pre></td></tr></table></figure>

<p>查看集群的命令</p>
<ul>
<li>查看集群状态 </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:7003&gt; cluster info</span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6</span><br><span class="line">cluster_size:3</span><br><span class="line">cluster_current_epoch:6</span><br><span class="line">cluster_my_epoch:3</span><br><span class="line">cluster_stats_messages_sent:926</span><br><span class="line">cluster_stats_messages_received:926</span><br></pre></td></tr></table></figure>

<ul>
<li>查看集群中的节点 </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:7003&gt; cluster nodes</span><br><span class="line">d277cd2984639747a17ca79428602480b28ef070 127.0.0.1:7003@17003 myself,master - 0</span><br><span class="line">1570457306000 3 connected 10923-16383</span><br><span class="line">af559fc6c82c83dc39d07e2dfe59046d16b6a429 127.0.0.1:7001@17001 master - 0</span><br><span class="line">1570457307597 1 connected 0-5460</span><br><span class="line">e7b1f1962de2a1ffef2bf1ac5d94574b2e4d67d8 127.0.0.1:7005@17005 slave</span><br><span class="line">068b678923ad0858002e906040b0fef6fff8dda4 0 1570457308605 5 connected</span><br><span class="line">068b678923ad0858002e906040b0fef6fff8dda4 127.0.0.1:7002@17002 master - 0</span><br><span class="line">1570457309614 2 connected 5461-10922</span><br><span class="line">51c3ebdd0911dd6564040c7e20b9ae69cabb0425 127.0.0.1:7004@17004 slave</span><br><span class="line">af559fc6c82c83dc39d07e2dfe59046d16b6a429 0 1570457307000 4 connected</span><br><span class="line">78dfe773eaa817fb69a405a3863f5b8fcf3e172f 127.0.0.1:7006@17006 slave</span><br><span class="line">d277cd2984639747a17ca79428602480b28ef070 0 1570457309000 6 connected</span><br><span class="line">127.0.0.1:7003&gt;</span><br></pre></td></tr></table></figure>

<h4 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h4><p>不同节点分组服务于相互无交集的分片（sharding），Redis Cluster 不存在单独的proxy或配置服务<br>器，所以需要将客户端路由到目标的分片。</p>
<h5 id="客户端路由"><a href="#客户端路由" class="headerlink" title="客户端路由"></a>客户端路由</h5><p>Redis Cluster的客户端相比单机Redis 需要具备路由语义的识别能力，且具备一定的路由缓存能力。<br> <strong>moved重定向</strong><br> 1.每个节点通过通信都会共享Redis Cluster中槽和集群中对应节点的关系<br>2.客户端向Redis Cluster的任意节点发送命令，接收命令的节点会根据CRC16规则进行hash运算与<br>16384取余，计算自己的槽和对应节点<br>3.如果保存数据的槽被分配给当前节点，则去槽中执行命令，并把命令执行结果返回给客户端<br>4.如果保存数据的槽不在当前节点的管理范围内，则向客户端返回moved重定向异常<br>5.客户端接收到节点返回的结果，如果是moved异常，则从moved异常中获取目标节点的信息<br>6.客户端向目标节点发送命令，获取命令执行结果<br> <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100513.png" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost bin]<span class="comment"># ./redis-cli -h 127.0.0.1 -p 7001 -c</span></span><br><span class="line">127.0.0.1:7001&gt; <span class="built_in">set</span> name:001 zhaoyun</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7001&gt; get name:001</span><br><span class="line"><span class="string">&quot;zhaoyun&quot;</span></span><br><span class="line">[root@localhost bin]<span class="comment"># ./redis-cli -h 127.0.0.1 -p 7002 -c</span></span><br><span class="line">127.0.0.1:7002&gt; get name:001</span><br><span class="line">-&gt; Redirected to slot [4354] located at 127.0.0.1:7001</span><br><span class="line"><span class="string">&quot;zhaoyun&quot;</span></span><br><span class="line">127.0.0.1:7001&gt; cluster keyslot name:001</span><br><span class="line">(<span class="built_in">integer</span>) 4354</span><br></pre></td></tr></table></figure>

<p><strong>ask重定向</strong><br> 在对集群进行扩容和缩容时，需要对槽及槽中数据进行迁移<br>当客户端向某个节点发送命令，节点向客户端返回moved异常，告诉客户端数据对应的槽的节点信息<br>如果此时正在进行集群扩展或者缩空操作，当客户端向正确的节点发送命令时，槽及槽中数据已经被迁<br>移到别的节点了，就会返回ask，这就是ask重定向机制<br>1.客户端向目标节点发送命令，目标节点中的槽已经迁移支别的节点上了，此时目标节点会返回ask转<br>向给客户端<br>2.客户端向新的节点发送Asking命令给新的节点，然后再次向新节点发送命令<br>3.新节点执行命令，把命令执行结果返回给客户端<br> <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100517.png" alt="img"></p>
<p>moved和ask的区别<br>1、moved：槽已确认转移<br>2、ask：槽还在转移过程中<br> <strong>Smart智能客户端</strong><br> <strong>JedisCluster</strong><br> JedisCluster是Jedis根据RedisCluster的特性提供的集群智能客户端<br>JedisCluster为每个节点创建连接池，并跟节点建立映射关系缓存（Cluster slots）<br>JedisCluster将每个主节点负责的槽位一一与主节点连接池建立映射缓存<br>JedisCluster启动时，已经知道key,slot和node之间的关系，可以找到目标节点<br>JedisCluster对目标节点发送命令，目标节点直接响应给JedisCluster<br>如果JedisCluster与目标节点连接出错，则JedisCluster会知道连接的节点是一个错误的节点<br>此时节点返回moved异常给JedisCluster<br>JedisCluster会重新初始化slot与node节点的缓存关系，然后向新的目标节点发送命令，目标命令执行<br>命令并向JedisCluster响应<br>如果命令发送次数超过5次，则抛出异常”Too many cluster redirection!”<br> <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100523.png" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">JedisPoolConfig config = new JedisPoolConfig();</span><br><span class="line">Set&lt;HostAndPort&gt; jedisClusterNode = new HashSet&lt;HostAndPort&gt;();</span><br><span class="line">jedisClusterNode.add(new HostAndPort(<span class="string">&quot;192.168.127.128&quot;</span>, 7001));</span><br><span class="line">jedisClusterNode.add(new HostAndPort(<span class="string">&quot;192.168.127.128&quot;</span>, 7002));</span><br><span class="line">jedisClusterNode.add(new HostAndPort(<span class="string">&quot;192.168.127.128&quot;</span>, 7003));</span><br><span class="line">jedisClusterNode.add(new HostAndPort(<span class="string">&quot;192.168.127.128&quot;</span>, 7004));</span><br><span class="line">jedisClusterNode.add(new HostAndPort(<span class="string">&quot;192.168.127.128&quot;</span>, 7005));</span><br><span class="line">jedisClusterNode.add(new HostAndPort(<span class="string">&quot;192.168.127.128&quot;</span>, 7006));</span><br><span class="line">JedisCluster jcd = new JedisCluster(jedisClusterNode, config);</span><br><span class="line">jcd.set(<span class="string">&quot;name:001&quot;</span>,<span class="string">&quot;zhangfei&quot;</span>);</span><br><span class="line">String value = jcd.get(<span class="string">&quot;name:001&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h5><p>在RedisCluster中每个slot 对应的节点在初始化后就是确定的。在某些情况下，节点和分片需要变更：</p>
<ul>
<li><p>新的节点作为master加入；</p>
</li>
<li><p>某个节点分组需要下线；</p>
</li>
<li><p>负载不均衡需要调整slot 分布。</p>
</li>
</ul>
<p>此时需要进行分片的迁移，迁移的触发和过程控制由外部系统完成。包含下面 2 种：</p>
<ul>
<li>节点迁移状态设置：迁移前标记源/目标节点。</li>
<li>key迁移的原子化命令：迁移的具体步骤。<br>   <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100527.png" alt="img"></li>
</ul>
<p>1、向节点B发送状态变更命令，将B的对应slot 状态置为importing。 </p>
<p>2、向节点A发送状态变更命令，将A对应的slot 状态置为migrating。 </p>
<p>3、向A 发送migrate 命令，告知A 将要迁移的slot对应的key 迁移到B。<br>4、当所有key 迁移完成后，cluster setslot 重新设置槽位。 </p>
<h5 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h5><p>添加主节点（无数据）</p>
<ul>
<li>先创建7007节点 （无数据） </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir redis-cluster/7007</span><br><span class="line">make install PREFIX=/var/redis-cluster/7007</span><br></pre></td></tr></table></figure>

<ul>
<li>添加7007结点作为新节点,并启动<br>   执行命令： </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost bin]<span class="comment"># ./redis-cli --cluster add-node 192.168.72.128:7007</span></span><br><span class="line">192.168.72.128:7001</span><br><span class="line">&gt;&gt;&gt; Adding node 192.168.127.128:7007 to cluster 192.168.127.128:7001</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.127.128:7001)</span><br><span class="line">M: 02fdca827762904854293590323bb398e6bee971 192.168.127.128:7001</span><br><span class="line">slots:[0-5460] (5461 slots) master</span><br><span class="line">1 additional replica(s)</span><br><span class="line">M: 95598dd50a91a72812ab5d441876bf2ee40ceef4 192.168.127.128:7003</span><br><span class="line">slots:[10923-16383] (5461 slots) master</span><br><span class="line">1 additional replica(s)</span><br><span class="line">S: 2191b40176f95a2a969bdcaccdd236aa01a3099a 192.168.127.128:7005</span><br><span class="line">slots: (0 slots) slave</span><br><span class="line">replicates 2dddc9d3925d129edd4c6bd5eab3bbad531277ec</span><br><span class="line">S: 633af51cfdadb907e4d930f3f10082a77b256efb 192.168.127.128:7004</span><br><span class="line">slots: (0 slots) slave</span><br><span class="line">replicates 02fdca827762904854293590323bb398e6bee971</span><br><span class="line">S: 1d35bec18fcc23f2c555a25563b1e6f2ffa3b0e9 192.168.127.128:7006</span><br><span class="line">slots: (0 slots) slave</span><br><span class="line">replicates 95598dd50a91a72812ab5d441876bf2ee40ceef4</span><br><span class="line">M: 2dddc9d3925d129edd4c6bd5eab3bbad531277ec 192.168.127.128:7002</span><br><span class="line">slots:[5461-10922] (5462 slots) master</span><br><span class="line">1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line">&gt;&gt;&gt; Send CLUSTER MEET to node 192.168.127.128:7007 to make it join the cluster.</span><br><span class="line">[OK] New node added correctly.</span><br></pre></td></tr></table></figure>

<ul>
<li>查看集群结点发现7007已添加到集群中 </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:7001&gt; cluster nodes</span><br><span class="line">d277cd2984639747a17ca79428602480b28ef070 127.0.0.1:7003@17003 master - 0</span><br><span class="line">1570457568602 3 connected 10923-16383</span><br><span class="line">50b073163bc4058e89d285dc5dfc42a0d1a222f2 127.0.0.1:7007@17007 master - 0</span><br><span class="line">1570457567000 0 connected</span><br><span class="line">e7b1f1962de2a1ffef2bf1ac5d94574b2e4d67d8 127.0.0.1:7005@17005 slave</span><br><span class="line">068b678923ad0858002e906040b0fef6fff8dda4 0 1570457569609 5 connected</span><br><span class="line">068b678923ad0858002e906040b0fef6fff8dda4 127.0.0.1:7002@17002 master - 0</span><br><span class="line">1570457566000 2 connected 5461-10922</span><br><span class="line">51c3ebdd0911dd6564040c7e20b9ae69cabb0425 127.0.0.1:7004@17004 slave</span><br><span class="line">af559fc6c82c83dc39d07e2dfe59046d16b6a429 0 1570457567000 4 connected</span><br><span class="line">af559fc6c82c83dc39d07e2dfe59046d16b6a429 127.0.0.1:7001@17001 myself,master - 0</span><br><span class="line">1570457567000 1 connected 0-5460</span><br><span class="line">78dfe773eaa817fb69a405a3863f5b8fcf3e172f 127.0.0.1:7006@17006 slave</span><br><span class="line">d277cd2984639747a17ca79428602480b28ef070 0 1570457567593 6 connected</span><br></pre></td></tr></table></figure>

<p>hash槽重新分配（数据迁移）<br><strong>添加完主节点需要对主节点进行hash槽分配，这样该主节才可以存储数据。</strong> </p>
<ul>
<li>查看集群中槽占用情况<br>   <code>cluster nodes </code></li>
</ul>
<p>redis集群有16384个槽，集群中的每个结点分配自已槽，通过查看集群结点可以看到槽占用情况。 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:7001&gt; cluster nodes</span><br><span class="line">d277cd2984639747a17ca79428602480b28ef070 127.0.0.1:7003@17003 master - 0</span><br><span class="line">1570457568602 3 connected 10923-16383</span><br><span class="line">50b073163bc4058e89d285dc5dfc42a0d1a222f2 127.0.0.1:7007@17007 master - 0</span><br><span class="line">1570457567000 0 connected</span><br><span class="line">e7b1f1962de2a1ffef2bf1ac5d94574b2e4d67d8 127.0.0.1:7005@17005 slave</span><br><span class="line">068b678923ad0858002e906040b0fef6fff8dda4 0 1570457569609 5 connected</span><br><span class="line">068b678923ad0858002e906040b0fef6fff8dda4 127.0.0.1:7002@17002 master - 0</span><br><span class="line">1570457566000 2 connected 5461-10922</span><br><span class="line">51c3ebdd0911dd6564040c7e20b9ae69cabb0425 127.0.0.1:7004@17004 slave</span><br><span class="line">af559fc6c82c83dc39d07e2dfe59046d16b6a429 0 1570457567000 4 connected</span><br><span class="line">af559fc6c82c83dc39d07e2dfe59046d16b6a429 127.0.0.1:7001@17001 myself,master - 0</span><br><span class="line">1570457567000 1 connected 0-5460</span><br><span class="line">78dfe773eaa817fb69a405a3863f5b8fcf3e172f 127.0.0.1:7006@17006 slave</span><br><span class="line">d277cd2984639747a17ca79428602480b28ef070 0 1570457567593 6 connected</span><br></pre></td></tr></table></figure>

<p><strong>给刚添加的7007结点分配槽</strong> </p>
<ul>
<li>第一步：连接上集群（连接集群中任意一个可用结点都行） </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost 7007]<span class="comment"># ./redis-cli --cluster reshard 192.168.72.128:7007</span></span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7007)</span><br><span class="line">M: 50b073163bc4058e89d285dc5dfc42a0d1a222f2 127.0.0.1:7007</span><br><span class="line">slots: (0 slots) master</span><br><span class="line">S: 51c3ebdd0911dd6564040c7e20b9ae69cabb0425 127.0.0.1:7004</span><br><span class="line">slots: (0 slots) slave</span><br><span class="line">replicates af559fc6c82c83dc39d07e2dfe59046d16b6a429</span><br><span class="line">S: 78dfe773eaa817fb69a405a3863f5b8fcf3e172f 127.0.0.1:7006</span><br><span class="line">slots: (0 slots) slave</span><br><span class="line">replicates d277cd2984639747a17ca79428602480b28ef070</span><br><span class="line">S: e7b1f1962de2a1ffef2bf1ac5d94574b2e4d67d8 127.0.0.1:7005</span><br><span class="line">slots: (0 slots) slave</span><br><span class="line">replicates 068b678923ad0858002e906040b0fef6fff8dda4</span><br><span class="line">M: af559fc6c82c83dc39d07e2dfe59046d16b6a429 127.0.0.1:7001</span><br><span class="line">slots:[0-5460] (5461 slots) master</span><br><span class="line">1 additional replica(s)</span><br><span class="line">M: 068b678923ad0858002e906040b0fef6fff8dda4 127.0.0.1:7002</span><br><span class="line">slots:[5461-10922] (5462 slots) master</span><br><span class="line">1 additional replica(s)</span><br><span class="line">M: d277cd2984639747a17ca79428602480b28ef070 127.0.0.1:7003</span><br><span class="line">slots:[10923-16383] (5461 slots) master</span><br><span class="line">1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<ul>
<li>第二步：输入要分配的槽数量<br>   <code>How many slots do you want to move (from 1 to 16384)? 3000 </code></li>
<li>第三步：输入接收槽的结点id<br>   <code>What is the receiving node ID? </code></li>
</ul>
<p>输入：50b073163bc4058e89d285dc5dfc42a0d1a222f2 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PS：这里准备给7007分配槽，通过cluster nodes查看7007结点id为：</span><br><span class="line">50b073163bc4058e89d285dc5dfc42a0d1a222f2</span><br></pre></td></tr></table></figure>

<ul>
<li>第四步：输入源结点id </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Please enter all the <span class="built_in">source</span> node IDs.</span><br><span class="line">Type <span class="string">&#x27;all&#x27;</span> to use all the nodes as <span class="built_in">source</span> nodes <span class="keyword">for</span> the <span class="built_in">hash</span> slots.</span><br><span class="line">Type <span class="string">&#x27;done&#x27;</span> once you entered all the <span class="built_in">source</span> nodes IDs.</span><br></pre></td></tr></table></figure>

<p>输入：all </p>
<ul>
<li>第五步：输入yes开始移动槽到目标结点id<br>   <img src="https://cdn.nlark.com/yuque/0/2021/png/1316497/1626313971136-39412443-9f78-42e2-80a2-38393b338014.png" alt="img"></li>
</ul>
<p>输入：yes </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Moving slot 11913 from 192.168.127.128:7003 to 192.168.127.128:7007:</span><br><span class="line">Moving slot 11914 from 192.168.127.128:7003 to 192.168.127.128:7007:</span><br><span class="line">Moving slot 11915 from 192.168.127.128:7003 to 192.168.127.128:7007:</span><br><span class="line">Moving slot 11916 from 192.168.127.128:7003 to 192.168.127.128:7007:</span><br><span class="line">Moving slot 11917 from 192.168.127.128:7003 to 192.168.127.128:7007:</span><br><span class="line">Moving slot 11918 from 192.168.127.128:7003 to 192.168.127.128:7007:</span><br><span class="line">Moving slot 11919 from 192.168.127.128:7003 to 192.168.127.128:7007:</span><br><span class="line">Moving slot 11920 from 192.168.127.128:7003 to 192.168.127.128:7007:</span><br><span class="line">Moving slot 11921 from 192.168.127.128:7003 to 192.168.127.128:7007:</span><br></pre></td></tr></table></figure>

<p>查看结果 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:7001&gt; cluster nodes</span><br><span class="line">95598dd50a91a72812ab5d441876bf2ee40ceef4 192.168.127.128:7003@17003 master - 0</span><br><span class="line">1595301163000 3 connected 11922-16383</span><br><span class="line">6ff20bf463c954e977b213f0e36f3efc02bd53d6 192.168.127.128:7007@17007 master - 0</span><br><span class="line">1595301164568 7 connected 0-998 5461-6461 10923-11921</span><br><span class="line">2191b40176f95a2a969bdcaccdd236aa01a3099a 192.168.127.128:7005@17005 slave</span><br><span class="line">2dddc9d3925d129edd4c6bd5eab3bbad531277ec 0 1595301163000 5 connected</span><br><span class="line">633af51cfdadb907e4d930f3f10082a77b256efb 192.168.127.128:7004@17004 slave</span><br><span class="line">02fdca827762904854293590323bb398e6bee971 0 1595301164000 4 connected</span><br><span class="line">1d35bec18fcc23f2c555a25563b1e6f2ffa3b0e9 192.168.127.128:7006@17006 slave</span><br><span class="line">95598dd50a91a72812ab5d441876bf2ee40ceef4 0 1595301161521 6 connected</span><br><span class="line">2dddc9d3925d129edd4c6bd5eab3bbad531277ec 192.168.127.128:7002@17002 master - 0</span><br><span class="line">1595301162000 2 connected 6462-10922</span><br><span class="line">02fdca827762904854293590323bb398e6bee971 192.168.127.128:7001@17001</span><br><span class="line">myself,master - 0 1595301160000 1 connected 999-5460</span><br></pre></td></tr></table></figure>

<p>添加从节点</p>
<ul>
<li>添加7008从结点，将7008作为7007的从结点 </li>
</ul>
<p>命令： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-cli --cluster add-node 新节点的ip和端口 旧节点ip和端口 --cluster-slave --</span><br><span class="line">cluster-master-id 主节点id</span><br></pre></td></tr></table></figure>

<p><strong>例如：</strong> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-cli --cluster add-node 192.168.72.128:7008 192.168.72.128:7007 --</span><br><span class="line">cluster-slave --cluster-master-id 6ff20bf463c954e977b213f0e36f3efc02bd53d6</span><br></pre></td></tr></table></figure>

<p>50b073163bc4058e89d285dc5dfc42a0d1a222f2是7007结点的id，可通过cluster nodes查看。 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost bin]<span class="comment"># ./redis-cli --cluster add-node 192.168.127.128:7008</span></span><br><span class="line">192.168.127.128:7007 --cluster-slave --cluster-master-id</span><br><span class="line">6ff20bf463c954e977b213f0e36f3efc02bd53d6</span><br><span class="line">&gt;&gt;&gt; Adding node 192.168.127.128:7008 to cluster 192.168.127.128:7007</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.127.128:7007)</span><br><span class="line">M: 6ff20bf463c954e977b213f0e36f3efc02bd53d6 192.168.127.128:7007</span><br><span class="line">slots:[0-998],[5461-6461],[10923-11921] (2999 slots) master</span><br><span class="line">S: 1d35bec18fcc23f2c555a25563b1e6f2ffa3b0e9 192.168.127.128:7006</span><br><span class="line">slots: (0 slots) slave</span><br><span class="line">replicates 95598dd50a91a72812ab5d441876bf2ee40ceef4</span><br><span class="line">S: 633af51cfdadb907e4d930f3f10082a77b256efb 192.168.127.128:7004</span><br><span class="line">slots: (0 slots) slave</span><br><span class="line">replicates 02fdca827762904854293590323bb398e6bee971</span><br><span class="line">M: 2dddc9d3925d129edd4c6bd5eab3bbad531277ec 192.168.127.128:7002</span><br><span class="line">slots:[6462-10922] (4461 slots) master</span><br><span class="line">1 additional replica(s)</span><br><span class="line">M: 02fdca827762904854293590323bb398e6bee971 192.168.127.128:7001</span><br><span class="line">slots:[999-5460] (4462 slots) master</span><br><span class="line">1 additional replica(s)</span><br><span class="line">S: 2191b40176f95a2a969bdcaccdd236aa01a3099a 192.168.127.128:7005</span><br><span class="line">slots: (0 slots) slave</span><br><span class="line">replicates 2dddc9d3925d129edd4c6bd5eab3bbad531277ec</span><br><span class="line">M: 95598dd50a91a72812ab5d441876bf2ee40ceef4 192.168.127.128:7003</span><br><span class="line">slots:[11922-16383] (4462 slots) master</span><br><span class="line">1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line">&gt;&gt;&gt; Send CLUSTER MEET to node 192.168.127.128:7008 to make it join the cluster.</span><br><span class="line">Waiting <span class="keyword">for</span> the cluster to join</span><br><span class="line">&gt;&gt;&gt; Configure node as replica of 192.168.127.128:7007.</span><br><span class="line">[OK] New node added correctly.</span><br></pre></td></tr></table></figure>

<p>注意：如果原来该结点在集群中的配置信息已经生成到cluster-config-file指定的配置文件中（如果<br>cluster-config-file没有指定则默认为nodes.conf），这时可能会报错：<br> <code>[ERR] Node XXXXXX is not empty. Either the node already knows other nodes (checkwith CLUSTER NODES) or contains some key in database 0 </code></p>
<p>解决方法是删除生成的配置文件nodes.conf，删除后再执行./redis-cli –cluster add-node 指令</p>
<ul>
<li>查看集群中的结点，刚添加的7008为7007的从节点： </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost 7008]<span class="comment"># ./redis-cli -h 127.0.0.1 -p 7001 -c</span></span><br><span class="line">127.0.0.1:7001&gt; cluster nodes</span><br><span class="line">95598dd50a91a72812ab5d441876bf2ee40ceef4 192.168.127.128:7003@17003 master - 0</span><br><span class="line">1595301378000 3 connected 11922-16383</span><br><span class="line">6be94480315ab0dd2276a7f70c82c578535d6666 192.168.127.128:7008@17008 slave</span><br><span class="line">6ff20bf463c954e977b213f0e36f3efc02bd53d6 0 1595301378701 7 connected</span><br><span class="line">6ff20bf463c954e977b213f0e36f3efc02bd53d6 192.168.127.128:7007@17007 master - 0</span><br><span class="line">1595301379715 7 connected 0-998 5461-6461 10923-11921</span><br><span class="line">2191b40176f95a2a969bdcaccdd236aa01a3099a 192.168.127.128:7005@17005 slave</span><br><span class="line">2dddc9d3925d129edd4c6bd5eab3bbad531277ec 0 1595301375666 5 connected</span><br><span class="line">633af51cfdadb907e4d930f3f10082a77b256efb 192.168.127.128:7004@17004 slave</span><br><span class="line">02fdca827762904854293590323bb398e6bee971 0 1595301379000 4 connected</span><br><span class="line">1d35bec18fcc23f2c555a25563b1e6f2ffa3b0e9 192.168.127.128:7006@17006 slave</span><br><span class="line">95598dd50a91a72812ab5d441876bf2ee40ceef4 0 1595301380731 6 connected</span><br><span class="line">2dddc9d3925d129edd4c6bd5eab3bbad531277ec 192.168.127.128:7002@17002 master - 0</span><br><span class="line">1595301376000 2 connected 6462-10922</span><br><span class="line">02fdca827762904854293590323bb398e6bee971 192.168.127.128:7001@17001</span><br><span class="line">myself,master - 0 1595301376000 1 connected 999-5460</span><br></pre></td></tr></table></figure>

<h5 id="缩容"><a href="#缩容" class="headerlink" title="缩容"></a>缩容</h5><p>命令： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-cli --cluster del-node 192.168.127.128:7008</span><br><span class="line">6be94480315ab0dd2276a7f70c82c578535d6666</span><br></pre></td></tr></table></figure>

<p>删除已经占有hash槽的结点会失败，报错如下：<br> <code>[ERR] Node 192.168.127.128:7008 is not empty! Reshard data away and try again. </code></p>
<p>需要将该结点占用的hash槽分配出去。 </p>
<h4 id="容灾（failover）"><a href="#容灾（failover）" class="headerlink" title="容灾（failover）"></a>容灾（failover）</h4><h5 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h5><p>集群中的每个节点都会定期地（每秒）向集群中的其他节点发送PING消息</p>
<p>如果在一定时间内(cluster-node-timeout)，发送ping的节点A没有收到某节点B的pong回应，则A将B<br>标识为pfail。<br>A在后续发送ping时，会带上B的pfail信息， 通知给其他节点。<br>如果B被标记为pfail的个数大于集群主节点个数的一半（N/2 + 1）时，B会被标记为fail，A向整个集群<br>广播，该节点已经下线。<br>其他节点收到广播，标记B为fail。 </p>
<h5 id="从节点选举"><a href="#从节点选举" class="headerlink" title="从节点选举"></a>从节点选举</h5><p>raft，每个从节点，都根据自己对master复制数据的offset，来设置一个选举时间，offset越大（复制数<br>据越多）的从节点，选举时间越靠前，优先进行选举。<br>slave 通过向其他master发送FAILVOER_AUTH_REQUEST 消息发起竞选，<br>master 收到后回复FAILOVER_AUTH_ACK 消息告知是否同意。<br>slave 发送FAILOVER_AUTH_REQUEST 前会将currentEpoch 自增，并将最新的Epoch 带入到<br>FAILOVER_AUTH_REQUEST 消息中，如果自己未投过票，则回复同意，否则回复拒绝。<br> 所有的Master开始slave选举投票，给要进行选举的slave进行投票，如果大部分master node（N/2 +<br>1）都投票给了某个从节点，那么选举通过，那个从节点可以切换成master。<br>RedisCluster失效的判定：<br>1、集群中半数以上的主节点都宕机（无法投票）<br>2、宕机的主节点的从节点也宕机了（slot槽分配不连续） </p>
<h5 id="变更通知"><a href="#变更通知" class="headerlink" title="变更通知"></a>变更通知</h5><p>当slave 收到过半的master 同意时，会成为新的master。此时会以最新的Epoch 通过PONG 消息广播<br>自己成为master，让Cluster 的其他节点尽快的更新拓扑结构(node.conf)。 </p>
<h5 id="主从切换"><a href="#主从切换" class="headerlink" title="主从切换"></a>主从切换</h5><p>主从切换<br>自动切换<br>就是上面讲的从节点选举<br>手动切换<br>人工故障切换是预期的操作，而非发生了真正的故障，目的是以一种安全的方式(数据无丢失)将当前<br>master节点和其中一个slave节点(执行cluster-failover的节点)交换角色<br>1、向从节点发送cluster failover 命令（slaveof no one）<br>2、从节点告知其主节点要进行手动切换（CLUSTERMSG_TYPE_MFSTART）<br>3、主节点会阻塞所有客户端命令的执行（10s）<br>4、从节点从主节点的ping包中获得主节点的复制偏移量<br>5、从节点复制达到偏移量，发起选举、统计选票、赢得选举、升级为主节点并更新配置<br>6、切换完成后，原主节点向所有客户端发送moved指令重定向到新的主节点<br>以上是在主节点在线情况下。<br>如果主节点下线了，则采用cluster failover force或cluster failover takeover 进行强制切换。 </p>
<h5 id="副本漂移"><a href="#副本漂移" class="headerlink" title="副本漂移"></a>副本漂移</h5><p>我们知道在一主一从的情况下，如果主从同时挂了，那整个集群就挂了。<br>为了避免这种情况我们可以做一主多从，但这样成本就增加了。<br>Redis提供了一种方法叫副本漂移，这种方法既能提高集群的可靠性又不用增加太多的从机。<br>如图：<br> <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210715100535.png" alt="img"></p>
<p>Master1宕机，则Slaver11提升为新的Master1<br>集群检测到新的Master1是单点的（无从机）<br>集群从拥有最多的从机的节点组（Master3）中，选择节点名称字母顺序最小的从机（Slaver31）漂移<br>到单点的主从节点组(Master1)。<br>具体流程如下（以上图为例）：<br>1、将Slaver31的从机记录从Master3中删除<br>2、将Slaver31的的主机改为Master1<br>3、在Master1中添加Slaver31为从节点<br>4、将Slaver31的复制源改为Master1<br>5、通过ping包将信息同步到集群的其他节点 
 </p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小肥龙吃大冰淇淋</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://andice-cream.github.io/post/e34f1f32.html">https://andice-cream.github.io/post/e34f1f32.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://andice-cream.github.io" target="_blank">小肥龙吃大冰淇淋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post_share"><div class="social-share" data-image="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165211.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/d68a7f61.html"><img class="prev-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165209.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis大厂面试汇总</div></div></a></div><div class="next-post pull-right"><a href="/post/8a1c1c9f.html"><img class="next-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165212.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redis扩展功能</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/f345cc71.html" title="Redis-数据类型与底层数据结构"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165241.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-13</div><div class="title">Redis-数据类型与底层数据结构</div></div></a></div><div><a href="/post/d68a7f61.html" title="Redis大厂面试汇总"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165209.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-13</div><div class="title">Redis大厂面试汇总</div></div></a></div><div><a href="/post/b37f97dc.html" title="Redis企业实战"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165213.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-13</div><div class="title">Redis企业实战</div></div></a></div><div><a href="/post/8a1c1c9f.html" title="Redis扩展功能"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165212.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-13</div><div class="title">Redis扩展功能</div></div></a></div><div><a href="/post/119ed1dc.html" title="Redis持久化"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212104.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-13</div><div class="title">Redis持久化</div></div></a></div><div><a href="/post/bae4ff13.html" title="Redis"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082249.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-08</div><div class="title">Redis</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE"><span class="toc-number">1.1.</span> <span class="toc-text">主从配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BBRedis%E9%85%8D%E7%BD%AE"><span class="toc-number">1.1.1.</span> <span class="toc-text">主Redis配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8ERedis%E9%85%8D%E7%BD%AE"><span class="toc-number">1.1.2.</span> <span class="toc-text">从Redis配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-number">1.2.1.</span> <span class="toc-text">读写分离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%B9%E7%81%BE"><span class="toc-number">1.2.2.</span> <span class="toc-text">数据容灾</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text">原理与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">复制流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E4%B8%BB%E8%8A%82%E7%82%B9%E4%BF%A1%E6%81%AF"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">保存主节点信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8Bsocket%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">建立socket连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E9%80%81ping%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">发送ping命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">权限验证</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E7%AB%AF%E5%8F%A3%E4%BF%A1%E6%81%AF"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">发送端口信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">同步数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E4%BC%A0%E6%92%AD"><span class="toc-number">1.3.1.7.</span> <span class="toc-text">命令传播</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE%E9%9B%86"><span class="toc-number">1.3.2.</span> <span class="toc-text">同步数据集</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A7%E7%89%88%E6%9C%AC"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">旧版本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B0%E7%89%88"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">新版</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B"><span class="toc-number">1.3.3.</span> <span class="toc-text">心跳检测</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">哨兵模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88"><span class="toc-number">2.1.</span> <span class="toc-text">部署方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E9%85%8D%E7%BD%AE"><span class="toc-number">2.2.</span> <span class="toc-text">搭建配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%B9%B6%E5%88%9D%E5%A7%8B%E5%8C%96Sentinel"><span class="toc-number">2.3.1.</span> <span class="toc-text">启动并初始化Sentinel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E4%B8%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BF%A1%E6%81%AF"><span class="toc-number">2.3.2.</span> <span class="toc-text">获取主服务器信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BF%A1%E6%81%AF"><span class="toc-number">2.3.3.</span> <span class="toc-text">获取从服务器信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E4%B8%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF-%E4%BB%A5%E8%AE%A2%E9%98%85%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.4.</span> <span class="toc-text">向主服务器和从服务器发送消息(以订阅的方式)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E6%9D%A5%E8%87%AA%E4%B8%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%A2%91%E9%81%93%E4%BF%A1%E6%81%AF"><span class="toc-number">2.3.5.</span> <span class="toc-text">接收来自主服务器和从服务器的频道信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E4%B8%BB%E8%A7%82%E4%B8%8B%E7%BA%BF%E7%8A%B6%E6%80%81"><span class="toc-number">2.3.6.</span> <span class="toc-text">检测主观下线状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E5%AE%A2%E8%A7%82%E4%B8%8B%E7%BA%BF%E7%8A%B6%E6%80%81"><span class="toc-number">2.3.7.</span> <span class="toc-text">检查客观下线状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E4%B8%BELeader-Sentinel"><span class="toc-number">2.3.8.</span> <span class="toc-text">选举Leader Sentinel</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%A8%E5%85%B5leader%E9%80%89%E4%B8%BE"><span class="toc-number">2.4.</span> <span class="toc-text">哨兵leader选举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-number">2.5.</span> <span class="toc-text">故障转移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">2.6.</span> <span class="toc-text">主服务器的选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%8C%BA"><span class="toc-number">3.</span> <span class="toc-text">集群与分区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">分区的意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">分区的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E5%88%86%E5%8C%BA"><span class="toc-number">3.2.1.</span> <span class="toc-text">范围分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hash%E5%88%86%E5%8C%BA"><span class="toc-number">3.2.2.</span> <span class="toc-text">hash分区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#client%E7%AB%AF%E5%88%86%E5%8C%BA"><span class="toc-number">3.3.</span> <span class="toc-text">client端分区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88-1"><span class="toc-number">3.3.1.</span> <span class="toc-text">部署方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95"><span class="toc-number">3.3.2.</span> <span class="toc-text">客户端选择算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#hash"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">hash</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7hash"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">一致性hash</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">3.3.3.</span> <span class="toc-text">缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%AB%98"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">复杂度高</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E6%98%93%E6%89%A9%E5%B1%95"><span class="toc-number">3.3.3.2.</span> <span class="toc-text">不易扩展</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proxy%E7%AB%AF%E5%88%86%E5%8C%BA"><span class="toc-number">3.4.</span> <span class="toc-text">proxy端分区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84"><span class="toc-number">3.4.1.</span> <span class="toc-text">部署架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%89%87%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.2.</span> <span class="toc-text">分片原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-amp-%E7%BC%BA%E7%82%B9"><span class="toc-number">3.4.3.</span> <span class="toc-text">优点&amp;缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%98%E6%96%B9cluster%E5%88%86%E5%8C%BA"><span class="toc-number">3.5.</span> <span class="toc-text">官方cluster分区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84-1"><span class="toc-number">3.5.1.</span> <span class="toc-text">部署架构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">去中心化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Gossip%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.5.1.2.</span> <span class="toc-text">Gossip协议</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#slot"><span class="toc-number">3.5.1.3.</span> <span class="toc-text">slot</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RedisCluster%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">3.5.1.4.</span> <span class="toc-text">RedisCluster的优势</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%89%87"><span class="toc-number">3.5.2.</span> <span class="toc-text">分片</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B7%AF%E7%94%B1"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">客户端路由</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%81%E7%A7%BB"><span class="toc-number">3.5.2.2.</span> <span class="toc-text">迁移</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9"><span class="toc-number">3.5.2.3.</span> <span class="toc-text">扩容</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%A9%E5%AE%B9"><span class="toc-number">3.5.2.4.</span> <span class="toc-text">缩容</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E7%81%BE%EF%BC%88failover%EF%BC%89"><span class="toc-number">3.5.3.</span> <span class="toc-text">容灾（failover）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E6%A3%80%E6%B5%8B"><span class="toc-number">3.5.3.1.</span> <span class="toc-text">故障检测</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8E%E8%8A%82%E7%82%B9%E9%80%89%E4%B8%BE"><span class="toc-number">3.5.3.2.</span> <span class="toc-text">从节点选举</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E6%9B%B4%E9%80%9A%E7%9F%A5"><span class="toc-number">3.5.3.3.</span> <span class="toc-text">变更通知</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2"><span class="toc-number">3.5.3.4.</span> <span class="toc-text">主从切换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%AF%E6%9C%AC%E6%BC%82%E7%A7%BB"><span class="toc-number">3.5.3.5.</span> <span class="toc-text">副本漂移</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 小肥龙吃大冰淇淋</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="framework-info"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202301132049386.png"/><span> </span><a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">晋ICP备2022012091号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'pinglun-9gh2lmcnd8587831',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'pinglun-9gh2lmcnd8587831',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@latest/source/js/issues.min.js"></script><script src="//code.tidio.co/smwivpnwumemac2wohardi3d3gpud1ag.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>